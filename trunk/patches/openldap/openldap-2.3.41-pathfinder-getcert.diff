diff -urN openldap-2.3.41-clean/GPL_getcert openldap-2.3.41-pathfinder-getcert/GPL_getcert
--- openldap-2.3.41-clean/GPL_getcert	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/GPL_getcert	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -urN openldap-2.3.41-clean/README_getcert openldap-2.3.41-pathfinder-getcert/README_getcert
--- openldap-2.3.41-clean/README_getcert	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/README_getcert	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,24 @@
+
+
+
+        The getcert_4.x package is a source code bundle that is to be
+        combined with the sourcecode of OpenLDAP 2.1.30 in order to
+        build an LDAP Proxy capable of searching for and retrieving
+        public X.509 user certificates for use in email encryption.
+
+        See the file "ldap_proxy_build.txt" in this directory for 
+        specific build instructions.  Pre-compiled versions of the
+        LDAP Proxy for Linux and Solaris systems are available for
+        download from the Boeing LDAP Proxy project page at:
+
+        http://ldap-proxy.sourceforge.net
+
+        Full documentation on the LDAP Proxy is available at:
+
+        http://ldap-proxy.sourceforge.net/ldap_proxy_release_notes.html
+
+
+-- 
+    Marc Amis    Boeing Information Technology
+                 Bellevue, Washington, USA
+                 marc.amis@boeing.com
diff -urN openldap-2.3.41-clean/build/top.mk openldap-2.3.41-pathfinder-getcert/build/top.mk
--- openldap-2.3.41-clean/build/top.mk	2008-02-11 18:24:07.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/build/top.mk	2008-03-25 12:18:48.000000000 -0400
@@ -200,6 +200,10 @@
 SLAPD_LIBS = @SLAPD_LIBS@ @SLAPD_PERL_LDFLAGS@ @SLAPD_SQL_LDFLAGS@ @SLAPD_SQL_LIBS@ @SLAPD_SLP_LIBS@ @SLAPD_GMP_LIBS@
 SLURPD_LIBS = @SLURPD_LIBS@
 
+PATHFINDER_INC = @PATHFINDER_INC@
+PATHFINDER_LIBS = @PATHFINDER_LIBS@
+
+
 # Our Defaults
 CC = $(AC_CC)
 DEFS = $(LDAP_INCPATH) $(XINCPATH) $(XDEFS) $(AC_DEFS) $(DEFINES)
diff -urN openldap-2.3.41-clean/clients/tools/Makefile.in openldap-2.3.41-pathfinder-getcert/clients/tools/Makefile.in
--- openldap-2.3.41-clean/clients/tools/Makefile.in	2008-02-11 18:24:07.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/clients/tools/Makefile.in	2008-03-25 12:18:48.000000000 -0400
@@ -22,7 +22,7 @@
 MKVOPTS = -s
 
 XLIBS =  $(LDAP_L)
-XXLIBS	= $(SECURITY_LIBS) $(LUTIL_LIBS)
+XXLIBS	= $(SECURITY_LIBS) $(LUTIL_LIBS) $(PATHFINDER_LIBS)
 
 XSRCS	= ldsversion.c ldmversion.c lddversion.c ldrversion.c \
 	ldpversion.c ldwversion.c ldcversion.c
diff -urN openldap-2.3.41-clean/configure.in openldap-2.3.41-pathfinder-getcert/configure.in
--- openldap-2.3.41-clean/configure.in	2008-02-11 18:24:06.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/configure.in	2008-03-25 12:18:48.000000000 -0400
@@ -256,6 +256,9 @@
 OL_ARG_WITH(odbc,
 	[  --with-odbc             with specific ODBC support iodbc|unixodbc|auto],
 	auto, [auto iodbc unixodbc] )
+OL_ARG_WITH(pathfinder,
+	[  --with-pathfinder       with libpathfinder support],
+	auto, [auto yes no] )
 
 dnl ----------------------------------------------------------------
 dnl Server options
@@ -284,6 +287,7 @@
 dnl SLAPD Backend Options
 Backends="bdb \
 	dnssrv \
+	getcert \
 	hdb \
 	ldap \
 	ldbm \
@@ -305,6 +309,8 @@
 	yes, [no yes mod], ol_enable_backends)dnl
 OL_ARG_ENABLE(dnssrv,[    --enable-dnssrv	  enable dnssrv backend],
 	no, [no yes mod], ol_enable_backends)dnl
+OL_ARG_ENABLE(getcert,[    --enable-getcert	  enable ldap-proxy backend],
+	yes, [no yes mod], ol_enable_backends)dnl
 OL_ARG_ENABLE(hdb,[    --enable-hdb	  enable Hierarchical DB backend],
 	yes, [no yes mod], ol_enable_backends)dnl
 OL_ARG_ENABLE(ldap,[    --enable-ldap	  enable ldap backend],
@@ -493,6 +499,7 @@
 	if test $ol_enable_modules != yes &&
 	   test $ol_enable_bdb = no &&
 	   test $ol_enable_dnssrv = no &&
+           test $ol_enable_getcert = no &&
 	   test $ol_enable_hdb = no &&
 	   test $ol_enable_ldap = no &&
 	   test $ol_enable_meta = no &&
@@ -604,6 +611,7 @@
 SLAPD_SLAPI_DEPEND=
 
 BUILD_BDB=no
+BUILD_GETCERT=no
 BUILD_DNSSRV=no
 BUILD_HDB=no
 BUILD_LDAP=no
@@ -2307,6 +2315,37 @@
 fi
 
 dnl ----------------------------------------------------------------
+dnl
+dnl Check for libpathfinder
+dnl
+ol_link_pathfinder=no
+if test $ol_with_pathfinder != no ; then
+    AC_CHECK_HEADERS(pathfinder-1/libpathfinder.h)
+
+    if test $ac_cv_header_pathfinder_1_libpathfinder_h = yes ; then
+        save_LIBS="$LIBS"
+        LIBS="-lpathfinder-openssl-1 -ldbus-1 -lssl $LIBS"
+        AC_CHECK_LIB(pathfinder-openssl-1, pathfinder_dbus_verify, 
+                           [have_pathfinder=yes], [have_pathfinder=no])
+        LIBS="$save_LIBS"
+
+        if test $have_pathfinder = yes ; then
+            ol_with_pathfinder=found
+            ol_link_pathfinder=yes
+
+            PATHFINDER_INC=$(pkg-config --cflags pathfinder-openssl)
+            PATHFINDER_LIBS=$(pkg-config --libs pathfinder-openssl)
+        fi
+    fi
+fi
+                                                             
+if test $ol_link_pathfinder = yes ; then                     
+       AC_DEFINE(HAVE_PATHFINDER, 1, [define if you have -lpathfinder-openssl-1])                                                            
+fi                                                           
+                                                             
+
+
+dnl ----------------------------------------------------------------
 dnl FreeBSD (and others) have crypt(3) in -lcrypt
 if test $ol_enable_crypt != no ; then
 	save_LIBS="$LIBS"
@@ -2731,6 +2770,19 @@
 	AC_DEFINE_UNQUOTED(SLAPD_DNSSRV,$MFLAG,[define to support DNS SRV backend])
 fi
 
+if test "$ol_enable_getcert" != no ; then
+	BUILD_SLAPD=yes
+	BUILD_GETCERT=$ol_enable_getcert
+	if test "$ol_enable_getcert" = mod ; then
+		SLAPD_DYNAMIC_BACKENDS="$SLAPD_DYNAMIC_BACKENDS back-getcert"
+		MFLAG=SLAPD_MOD_DYNAMIC
+	else
+		SLAPD_STATIC_BACKENDS="$SLAPD_STATIC_BACKENDS back-getcert"
+		MFLAG=SLAPD_MOD_STATIC
+	fi
+	AC_DEFINE_UNQUOTED(SLAPD_GETCERT, $MFLAG,[define to support GETCERT backend])
+fi
+
 if test "$ol_enable_hdb" != no ; then
 	BUILD_SLAPD=yes
 	BUILD_HDB=$ol_enable_hdb
@@ -3106,6 +3158,7 @@
 dnl backends
   AC_SUBST(BUILD_BDB)
   AC_SUBST(BUILD_DNSSRV)
+  AC_SUBST(BUILD_GETCERT)
   AC_SUBST(BUILD_HDB)
   AC_SUBST(BUILD_LDAP)
   AC_SUBST(BUILD_LDBM)
@@ -3138,6 +3191,7 @@
 AC_SUBST(LDAP_LIBS)
 AC_SUBST(SLAPD_LIBS)
 AC_SUBST(SLURPD_LIBS)
+AC_SUBST(GETCERT_LIBS)
 AC_SUBST(LDBM_LIBS)
 AC_SUBST(LTHREAD_LIBS)
 AC_SUBST(LUTIL_LIBS)
@@ -3173,6 +3227,10 @@
 AC_SUBST(SLAPD_SQL_LIBS)
 AC_SUBST(SLAPD_SQL_INCLUDES)
 
+AC_SUBST(PATHFINDER_INC)
+AC_SUBST(PATHFINDER_LIBS)
+
+
 dnl ----------------------------------------------------------------
 dnl final help output
 AC_ARG_WITH(xxinstall,[
@@ -3203,6 +3261,7 @@
 [servers/slapd/Makefile:build/top.mk:servers/slapd/Makefile.in:build/srv.mk]
 [servers/slapd/back-bdb/Makefile:build/top.mk:servers/slapd/back-bdb/Makefile.in:build/mod.mk]
 [servers/slapd/back-dnssrv/Makefile:build/top.mk:servers/slapd/back-dnssrv/Makefile.in:build/mod.mk]
+[servers/slapd/back-getcert/Makefile:build/top.mk:servers/slapd/back-getcert/Makefile.in:build/mod.mk]
 [servers/slapd/back-hdb/Makefile:build/top.mk:servers/slapd/back-hdb/Makefile.in:build/mod.mk]
 [servers/slapd/back-ldap/Makefile:build/top.mk:servers/slapd/back-ldap/Makefile.in:build/mod.mk]
 [servers/slapd/back-ldbm/Makefile:build/top.mk:servers/slapd/back-ldbm/Makefile.in:build/mod.mk]
diff -urN openldap-2.3.41-clean/ldap_proxy_build.txt openldap-2.3.41-pathfinder-getcert/ldap_proxy_build.txt
--- openldap-2.3.41-clean/ldap_proxy_build.txt	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/ldap_proxy_build.txt	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,151 @@
+
+
+    Building LDAP Proxy version 4.0 from Source Code            September 2004
+    ------------------------------------------------
+
+    [NOTE: Replace "4.0" in the following instructions with the
+           actual version of the LDAP Proxy you are building.]
+
+
+    LDAP Proxy version 4.0 will compile on either Linux or Sun/Solaris systems.
+
+    Prerequisites:
+
+        OpenLDAP 2.1.30
+
+                Available from http://www.openldap.org/.  
+                The LDAP Proxy is not compatible with
+                OpenLDAP 2.2.x or OpenLDAP 2.3.x.
+
+        getcert 4.0
+
+                Available from SourceForge.net or Boeing.
+                Contents:
+                    ldap_proxy_4.0_source/configure.in
+                    ldap_proxy_4.0_source/servers/slapd/back-getcert/
+                    ldap_proxy_4.0_source/servers/slapd/backend.c
+                    ldap_proxy_4.0_source/servers/slapd/result.c
+
+        autoconf 2.13.1
+
+                Used to build the OpenLDAP configuration file.
+                This is a very old version of autoconf required by OpenLDAP.
+                Note that version 2.13 won't work with OpenLDAP 2.1.30.
+                Available from http://www.gnu.org/software/autoconf/
+
+        automake 1.4a
+        libtool 1.4.2
+
+                Used by autoconf.
+                Available from the GNU org: ftp://ftp.gnu.org/pub/gnu/
+
+
+
+    1) Install the autoconf, automake, and libtool packages according to
+        the "INSTALL" file contained in each package.
+
+
+    2) Unpack the OpenLDAP 2.1.30 source code and rename it to
+        "ldap_proxy_4.0_source".
+
+
+                gunzip openldap-2.1.30.tgz
+                tar xf openldap-2.1.30.tar
+                mv openldap-2.1.30 ldap_proxy_4.0_source
+                rm openldap-2.1.30.tar
+
+
+    3) Uncompress and untar the getcert software into the top level of the
+        OpenLDAP source code tree. 
+
+
+                cd ldap_proxy_4.0_source
+                gunzip getcert_4.0.tar.gz
+                tar xf getcert_4.0.tar
+                rm getcert_4.0.tar
+
+
+    4) Set your CC, CPPFLAGS, and CFLAGS environment variables.
+        For example, using the Korn shell:
+
+                export CC=gcc
+                export CPPFLAGS="-DFD_SETSIZE=8192 -DNDEBUG"
+                
+        For Solaris: export CFLAGS="-O -g -D_REENTRANT"
+        For Linux:   export CFLAGS="-O -g"
+
+        If autoconf version 2.13.1 is not the first autoconf in your PATH,
+        set your PATH environment variable (example using the Korn shell):
+
+                export PATH=/usr/local/autoconf_2.13.1/bin:$PATH
+
+
+    5) Build the LDAP Proxy configuration file:
+
+
+                cd ldap_proxy_4.0_source
+                autoconf
+                autoheader
+
+        You can ignore the warning issued by autoconf about "AC_TRY_RUN".
+        You must re-run autoconf and autoheader whenever you make changes
+        to the "configure.in" file.
+
+
+    6) Build the new configuration.  Set the "--prefix" option to the full 
+        path of the directory you will be installing the LDAP Proxy into.
+
+
+        cd ldap_proxy_4.0_source
+        ./configure --prefix=/usr/local/apps/ldap_proxy_4.0 \
+            --with-threads --without-tls --without-cyrus-sasl \
+            --enable-debug --enable-syslog --enable-slapd --enable-getcert \
+            --disable-ipv6 --disable-rlookups --disable-slurpd --disable-bdb
+
+
+    7) Build and install the LDAP Proxy.  Be sure you have read/write access
+        to the install directory specified by the "--prefix" option in the 
+        configure command above.
+
+
+        cd ldap_proxy_4.0_source
+        make depend
+        make
+        make install
+
+
+    8) Copy the LDAP Proxy support files into the newly installed LDAP proxy:
+
+
+        cd ldap_proxy_4.0_source/servers/slapd/back-getcert/PROTO_FILES/
+        tar cf - * | (cd /usr/local/apps/ldap_proxy_4.0; tar xlpf -)
+
+
+    9) Set ownership and permission attributes in the installed LDAP Proxy:
+
+        Log in as "root".
+        cd /usr/local/apps/ldap_proxy_4.0/bin/
+        # Edit the "PROXYHOME" line in the "set_permissions.sh"
+        # script to point to the LDAP Proxy install directory
+        # (Example: "PROXYHOME=/usr/local/apps/ldap_proxy_4.0").
+        ./set_permissions.sh
+
+
+    At this point the installed LDAP Proxy should look like the pre-compiled
+    version Boeing distributes.  Continue with the configuration steps in
+    section 6 (Proxy Administration) of the main LDAP Proxy web page
+    "ldap_proxy_release_notes.html" now located in
+    "/usr/local/apps/ldap_proxy_4.0/docs/".
+
+
+                Marc Amis      September 2004
+                Boeing Information Technology
+                Bellevue, Washington      USA
+
+    -----------------------------------------------------------------------
+    LDAP Proxy Team
+
+    Wen Fang     -  Architecture & Design         -  wen.fang@boeing.com
+    Marc Amis    -  Development & Implementation  -  marc.amis@boeing.com
+    Darryl Lang  -  Proxy Administration          -  darryl.p.lang@boeing.com
+    -----------------------------------------------------------------------
diff -urN openldap-2.3.41-clean/servers/slapd/Makefile.in openldap-2.3.41-pathfinder-getcert/servers/slapd/Makefile.in
--- openldap-2.3.41-clean/servers/slapd/Makefile.in	2008-02-11 18:24:14.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/Makefile.in	2008-03-25 12:18:48.000000000 -0400
@@ -73,7 +73,7 @@
 XLDFLAGS = $(MODULES_LDFLAGS)
 
 XLIBS = $(SLAPD_STATIC_DEPENDS) $(SLAPD_L) $(MODULES_LIBS) 
-XXLIBS = $(SLAPD_LIBS) $(SECURITY_LIBS) $(LUTIL_LIBS)
+XXLIBS = $(SLAPD_LIBS) $(SECURITY_LIBS) $(LUTIL_LIBS) $(PATHFINDER_LIBS)
 XXXLIBS = $(LTHREAD_LIBS) $(SLAPI_LIBS)
 
 BUILD_OPT = "--enable-slapd"
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/Makefile.in openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/Makefile.in
--- openldap-2.3.41-clean/servers/slapd/back-getcert/Makefile.in	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/Makefile.in	2008-03-25 12:18:48.000000000 -0400
@@ -0,0 +1,23 @@
+# Makefile.in  version "3.0  5/20/2004";
+
+SRCS	= init.c config.c open.c bind.c unbind.c search.c close.c read_cert_serverlist.c read_ldap_serverlist.c
+OBJS	= init.lo config.lo open.lo bind.lo unbind.lo search.lo close.lo read_cert_serverlist.lo read_ldap_serverlist.lo
+
+LDAP_INCDIR= ../../../include       
+LDAP_LIBDIR= ../../../libraries
+
+BUILD_OPT = "--enable-getcert"
+BUILD_MOD = @BUILD_GETCERT@
+
+LIBBASE = back_getcert
+
+LINKAGE = static
+
+XINCPATH = -I.. -I$(srcdir)/.. $(PATHFINDER_INC)
+XDEFS = $(MODULES_CPPFLAGS)
+
+all-local-lib:	../.backend
+
+../.backend: lib$(LIBBASE).a
+	@touch $@
+
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/README openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/README
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/README	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/README	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,13 @@
+
+
+        Documentation including installation, configuration,
+        and operation information is in:
+
+	doc/ldap_proxy_release_notes.html
+
+
+-- 
+    Marc Amis    Boeing Information Technology    Bellevue, Washington, USA
+                 Internet Infrastructure Services
+                 marc.amis@boeing.com
+
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/bin/set_permissions.sh openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/bin/set_permissions.sh
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/bin/set_permissions.sh	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/bin/set_permissions.sh	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,33 @@
+#!/bin/sh
+#
+#  Set default file ownership and permissions 
+#  on the LDAP Proxy install base.
+#
+PROXYHOME=/usr/local/apps/ldap_proxy_4.2
+
+if test ! -d $PROXYHOME
+then
+    echo "ERROR: Cannot find LDAP Proxy at ${PROXYHOME}."
+    exit 1
+fi
+
+find $PROXYHOME -type d -exec chmod 750 {} \;
+chmod 755 $PROXYHOME
+chmod 755 $PROXYHOME/doc
+chmod 644 $PROXYHOME/doc/*
+chmod 755 $PROXYHOME/doc/flowcharts
+chmod 444 $PROXYHOME/README
+chmod 755 $PROXYHOME/bin
+chmod 555 $PROXYHOME/bin/*
+chmod 750 $PROXYHOME/bin/s*
+chmod -R 755 $PROXYHOME/lib
+chmod -R 644 $PROXYHOME/include/*
+chmod 644 $PROXYHOME/lib/libl*a
+chmod 640 $PROXYHOME/libexec/*.txt >/dev/null
+chmod 750 $PROXYHOME/libexec/slapd
+chmod 640 $PROXYHOME/etc/openldap/slapd.conf
+chmod 550 $PROXYHOME/man $PROXYHOME/man/*
+chmod 444 $PROXYHOME/man/*/*
+chmod 550 $PROXYHOME/sbin/*
+
+exit 0
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/bin/start_ldap_proxy openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/bin/start_ldap_proxy
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/bin/start_ldap_proxy	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/bin/start_ldap_proxy	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,47 @@
+#!/bin/sh
+#
+# Start up ldap_proxy
+# marc.amis@boeing.com
+#
+PROXYHOME=/usr/local/apps/ldap_proxy_4.2
+
+#
+# Choose which port this LDAP Proxy will listen on for LDAP commands.
+# Port 389 is the standard LDAP port and is known by LDAP clients.
+# If you choose a port number less than 1024, the LDAP Proxy must be
+# started and run by the root account.  A port number higher than 1024
+# will allow any userid to run the proxy, but LDAP clients would need
+# to know what new port number this proxy was listening on.
+#
+LDAP_PORT=389
+
+# Increase the number of available file descriptors if
+# this is a Solaris system.  Linux systems default to 1024.
+ulimit -n 1024
+
+# Only root can use privileged ports (port numbers less than 1024).
+USERID="`id | cut -f1 -d'(' | cut -c5-`"
+if test "$USERID" -ne 0 -a $LDAP_PORT -lt 1024
+then 
+     echo
+     echo "ERROR: You must be root to start this ldap_proxy."
+     echo
+fi
+
+if test -x $PROXYHOME/libexec/slapd
+then 
+#
+#  If you run multiple LDAP Proxies on the same system at the same
+#  time, use the "-h" option to select different ports to listen on
+#  and use the "-l" option to allow logging to different log files.
+#  See the LDAP Proxy documentation for more information.
+#  
+     $PROXYHOME/libexec/slapd -h "ldap://0.0.0.0:${LDAP_PORT}/" \
+	-f $PROXYHOME/etc/openldap/slapd.conf
+else
+     echo 
+     echo "ERROR: Cannot run $PROXYHOME/libexec/slapd"
+     echo
+fi
+
+exit 0
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/bin/stop_ldap_proxy openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/bin/stop_ldap_proxy
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/bin/stop_ldap_proxy	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/bin/stop_ldap_proxy	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,68 @@
+#!/bin/sh
+#
+PROXYHOME=/usr/local/apps/ldap_proxy_4.2
+
+# marc.amis@boeing.com
+#
+# Stop this instance of the LDAP Proxy by stopping the "slapd" process.
+#
+# *NOTE*
+# Al alternate way to stop this Proxy:
+# Look for the particular "slapd" you want
+# to stop in the "ps -ef" output list and 
+# kill it via:
+#     "kill -1 <pid>"
+# where <pid> is the process ID of the slapd process.
+#
+# If this LDAP Proxy was started by root,
+# it may need to be stopped by root.
+
+# Find the process ID of this slapd instance.
+#
+if test -s $PROXYHOME/var/slapd.pid
+then 
+    PID=`cat $PROXYHOME/var/slapd.pid`
+    if test "$PID" -gt 1 -a "$PID" -lt 32768 
+    then
+	for PASS in 1 2 3 4
+	do
+	    kill -1 $PID 2>/dev/null
+	    sleep 3
+            PNAME=`ps -o comm -p $PID | fgrep slapd | awk '{ print $1 }'`
+	    if test -z "$PNAME" 
+	    then
+		exit 0
+	    fi
+	done
+
+    	echo "LDAP Proxy not stopping.  Attempting to kill it."
+    	for PASS in 1 2 3 4
+    	do
+	    kill -9 $PID 2>/dev/null
+	    sleep 3
+	    PNAME=`ps -o comm -p $PID | fgrep slapd | awk '{ print $1 }'`
+	    if test -z "$PNAME"
+	    then
+		echo "LDAP Proxy killed"
+		exit 0
+	    fi
+	done
+
+        echo
+        echo "ERROR: Cannot stop LDAP Proxy (PID=$PID)."
+        echo
+        exit 1
+    else
+	echo
+	echo "ERROR: Invalid process ID ($PID)"
+ 	echo
+	exit 1
+    fi
+else
+    echo
+    echo "ERROR: The LDAP Proxy does not appear to be running."
+    echo
+    exit 1
+fi
+
+exit 0
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/COPYRIGHT_CMU openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/COPYRIGHT_CMU
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/COPYRIGHT_CMU	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/COPYRIGHT_CMU	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,29 @@
+
+    This statement refers to the base64_encode() routine 
+    included in the source code of the LDAP Proxy.
+
+
+/***********************************************************
+        Copyright 1998 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/COPYRIGHT_OpenLDAP openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/COPYRIGHT_OpenLDAP
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/COPYRIGHT_OpenLDAP	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/COPYRIGHT_OpenLDAP	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,62 @@
+Copyright 1998-2004 The OpenLDAP Foundation
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted only as authorized by the OpenLDAP
+Public License.
+
+A copy of this license is available in the file LICENSE in the
+top-level directory of the distribution or, alternatively, at
+<http://www.OpenLDAP.org/license.html>.
+
+OpenLDAP is a registered trademark of the OpenLDAP Foundation.
+
+Individual files and/or contributed packages may be copyright by
+other parties and subject to additional restrictions.
+
+This work is derived from the University of Michigan LDAP v3.3
+distribution.  Information concerning this software is available
+at <http://www.umich.edu/~dirsvcs/ldap/>.
+
+This work also contains materials derived from public sources.
+
+Additional information about OpenLDAP can be obtained at
+<http://www.openldap.org/>.
+
+---
+
+Portions Copyright 1998-2004 Kurt D. Zeilenga.
+Portions Copyright 1998-2004 Net Boolean Incorporated.
+Portions Copyright 2001-2004 IBM Corporation.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted only as authorized by the OpenLDAP
+Public License.
+
+---
+
+Portions Copyright 1999-2003 Howard Y.H. Chu.
+Portions Copyright 1999-2003 Symas Corporation.
+Portions Copyright 1998-2003 Hallvard B. Furuseth.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that this notice is preserved.
+The names of the copyright holders may not be used to endorse or
+promote products derived from this software without their specific
+prior written permission.  This software is provided ``as is''
+without express or implied warranty.
+
+---
+
+Portions Copyright (c) 1992-1996 Regents of the University of Michigan.
+All rights reserved.
+
+Redistribution and use in source and binary forms are permitted
+provided that this notice is preserved and that due credit is given
+to the University of Michigan at Ann Arbor.  The name of the
+University may not be used to endorse or promote products derived
+from this software without specific prior written permission.  This
+software is provided ``as is'' without express or implied warranty.
+
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/GPL_getcert openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/GPL_getcert
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/GPL_getcert	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/GPL_getcert	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/LICENSE_OpenLDAP openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/LICENSE_OpenLDAP
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/LICENSE_OpenLDAP	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/LICENSE_OpenLDAP	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,47 @@
+The OpenLDAP Public License
+  Version 2.8, 17 August 2003
+
+Redistribution and use of this software and associated documentation
+("Software"), with or without modification, are permitted provided
+that the following conditions are met:
+
+1. Redistributions in source form must retain copyright statements
+   and notices,
+
+2. Redistributions in binary form must reproduce applicable copyright
+   statements and notices, this list of conditions, and the following
+   disclaimer in the documentation and/or other materials provided
+   with the distribution, and
+
+3. Redistributions must contain a verbatim copy of this document.
+
+The OpenLDAP Foundation may revise this license from time to time.
+Each revision is distinguished by a version number.  You may use
+this Software under terms of this license revision or under the
+terms of any subsequent revision of the license.
+
+THIS SOFTWARE IS PROVIDED BY THE OPENLDAP FOUNDATION AND ITS
+CONTRIBUTORS ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
+INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT
+SHALL THE OPENLDAP FOUNDATION, ITS CONTRIBUTORS, OR THE AUTHOR(S)
+OR OWNER(S) OF THE SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+The names of the authors and copyright holders must not be used in
+advertising or otherwise to promote the sale, use or other dealing
+in this Software without specific, written prior permission.  Title
+to copyright in this Software shall at all times remain with copyright
+holders.
+
+OpenLDAP is a registered trademark of the OpenLDAP Foundation.
+
+Copyright 1999-2003 The OpenLDAP Foundation, Redwood City,
+California, USA.  All Rights Reserved.  Permission to copy and
+distribute verbatim copies of this document is granted.
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fa.html openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fa.html
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fa.html	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fa.html	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,54 @@
+<html>
+<head>
+<title>LDAP Proxy Release Notes</title>
+</head>
+<body bgcolor="aqua">
+
+<center>
+<h1>The LDAP Proxy Flowcharts</h1>
+<p>
+<h2>Click on red boxes for individual flow charts.</h2>
+<hr>
+<p>
+<img src="flow_map_3x3.jpeg" border=0 height=237 width=921 usemap=#flowmap>
+<map name=flowmap>
+  <area shape=rect coords="1,92,90,140"     href=ldap_proxy_flowcharts.html>
+  <area shape=rect coords="129,86,207,148"  href=ldap_proxy_flowcharts.html>
+  <area shape=rect coords="244,3,325,236"   href=chart_gc.html>
+  <area shape=rect coords="363,5,488,69"    href=chart_fca.html>
+  <area shape=rect coords="532,5,646,69"    href=chart_fcb.html>
+  <area shape=rect coords="688,6,802,69"    href=chart_fcc.html>
+  <area shape=rect coords="364,97,455,142"  href=chart_fo.html>
+  <area shape=rect coords="366,174,435,219" href=chart_fa.html>
+  <area shape=rect coords="857,98,916,140"  href=ldap_proxy_flowcharts.html>
+</map>
+
+<p>
+<hr>
+</center>
+<a href=/pub/ldap_proxy/ldap_proxy_release_notes.html>
+  <b>LDAP Proxy Release Notes</b>
+</a>
+<center>
+<p>
+<img src=find_all_3x3.jpeg border=0>
+<hr>
+<p>
+<a href=/pub/ldap_proxy/ldap_proxy_release_notes.html>
+  <b>LDAP Proxy Release Notes</b>
+</a>
+<p>
+
+<i>Last Update: August 2006<br>
+  Marc Amis - <a href="mailto:ldap.proxy@boeing.com">LDAP Proxy Team</a>
+</i>
+
+<p>
+<a href="http://sourceforge.net">
+    <img src="http://sourceforge.net/sflogo.php?group_id=126646&amp;type=3"
+    width="125" height="37" border="0" alt="SourceForge.net Logo">
+</a>
+</center>
+
+</body>
+</html>
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fca.html openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fca.html
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fca.html	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fca.html	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,54 @@
+<html>
+<head>
+<title>LDAP Proxy Release Notes</title>
+</head>
+<body bgcolor="aqua">
+
+<center>
+<h1>The LDAP Proxy Flowcharts</h1>
+<p>
+<h2>Click on red boxes for individual flow charts.</h2>
+<hr>
+<p>
+<img src="flow_map_3x3.jpeg" border=0 height=237 width=921 usemap=#flowmap>
+<map name=flowmap>
+  <area shape=rect coords="1,92,90,140"     href=ldap_proxy_flowcharts.html>
+  <area shape=rect coords="129,86,207,148"  href=ldap_proxy_flowcharts.html>
+  <area shape=rect coords="244,3,325,236"   href=chart_gc.html>
+  <area shape=rect coords="363,5,488,69"    href=chart_fca.html>
+  <area shape=rect coords="532,5,646,69"    href=chart_fcb.html>
+  <area shape=rect coords="688,6,802,69"    href=chart_fcc.html>
+  <area shape=rect coords="364,97,455,142"  href=chart_fo.html>
+  <area shape=rect coords="366,174,435,219" href=chart_fa.html>
+  <area shape=rect coords="857,98,916,140"  href=ldap_proxy_flowcharts.html>
+</map>
+
+<p>
+<hr>
+</center>
+<a href=/pub/ldap_proxy/ldap_proxy_release_notes.html>
+  <b>LDAP Proxy Release Notes</b>
+</a>
+<center>
+<p>
+<img src=find_certificate_A_3x3.jpeg border=0>
+<hr>
+<p>
+<a href=/pub/ldap_proxy/ldap_proxy_release_notes.html>
+  <b>LDAP Proxy Release Notes</b>
+</a>
+<p>
+
+<i>Last Update: August 2006<br>
+  Marc Amis - <a href="mailto:ldap.proxy@boeing.com">LDAP Proxy Team</a>
+</i>
+
+<p>
+<a href="http://sourceforge.net">
+    <img src="http://sourceforge.net/sflogo.php?group_id=126646&amp;type=3"
+    width="125" height="37" border="0" alt="SourceForge.net Logo">
+</a>
+</center>
+
+</body>
+</html>
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fcb.html openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fcb.html
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fcb.html	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fcb.html	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,54 @@
+<html>
+<head>
+<title>LDAP Proxy Release Notes</title>
+</head>
+<body bgcolor="aqua">
+
+<center>
+<h1>The LDAP Proxy Flowcharts</h1>
+<p>
+<h2>Click on red boxes for individual flow charts.</h2>
+<hr>
+<p>
+<img src="flow_map_3x3.jpeg" border=0 height=237 width=921 usemap=#flowmap>
+<map name=flowmap>
+  <area shape=rect coords="1,92,90,140"     href=ldap_proxy_flowcharts.html>
+  <area shape=rect coords="129,86,207,148"  href=ldap_proxy_flowcharts.html>
+  <area shape=rect coords="244,3,325,236"   href=chart_gc.html>
+  <area shape=rect coords="363,5,488,69"    href=chart_fca.html>
+  <area shape=rect coords="532,5,646,69"    href=chart_fcb.html>
+  <area shape=rect coords="688,6,802,69"    href=chart_fcc.html>
+  <area shape=rect coords="364,97,455,142"  href=chart_fo.html>
+  <area shape=rect coords="366,174,435,219" href=chart_fa.html>
+  <area shape=rect coords="857,98,916,140"  href=ldap_proxy_flowcharts.html>
+</map>
+
+<p>
+<hr>
+</center>
+<a href=/pub/ldap_proxy/ldap_proxy_release_notes.html>
+  <b>LDAP Proxy Release Notes</b>
+</a>
+<center>
+<p>
+<img src=find_certificate_B_3x3.jpeg border=0>
+<hr>
+<p>
+<a href=/pub/ldap_proxy/ldap_proxy_release_notes.html>
+  <b>LDAP Proxy Release Notes</b>
+</a>
+<p>
+
+<i>Last Update: August 2006<br>
+  Marc Amis - <a href="mailto:ldap.proxy@boeing.com">LDAP Proxy Team</a>
+</i>
+
+<p>
+<a href="http://sourceforge.net">
+    <img src="http://sourceforge.net/sflogo.php?group_id=126646&amp;type=3"
+    width="125" height="37" border="0" alt="SourceForge.net Logo">
+</a>
+</center>
+
+</body>
+</html>
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fcc.html openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fcc.html
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fcc.html	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fcc.html	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,54 @@
+<html>
+<head>
+<title>LDAP Proxy Release Notes</title>
+</head>
+<body bgcolor="aqua">
+
+<center>
+<h1>The LDAP Proxy Flowcharts</h1>
+<p>
+<h2>Click on red boxes for individual flow charts.</h2>
+<hr>
+<p>
+<img src="flow_map_3x3.jpeg" border=0 height=237 width=921 usemap=#flowmap>
+<map name=flowmap>
+  <area shape=rect coords="1,92,90,140"     href=ldap_proxy_flowcharts.html>
+  <area shape=rect coords="129,86,207,148"  href=ldap_proxy_flowcharts.html>
+  <area shape=rect coords="244,3,325,236"   href=chart_gc.html>
+  <area shape=rect coords="363,5,488,69"    href=chart_fca.html>
+  <area shape=rect coords="532,5,646,69"    href=chart_fcb.html>
+  <area shape=rect coords="688,6,802,69"    href=chart_fcc.html>
+  <area shape=rect coords="364,97,455,142"  href=chart_fo.html>
+  <area shape=rect coords="366,174,435,219" href=chart_fa.html>
+  <area shape=rect coords="857,98,916,140"  href=ldap_proxy_flowcharts.html>
+</map>
+
+<p>
+<hr>
+</center>
+<a href=/pub/ldap_proxy/ldap_proxy_release_notes.html>
+  <b>LDAP Proxy Release Notes</b>
+</a>
+<center>
+<p>
+<img src=find_certificate_C_2x2.jpeg border=0>
+<hr>
+<p>
+<a href=/pub/ldap_proxy/ldap_proxy_release_notes.html>
+  <b>LDAP Proxy Release Notes</b>
+</a>
+<p>
+
+<i>Last Update: August 2006<br>
+  Marc Amis - <a href="mailto:ldap.proxy@boeing.com">LDAP Proxy Team</a>
+</i>
+
+<p>
+<a href="http://sourceforge.net">
+    <img src="http://sourceforge.net/sflogo.php?group_id=126646&amp;type=3"
+    width="125" height="37" border="0" alt="SourceForge.net Logo">
+</a>
+</center>
+
+</body>
+</html>
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fo.html openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fo.html
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fo.html	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_fo.html	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,54 @@
+<html>
+<head>
+<title>LDAP Proxy Release Notes</title>
+</head>
+<body bgcolor="aqua">
+
+<center>
+<h1>The LDAP Proxy Flowcharts</h1>
+<p>
+<h2>Click on red boxes for individual flow charts.</h2>
+<hr>
+<p>
+<img src="flow_map_3x3.jpeg" border=0 height=237 width=921 usemap=#flowmap>
+<map name=flowmap>
+  <area shape=rect coords="1,92,90,140"     href=ldap_proxy_flowcharts.html>
+  <area shape=rect coords="129,86,207,148"  href=ldap_proxy_flowcharts.html>
+  <area shape=rect coords="244,3,325,236"   href=chart_gc.html>
+  <area shape=rect coords="363,5,488,69"    href=chart_fca.html>
+  <area shape=rect coords="532,5,646,69"    href=chart_fcb.html>
+  <area shape=rect coords="688,6,802,69"    href=chart_fcc.html>
+  <area shape=rect coords="364,97,455,142"  href=chart_fo.html>
+  <area shape=rect coords="366,174,435,219" href=chart_fa.html>
+  <area shape=rect coords="857,98,916,140"  href=ldap_proxy_flowcharts.html>
+</map>
+
+<p>
+<hr>
+</center>
+<a href=/pub/ldap_proxy/ldap_proxy_release_notes.html>
+  <b>LDAP Proxy Release Notes</b>
+</a>
+<center>
+<p>
+<img src=find_object_4x4.jpeg border=0>
+<hr>
+<p>
+<a href=/pub/ldap_proxy/ldap_proxy_release_notes.html>
+  <b>LDAP Proxy Release Notes</b>
+</a>
+<p>
+
+<i>Last Update: August 2006<br>
+  Marc Amis - <a href="mailto:ldap.proxy@boeing.com">LDAP Proxy Team</a>
+</i>
+
+<p>
+<a href="http://sourceforge.net">
+    <img src="http://sourceforge.net/sflogo.php?group_id=126646&amp;type=3"
+    width="125" height="37" border="0" alt="SourceForge.net Logo">
+</a>
+</center>
+
+</body>
+</html>
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_gc.html openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_gc.html
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_gc.html	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/chart_gc.html	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,54 @@
+<html>
+<head>
+<title>LDAP Proxy Release Notes</title>
+</head>
+<body bgcolor="aqua">
+
+<center>
+<h1>The LDAP Proxy Flowcharts</h1>
+<p>
+<h2>Click on red boxes for individual flow charts.</h2>
+<hr>
+<p>
+<img src="flow_map_3x3.jpeg" border=0 height=237 width=921 usemap=#flowmap>
+<map name=flowmap>
+  <area shape=rect coords="1,92,90,140"     href=ldap_proxy_flowcharts.html>
+  <area shape=rect coords="129,86,207,148"  href=ldap_proxy_flowcharts.html>
+  <area shape=rect coords="244,3,325,236"   href=chart_gc.html>
+  <area shape=rect coords="363,5,488,69"    href=chart_fca.html>
+  <area shape=rect coords="532,5,646,69"    href=chart_fcb.html>
+  <area shape=rect coords="688,6,802,69"    href=chart_fcc.html>
+  <area shape=rect coords="364,97,455,142"  href=chart_fo.html>
+  <area shape=rect coords="366,174,435,219" href=chart_fa.html>
+  <area shape=rect coords="857,98,916,140"  href=ldap_proxy_flowcharts.html>
+</map>
+
+<p>
+<hr>
+</center>
+<a href=/pub/ldap_proxy/ldap_proxy_release_notes.html>
+  <b>LDAP Proxy Release Notes</b>
+</a>
+<center>
+<p>
+<img src=getcert_3x3.jpeg border=0>
+<hr>
+<p>
+<a href=/pub/ldap_proxy/ldap_proxy_release_notes.html>
+  <b>LDAP Proxy Release Notes</b>
+</a>
+<p>
+
+<i>Last Update: August 2006<br>
+  Marc Amis - <a href="mailto:ldap.proxy@boeing.com">LDAP Proxy Team</a>
+</i>
+
+<p>
+<a href="http://sourceforge.net">
+    <img src="http://sourceforge.net/sflogo.php?group_id=126646&amp;type=3"
+    width="125" height="37" border="0" alt="SourceForge.net Logo">
+</a>
+</center>
+
+</body>
+</html>
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/ldap_proxy_flowcharts.html openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/ldap_proxy_flowcharts.html
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/ldap_proxy_flowcharts.html	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/flowcharts/ldap_proxy_flowcharts.html	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,42 @@
+<html>
+<head>
+<title>LDAP Proxy Release Notes</title>
+</head>
+<body bgcolor="aqua">
+
+<center>
+<h1>The LDAP Proxy Flowcharts</h1>
+<p>
+<h2>Click on red boxes for individual flow charts.</h2>
+<hr>
+<p>
+<img src="flow_map_3x3.jpeg" border=0 height=237 width=921 usemap=#flowmap>
+<map name=flowmap>
+  <area shape=rect coords="244,3,325,236"   href=chart_gc.html>
+  <area shape=rect coords="363,5,488,69"    href=chart_fca.html>
+  <area shape=rect coords="532,5,646,69"    href=chart_fcb.html>
+  <area shape=rect coords="688,6,802,69"    href=chart_fcc.html>
+  <area shape=rect coords="364,97,455,142"  href=chart_fo.html>
+  <area shape=rect coords="366,174,435,219" href=chart_fa.html>
+</map>
+
+<p>
+<hr>
+<a href=/pub/ldap_proxy/ldap_proxy_release_notes.html>
+  <b>LDAP Proxy Release Notes</b>
+</a>
+<p>
+
+<i>Last Update: August 2006<br>
+  Marc Amis - <a href="mailto:ldap.proxy@boeing.com">LDAP Proxy Team</a>
+</i>
+
+<p>
+<a href="http://sourceforge.net">
+    <img src="http://sourceforge.net/sflogo.php?group_id=126646&amp;type=3"
+    width="125" height="37" border="0" alt="SourceForge.net Logo">
+</a>
+</center>
+
+</body>
+</html>
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/ldap_proxy_build.txt openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/ldap_proxy_build.txt
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/ldap_proxy_build.txt	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/ldap_proxy_build.txt	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,151 @@
+
+
+    Building LDAP Proxy version 4.0 from Source Code            September 2004
+    ------------------------------------------------
+
+    [NOTE: Replace "4.0" in the following instructions with the
+           actual version of the LDAP Proxy you are building.]
+
+
+    LDAP Proxy version 4.0 will compile on either Linux or Sun/Solaris systems.
+
+    Prerequisites:
+
+        OpenLDAP 2.1.30
+
+                Available from http://www.openldap.org/.  
+                The LDAP Proxy is not compatible with
+                OpenLDAP 2.2.x or OpenLDAP 2.3.x.
+
+        getcert 4.0
+
+                Available from SourceForge.net or Boeing.
+                Contents:
+                    ldap_proxy_4.0_source/configure.in
+                    ldap_proxy_4.0_source/servers/slapd/back-getcert/
+                    ldap_proxy_4.0_source/servers/slapd/backend.c
+                    ldap_proxy_4.0_source/servers/slapd/result.c
+
+        autoconf 2.13.1
+
+                Used to build the OpenLDAP configuration file.
+                This is a very old version of autoconf required by OpenLDAP.
+                Note that version 2.13 won't work with OpenLDAP 2.1.30.
+                Available from http://www.gnu.org/software/autoconf/
+
+        automake 1.4a
+        libtool 1.4.2
+
+                Used by autoconf.
+                Available from the GNU org: ftp://ftp.gnu.org/pub/gnu/
+
+
+
+    1) Install the autoconf, automake, and libtool packages according to
+        the "INSTALL" file contained in each package.
+
+
+    2) Unpack the OpenLDAP 2.1.30 source code and rename it to
+        "ldap_proxy_4.0_source".
+
+
+                gunzip openldap-2.1.30.tgz
+                tar xf openldap-2.1.30.tar
+                mv openldap-2.1.30 ldap_proxy_4.0_source
+                rm openldap-2.1.30.tar
+
+
+    3) Uncompress and untar the getcert software into the top level of the
+        OpenLDAP source code tree. 
+
+
+                cd ldap_proxy_4.0_source
+                gunzip getcert_4.0.tar.gz
+                tar xf getcert_4.0.tar
+                rm getcert_4.0.tar
+
+
+    4) Set your CC, CPPFLAGS, and CFLAGS environment variables.
+        For example, using the Korn shell:
+
+                export CC=gcc
+                export CPPFLAGS="-DFD_SETSIZE=8192 -DNDEBUG"
+                
+        For Solaris: export CFLAGS="-O -g -D_REENTRANT"
+        For Linux:   export CFLAGS="-O -g"
+
+        If autoconf version 2.13.1 is not the first autoconf in your PATH,
+        set your PATH environment variable (example using the Korn shell):
+
+                export PATH=/usr/local/autoconf_2.13.1/bin:$PATH
+
+
+    5) Build the LDAP Proxy configuration file:
+
+
+                cd ldap_proxy_4.0_source
+                autoconf
+                autoheader
+
+        You can ignore the warning issued by autoconf about "AC_TRY_RUN".
+        You must re-run autoconf and autoheader whenever you make changes
+        to the "configure.in" file.
+
+
+    6) Build the new configuration.  Set the "--prefix" option to the full 
+        path of the directory you will be installing the LDAP Proxy into.
+
+
+        cd ldap_proxy_4.0_source
+        ./configure --prefix=/usr/local/apps/ldap_proxy_4.0 \
+            --with-threads --without-tls --without-cyrus-sasl \
+            --enable-debug --enable-syslog --enable-slapd --enable-getcert \
+            --disable-ipv6 --disable-rlookups --disable-slurpd --disable-bdb
+
+
+    7) Build and install the LDAP Proxy.  Be sure you have read/write access
+        to the install directory specified by the "--prefix" option in the 
+        configure command above.
+
+
+        cd ldap_proxy_4.0_source
+        make depend
+        make
+        make install
+
+
+    8) Copy the LDAP Proxy support files into the newly installed LDAP proxy:
+
+
+        cd ldap_proxy_4.0_source/servers/slapd/back-getcert/PROTO_FILES/
+        tar cf - * | (cd /usr/local/apps/ldap_proxy_4.0; tar xlpf -)
+
+
+    9) Set ownership and permission attributes in the installed LDAP Proxy:
+
+        Log in as "root".
+        cd /usr/local/apps/ldap_proxy_4.0/bin/
+        # Edit the "PROXYHOME" line in the "set_permissions.sh"
+        # script to point to the LDAP Proxy install directory
+        # (Example: "PROXYHOME=/usr/local/apps/ldap_proxy_4.0").
+        ./set_permissions.sh
+
+
+    At this point the installed LDAP Proxy should look like the pre-compiled
+    version Boeing distributes.  Continue with the configuration steps in
+    section 6 (Proxy Administration) of the main LDAP Proxy web page
+    "ldap_proxy_release_notes.html" now located in
+    "/usr/local/apps/ldap_proxy_4.0/docs/".
+
+
+                Marc Amis      September 2004
+                Boeing Information Technology
+                Bellevue, Washington      USA
+
+    -----------------------------------------------------------------------
+    LDAP Proxy Team
+
+    Wen Fang     -  Architecture & Design         -  wen.fang@boeing.com
+    Marc Amis    -  Development & Implementation  -  marc.amis@boeing.com
+    Darryl Lang  -  Proxy Administration          -  darryl.p.lang@boeing.com
+    -----------------------------------------------------------------------
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/ldap_proxy_release_notes.html openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/ldap_proxy_release_notes.html
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/doc/ldap_proxy_release_notes.html	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/doc/ldap_proxy_release_notes.html	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,1879 @@
+<html>
+<head>
+<title>LDAP Proxy Release Notes</title>
+<style>
+<!--
+BODY {margin-left: 5%; margin-right: 10%}
+ -->
+</style>
+</head>
+<body bgcolor="cyan">
+
+<center>
+<h1>LDAP Proxy Release Notes</h1>
+<br>
+</center>
+
+<table align="center" cols="1" width="60%">
+  <tbody><tr>
+    <td>
+<ol>
+  <li><a href="#Section_1">
+	<font size="+1"><b>Overview</b></font></a>
+  <li><a href="#Section_3">
+	<font size="+1"><b>Proxy Operation</b></font></a>
+  <li><a href="#Section_4">
+	<font size="+1"><b>Software</b></font></a>
+  <li><a href="#Section_5">
+	<font size="+1"><b>LDAP Server Lists</b></font></a>
+    <ul>
+      <li><a href="#subsection_5a">
+		<font size="+1">Certificate Server List</font></a>
+      <li><a href="#subsection_5b">
+		<font size="+1">LDAP Server List</font></a>
+    </ul>
+  <li><a href="#Section_6">
+	<font size="+1"><b>Configuration File</b></font></a>
+  <li><a href="#Section_7">
+	<font size="+1"><b>Proxy Administration</b></font></a>
+    <ul>
+      <li><a href="#subsection_7a">
+		<font size="+1">Installation</font></a>
+      <li><a href="#subsection_7b">
+		<font size="+1">Configuration</font></a>
+      <li><a href="#subsection_7k">
+		<font size="+1">Migrating from Proxy version 3 to version 4
+		</font></a>
+      <li><a href="#subsection_7c">
+		<font size="+1">Platform Issues</font></a>
+      <li><a href="#subsection_7d">
+		<font size="+1">Starting the Proxy</font></a>
+      <li><a href="#subsection_7e">
+		<font size="+1">Stopping the Proxy</font></a>
+      <li><a href="#subsection_7f">
+		<font size="+1">Logging</font></a>
+      <li><a href="#subsection_7g">
+		<font size="+1">Error Messages and Return Codes</font></a>
+      <li><a href="#subsection_7h">
+		<font size="+1">Testing the Proxy</font></a>
+      <li><a href="#subsection_7i">
+		<font size="+1">Running Multiple Instances of LDAP Proxy</font>
+	  </a>
+      <li><a href="#subsection_7j">
+		<font size="+1">Reporting Problems</font></a>
+    </ul>
+  <li><a href="#Section_8">
+	<font size="+1"><b>Web Interface</b></font></a>
+  <li><a href="#Section_9">
+	<font size="+1"><b>Development</b></font></a>
+  <li><a href="#Section_11">
+	<font size="+1"><b>Changelog</b></font></a>
+  <li><a href="#Section_13">
+	<font size="+1"><b>LDAP Proxy Team</b></font></a>
+</ol>
+    </td>
+  </tr>
+</tbody></table>
+
+<hr>
+
+<ul>
+  <a name="Section_1"></a>
+  <li><font size="+1"><b>Overview</b></font><br>
+<p>
+The LDAP Proxy is part of an email encryption architecture designed to
+facilitate the exchange of encrypted email through the use of X.509
+personal certificates.  The personal certificates contain public email
+encryption keys needed by the email sender to encrypt email that only the
+recipient can decrypt.
+The LDAP Proxy is given an email address and searches remote LDAP servers
+for an X.509 public certificate belonging to the person who matches the
+email address.  This certificate is returned to the requester and the
+public encryption key contained in the certificate is used by the
+requester's email program to encrypt email to be sent to the owner
+of the certificate.
+<p>
+The LDAP Proxy can also be used to find and return certificate revocation
+lists (CRL), CA & signing certificates, and other specific data stored on
+LDAP database servers.
+<p>
+The LDAP Proxy is part of the Public Key Infrastructure (PKI) based email
+encryption architecture presented to the 
+<a href=http://www.opengroup.org/>Open Group</a> Messaging Forum in 2002 as 
+<a href=http://www.opengroup.org/comm/case-studies/boeing_challenge.pdf>
+The Boeing Company Secure Messaging Challange</a>.
+<p>
+  <a name="Section_2"></a>
+Under the PKI scheme, each user has two encryption keys; a public key
+that allows encryption and a private key which allows decryption.  These
+keys are contained in the user's public and private X.509 user certificates.
+Anyone who has a copy of a user's public certificate can encrypt email that
+only the certificate's owner can decrypt using their private certificate.  
+Locating and exchanging the public encryption keys has been considered a
+bottleneck to the PKI email encryption approach.  The LDAP Proxy is
+designed to facilitate the location and exchange of these public
+certificates.
+<p>
+  <a name="Section_3"></a>
+  <li><font size="+1"><b>Proxy Operation</b></font><br>
+<p>
+The LDAP Proxy is not an LDAP server, though it tends to look like one to
+the LDAP client utilities that send it search requests.  It is designed
+to find and return X.509 type certificates and Certificate Revocation Lists
+(CRL) for use in email encryption.  Information about multiple LDAP servers
+is defined in the LDAP Proxy so that users only have to query the LDAP Proxy
+to find public encryption certificates for people from a variety of companies.
+Consequently the users do not need to query each company's LDAP server to find
+the encryption certificate they need.
+<p>
+The LDAP Proxy will process only three types of LDAP search requests:
+<ul>
+  <li>Public certificate searches using an email address as the search key.
+      <br>
+      (For finding an encryption certificate for a specific user.)
+  <li>LDAP queries asking for a specific piece of data using a BaseDN and
+      an attribute name as the search keys.
+      <br>
+      (For fetching CA/signing certificates and CRL lists.)
+  <li>Queries asking for all data from a specific LDAP database entry using
+      the BaseDN of that entry as a search key.
+      <br>
+      (For fetching multiple CA/signing certificates and CRL lists contained
+      in a single LDAP database entry.)
+</ul>
+<p>
+All other types of LDAP queries are not processed.  This allows LDAP Proxies
+on a company firewall to act as a filter when accessing LDAP database servers 
+within the firewall.  The Proxy finds and returns specific data but denies
+access to the rest of the data in the LDAP database.
+<p>
+By default, the LDAP Proxy listens on the standard LDAP port (389) for LDAP
+queries.  These queries can be made from any type of LDAP client but will
+typically come from an addressbook client or email program.
+An example of the LDAP Proxy in operation is the Boeing Company's LDAP
+Proxy Service located at 
+<font color=blue>dir.boeing.com port 389</font>, and its Web Interface
+located at URL 
+<a href=http://www.boeing.com/companyoffices/doingbiz/ldap_proxy/get_cert.html>
+http://www.boeing.com/companyoffices/doingbiz/ldap_proxy/get_cert.html</a>.
+
+  <ul>
+    <li><b>Certificate Retrieval</b>
+	<p>
+LDAP Requests for public encryption certificates must have a search filter
+containing a valid email address.  The email address is used by the LDAP
+Proxy to search a locally maintained list of LDAP servers (See "LDAP 
+Server Lists" below).  These servers provide employee information for the 
+companies and organizations that own the server.  If the LDAP Proxy finds an 
+LDAP server in the list that services the requested email address, an LDAP 
+query is made to that server using the email address as a search key.  
+If employee information is available for that email address, the LDAP Proxy 
+collects the common name of the employee and their public certificate (if 
+available) and returns these items to the original requester.  Once the 
+requester's email program has the public certificate, it can send encrypted 
+email to the owner of that certificate.
+<p>
+<pre>
+			  The Boeing LDAP Proxy
+			  ---------------------
+
+    -----------                                              -----------
+    | Boeing  |                                              | Boeing  |
+    |  ldap   |                                              |  ldap   |
+    | clients |                                              | servers |
+    -----------                                ----------    -----------
+         ^                                     | Boeing |         ^
+         |                                     | Admin  |         |
+         |     ^                               ----------     ^   |
+         |     |                                    |         |   |
+   email | user name                                |       email | user name
+   addr  | email addr                               |       addr  | email addr
+     |   | public cert                              |             | public cert
+     V   |                                          |             |   |
+         |                                          |             |   V
+         |   ---------------------------------------|----------   |
+         |   | LDAP_PROXY                           V         |   |
+         |   |                              ----------------  |   |
+         |   |                              |  Cert & LDAP |  |   |
+         |   |                              | server lists |  |   |
+         |   |                              ----------------  |   |
+         |   |                                      |         |   |
+         |   |                                      V         |   |
+         V   |  --------------   email addr   --------------  |   V
+         \   |  |            |---------------&gt;|            |  |   /
+          &lt;----&gt;|  OpenLDAP  |                |  getcert   |&lt;----&gt; 
+         /   |  |            |&lt;---------------|            |  |   \
+         ^   |  --------------   user name    --------------  |   ^
+         |   |                   email addr                   |   |
+         |   |                   public cert                  |   |
+         |   |                                                |   |
+         |   --------------------------------------------------   |
+         |                                                        |
+         |                                                        |
+ ========|===================Boeing firewall======================|============
+         |                                                        |
+         |                                                        |   ^
+     ^   |                                                        |   |
+     |   | user name                                        email | user name
+   email | email addr                                       addr  | email addr
+   addr  | public cert                                        |   | public cert
+         |      |                                             V   |
+         |      V                                                 |
+         |                                                        |
+         V                                                        V
+   --------------                                           --------------
+   | non-Boeing |                                           | non-Boeing |
+   |   ldap     |                                           |   ldap     |
+   |  clients   |                                           |  servers   |
+   --------------                                           --------------
+
+</pre>
+<p>
+     <li><b>CRL and CA Certificate Retrieval</b>
+	<p>
+Requests for CRLs and CA/signing certificates must contain two pieces of
+information: the data attribute name (for example, "CertificateRevocationList"
+or "cACertificate"), and a BaseDN (Distinquished Name) which defines the
+location of the data on the LDAP server.  An example	of a BaseDN is
+<font color="blue">ou=netscape,ou=certservers,o=Boeing,c=US</font>.
+The BaseDN and the attribute name are compared with BaseDNs and attribute
+names listed in the locally maintained LDAP server list (See "LDAP Server
+Lists" below).  If a match is found, an LDAP search request is send by the
+LDAP Proxy to the matched LDAP server specifying the BaseDN as the location
+of the attribute on that server and the attribute name as the name of the 
+data we are looking for.  The Proxy will fetch one or more CRLs or certificates
+from the LDAP server and return them to the requesting client.
+  </ul>
+
+<p>
+  <a name="Section_4"></a>
+  <li><font size="+1"><b>LDAP Proxy Software</b></font><br>
+<p>
+The current version of ldap_proxy is 4.2.<br>
+and is made up of:<br>
+<p>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenLDAP 2.1.30
+&nbsp;&nbsp;&nbsp;
+( <a href="http://www.openldap.org/">http://www.openldap.org/</a> )<br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getcert 4.2<br>
+<p>
+The LDAP Proxy software is made up of two components.  The OpenLDAP "slapd" 
+daemon is used as the LDAP front-end process and a locally written facility 
+called "getcert" is used as a back-end process to slapd.  The front-end
+process listens on LDAP port 389 and establishes LDAP sessions with remote
+LDAP clients.  When the front-end receives an LDAP query from the remote
+client, the LDAP search parameters are handed to the back-end process getcert.  
+Getcert then matches the search criteria with entries in the LDAP server
+lists and queries the appropriate remote LDAP servers for the requested
+data.  Search results are handed back to the slapd front-end process which
+sends the data to the remote LDAP client and terminates the LDAP session.
+<p>
+The ldap_proxy has been tested on Sun Solaris 8, 9 &amp; 10, RedHat Linux 8
+&amp; 9,
+Fedora Core 3, 4 &amp; 5, and SuSE Linux 9 servers.  In theory, it can be
+compiled and run on any UNIX system that is capable of running OpenLDAP.
+Instructions for
+<a href="ldap_proxy_build.txt">building the LDAP Proxy from source code</a> 
+are included with the LDAP Proxy source code distribution which is available
+for download from 
+<a href=http://ldap-proxy.sourceforge.net/>SourceForge.net</a>.
+<p>
+The LDAP Proxy uses a three number version notation to identify the release 
+version.  The major version is the left hand number and is incremented only 
+after the source code has undergone a major revision or major rewrite.
+The middle number is the minor version number and is incremented when new
+functionality or features are added to the code base.  The right hand number
+is the patch level and is incremented whenever changes are made to the code
+base but no new functionality is added.  If no patches or other changes are
+made to the code since the minor version was released, no patch level number
+is listed (i.e., version 2.5 rather than 2.5.0).
+<p>
+
+  <a name="Section_5"></a>
+  <li><font size="+1"><b>LDAP Server Lists</b></font>
+<p>
+The LDAP Proxy uses two locally maintained lists of LDAP servers to define
+the access information to the servers and the type of data available from
+that server.  At least one of these lists must be available to the Proxy.
+The full path names to these files are defined in the slapd configuration
+file (see "Configuration File" below).
+<p>
+  <ul>
+    <a name="subsection_5a"></a>
+    <li><b>Certificate Server List</b>
+	<p>
+	The certificate server list is called "certificate_server_list.txt"
+	and lists information about each LDAP server that can be accessed to
+	fetch individual pubic encryption certificates. It is an ascii text
+	file which is read into memory when the Proxy is started.  Each
+	server entry in the list is made up of either seven or nine lines
+	with one server option per line.  Each server entry is separated by
+	a blank line.
+	<br>
+	The server options are as follows:
+	<p>
+	<ol>
+  	  <li> Email domain name (or "*" to match any email domain)
+	  <li> LDAP server fully qualified domain name or IP address
+	  <li> LDAP port number
+	  <li> Base DN for certificate search
+	  <li> Name of email address attribute (typically "mail")
+	  <li> Name of person name attribute (typically "cn")
+	  <li> Name of certificate attribute (typically "userCertificate")
+	  <li> Bind DN (if required)
+	  <li> Bind password (if required)
+	</ol>
+	<p>
+	The first seven options are always required and define an LDAP server
+	that allows anonymous access.  The last two options are required if
+	the LDAP server requires access authentication.
+	<p>
+	Example server list entry:
+	<p>
+	<table cellspacing=0 cellpadding=0>
+	  <tr><td width=10%>&nbsp;</td><td>boeing.com</td></tr>
+	  <tr><td>&nbsp;</td><td>directory.boeing.com</td></tr>
+	  <tr><td>&nbsp;</td><td>389</td></tr>
+	  <tr><td>&nbsp;</td><td>ou=People,o=Boeing,c=US</td></tr>
+	  <tr><td>&nbsp;</td><td>boeingStableAddress</td></tr>
+	  <tr><td>&nbsp;</td><td>boeingDisplayName</td></tr>
+	  <tr><td>&nbsp;</td><td>userCertificate</td></tr>
+	  <tr><td>&nbsp;</td><td>boeingAppCn=ldap_app,ou=apps,o=Boeing,c=US</td></tr>
+	  <tr><td>&nbsp;</td><td>bind_password</td></tr>
+	</table>
+
+	<p>
+	<b>Email Domain Parsing</b><br>
+	The ldap_proxy searches the list from the top down using the email 
+	domain name of the input email filter as the search key.  The email 
+	domain will be scanned from left to right and each sub-domain of the 
+	email address will be searched until a match is found or only one
+	email domain (containing a single &quot;.&quot) remains.
+	For example, if the email filter contains the email address 
+	"Joe.User@dept_32.richmond.virginia.planecorp.com" 
+	the Proxy would make up to four comparisons of each entry in the 
+	server list searching for a match with one of the following email 
+	domains:
+	<p>
+	<ol>
+	  <li>dept_32.richmond.virginia.planecorp.com
+	  <li>richmond.virginia.planecorp.com
+	  <li>virginia.planecorp.com
+	  <li>planecorp.com
+	</ol>
+	<p>
+	If no match is found with the current server entry, the Proxy moves 
+	on to the next server entry in the list and begins the four
+	comparisons again.  In this way we would find departmental LDAP 
+	servers in the list before we found company-wide LDAP servers.  
+	<p>
+	<b>Server Fail-Over and Redundancy</b><br>
+	LDAP servers that serve the same email domain can be defined in the 
+	server list.  If the LDAP Proxy does not find a public certificate 
+	for the specified email address on one server, it will continue 
+	searching the server list for the next server that serves the desired 
+	email domain.  For example, If a company has both primary and backup 
+	LDAP servers, both can be listed in the server list so that the backup 
+	server will be queried by the LDAP Proxy if the primary server goes 
+	off line.  Another example would be the splitting of user data among 
+	several servers.  The LDAP Proxy would query each in turn until a 
+	valid certificate was found.  The local admin controls the order the
+	Proxy queries the servers by the order they are listed in the server 
+	list.
+	<p>
+	<b>Server Wildcarding</b><br>
+	If the email domain field in the server list entry is a single "*"
+	character, the server list entry will match any email address.
+	The server defined by this wildcarded server list entry will always
+	be searched for the email address specified in the LDAP query, unless
+	a usable certificate was found on a server defined by a preceeding
+	server list entry.  This is used to define one or more "catch-all"
+	LDAP servers as the last entries in the server list.
+	<p>
+
+    <a name="subsection_5b"></a>
+    <li><b>LDAP Server List</b>
+	<p>
+	The LDAP server list is called "ldap_server_list.txt" and is an
+	ascii text file which is read into memory when the Proxy is started.
+	Each server entry in the list is made up of either five or seven
+	lines with one server option per line.  Each server entry is
+	separated by a blank line.
+	<br>
+	The server options are as follows:
+	<p>
+	<ol>
+	  <li> BaseDN 
+	  <li> LDAP server fully qualified domain name or IP address
+	  <li> LDAP port number
+	  <li> attribute name or "all"
+	  <li> none (option not yet implemented)
+	  <li> Bind DN (if required)
+	  <li> Bind password (if required)
+	</ol>
+	<p>
+	The first five options are always required and define an LDAP server
+	that allows anonymous access.  The last two options are required if
+	the LDAP server requires access authentication.
+	<p>
+	Example server list entry:
+	<p>
+	<table cellspacing=0 cellpadding=0>
+	  <tr><td width=10%>&nbsp;</td>
+	      <td>CN=The Boeing Company Class 2 Certificate Authority,O=Boeing,C=US</td></tr>
+	  <tr><td>&nbsp;</td><td>pkiserver.boeing.com</td></tr>
+	  <tr><td>&nbsp;</td><td>389</td></tr>
+	  <tr><td>&nbsp;</td><td>certificateRevocationList</td></tr>
+	  <tr><td>&nbsp;</td><td>none</td></tr>
+	  <tr><td>&nbsp;</td>
+	      <td>boeingCn=ldapaccess,ou=applications,o=Boeing,c=US</td></tr>
+	  <tr><td>&nbsp;</td><td>bind_password</td></tr>
+	</table>
+	<p>
+	For each incoming LDAP search request, the LDAP Proxy will compare
+	the request's attributes and search DN with the entries in the LDAP
+	Server List (if it exists).  If a match is found with both the DN
+	and one of the attribute names specified in the search request, the
+	Proxy will request the attribute value from the matching server.  
+	If no attribute value is returned from that server, the Proxy will
+	continuing searching the LDAP server list and querying matching
+	servers until an attribute value is found or the end of the server
+	list is reached.
+	<p>
+	If the attribute name in the fourth line of the server list entry
+	is set to the keyword "all", all data from an LDAP entry can be
+	returned.  This keyword matches all attribute names for the entry
+	pointed to by the BaseDN.
+	<p>
+	BaseDN and attribute name comparisons are done character by character
+	and so the entries specified in the LDAP request and listed in the
+	server list must be identical.  However, the search is not
+	case-sensitive so upper and lower case differences will not affect
+	the comparisons.
+    </ul>
+
+<b>Making Changes to the Server Lists</b><br>
+When changes are made to either server list it must be reloaded into 
+the Proxy by stopping and restarting the Proxy.
+<p>
+
+<a name="Section_6"></a>
+<li><font size="+1"><b>Configuration File</b></font><br>
+<p>
+In addition to the two LDAP server lists described above, the Proxy uses a 
+configuration file called slapd.conf to initialize itself on startup.
+The Proxy installation will include a slapd.conf file with default values
+specified.  Descriptions of each option are included in the slapd.conf file.
+The configuration options are as follows:
+<p>
+<pre>
+    ucdata-path     /usr/local/apps/ldap_proxy_4.1/share/openldap/ucdata
+
+	Path to unicode support data used by slapd front end process.
+
+    include	    /usr/local/apps/ldap_proxy_4.1/etc/openldap/schema/core.schema
+    include	    /usr/local/apps/ldap_proxy_4.1/etc/openldap/schema/cosine.schema
+    include	    /usr/local/apps/ldap_proxy_4.1/etc/openldap/schema/inetorgperson.schema
+
+	These include files define the default LDAP database schema.
+	Only attributes listed in the schema files included with these
+	include statements can be returned by the LDAP Proxy.
+
+    pidfile         /usr/local/apps/ldap_proxy_4.1/var/slapd.pid
+
+	This is where the Proxy will store the Process ID of the 
+	front-end process when ldap_proxy is started.
+
+    argsfile        /usr/local/apps/ldap_proxy_4.1/var/slapd.args
+
+	This is where the Proxy will store the command line entry 
+	that was used to start slapd.
+
+    loglevel	    1024
+
+	Specifies the default type of debugging information from
+	the front-end "slapd" process.  This option has no effect
+	on logging done by the "getcert" back-end process which is
+	controlled by the "debugging" option (See "Logging" below).
+
+    allow bind_v2
+
+	Allow access by LDAP clients that speak only LDAP version 2.
+
+    idletimeout     600
+
+	Specify the number of seconds to wait before forcibly closing
+	an idle client connection. An idletimeout of 0 disables this
+	feature.
+
+    
+    database	    getcert
+
+	Name of the back-end process.  All options listed after this
+	database option refer to the getcert process.
+
+    readonly	    off
+
+	Specifies read-only access to ldap_proxy back-end process.
+	It is set to "off" so that ldap_proxy can be commanded to
+	re-read the serverlist file while the Proxy is running.
+	[The ability to re-read the serverlist while the Proxy is 
+	 running is currently disabled.]
+
+    lastmod         off
+
+	Set to "off" so that OpenLDAP does not attempt to maintain
+	database maintenance fields (there is no database in the Proxy).
+
+    access to * by anonymous read stop
+
+	This defines access controls for the LDAP Proxy.
+	In this case, anyone can query the Proxy.
+	
+    suffix          ""
+
+	Specifies the suffix of the database DN that can be passed to the 
+	back-end process.  The null string allows the servicing of requests 
+	using any base DN (or no base DN).
+
+    ########################################################
+    # The following options have default values which will #
+    # be used if the option is not defined in slapd.conf.  #
+    ########################################################
+
+    debugging 0
+
+	The "debugging" option sets the debugging message level of the backend
+	getcert process.  When greater than zero, debugging messages from the
+	backend process are logged via syslog to the LDAP Proxy log.
+	To select debugging messages from several levels, you can add the
+	levels.  For example, to get high-level, low-level, and memory
+	management messages logged together, specify "7" (level 1 + level 2 +
+	level 4).  Debugging levels greater than "1" are not likely to be
+	useful except during software development.
+
+	Debugging levels:
+	0 = No debugging messages are logged.
+	1 = General high-level debugging messages.
+	2 = Additional low-level debugging messages.
+	4 = Dynamic memory management messages.
+	8 = Messages from data parsing routines.
+	    [WARNING: Level 8 debugging will significantly
+                     degrade proxy performance.]
+	[Default: 0]
+
+    certificate_serverlist  /usr/local/apps/ldap_proxy_4.1/libexec/certificate_server_list.txt
+
+	"certificate_serverlist" is the full path name of the 
+	certificate_server_list file.  This file lists all the LDAP
+	servers that we can query for public X.509 certificates.
+	[Default: NULL]
+
+    ldap_serverlist  /usr/local/apps/ldap_proxy_4.1/libexec/ldap_server_list.txt
+
+	"ldap_serverlist" is the full path name of the ldap_server_list file.
+	If this file exists and is not empty, the LDAP Proxy will be able
+	to fetch CRL lists and CA/signing certificates.
+	[Default: NULL]
+
+    certificate_check 2
+
+	"certificate_check" determines how much checking the LDAP Proxy will do 
+	on the X.509 public encryption certificates it finds on the remote LDAP
+	servers.
+	Valid options are:
+	0 = No certificate checking.  Certificates are not examined and
+	    are sent the the requesting client just as they are found.
+	1 = Each certificate is decoded to confirm that it is a readable
+	    X.509 certificate.
+	2 = Each certificate is decoded and must meet the following
+	    criteria before being sent to the requesting client:
+	        a) The certificate is rejected if it is not readable and 
+	           identifiable as an X.509 certificate.
+	        b) The certificate validity dates are checked and the
+		   certificate is rejected if found to be expired or premature.
+	        c) The email address supplied by the client is compared with
+	           any email addresses defined in the certificate.  If email 
+		   addresses are defined in the certificate but none match the 
+		   client specified email address, the certificate is rejected.
+	[Default: 2]
+
+    search_timeout 30
+
+	"search_timeout" sets the maximum number of seconds that the Proxy
+	will wait for a response to its LDAP search request from a remote
+	LDAP server or LDAP Proxy.  A value of "0" seconds means no timeout
+	limit (i.e., wait forever).
+	[Default: 30 seconds].
+
+    certificatetype 0
+
+	"certificatetype" limits the Proxy to returning only one version of
+	X.509 certificate.  This option is ignored if the "certificate_check"
+	option is set to skip certificate decoding.
+	      0 = Return any version of certificate
+	      1 = Return only version 1 certificates
+	      2 = Return only version 2 certificates
+	      3 = Return only version 3 certificates
+	[Default: 0]
+
+    limit_return_codes   yes
+
+	"limit_return_codes" controls the type of return codes the LDAP Proxy
+	can return to the LDAP client.  The LDAP Proxy communicates with LDAP
+	clients by means of LDAP Return Codes.  By default, the Proxy will
+	return either LDAP_SUCCESS (0) or LDAP_OPERATIONS_ERROR (1) on
+	completion of an LDAP request.  If limit_return_codes is set to "no",
+	the Proxy will return codes selected from an expanded set of LDAP
+	Return Codes (see the list of possible return codes in the LDAP Proxy
+	documentation [ldap_proxy_release_notes.html]).  The use of expanded
+	return codes allow more descriptive status messages during development
+	and debugging.  However, some client programs have problems 
+	interpreting return codes they do not understand or expect.
+	[Default: no]
+
+    search_all_servers  no
+
+	"search_all_servers" determines whether the LDAP proxy will search
+	all LDAP servers listed in the certificate_server_lists.txt file for
+	encryption certificates that can be used with the email address
+	specified in the LDAP search request.  The default behavior of the
+	Proxy is to return only the certificates found at the first LDAP server
+	that contains usable certificates for the specified email address.
+	Setting "search_all_servers" to "yes" tells the LDAP proxy to keep
+	searching for more certificates even if it has already found some
+	usable certificates.  All certificates found are returned.
+	[Default: no]
+
+    cert_issuer_accept
+    cert_issuer_reject
+
+	The "cert_issuer_accept" and "cert_issuer_reject" options allow you to
+	select which Issuing Certificate Authorities you are willing, or
+	unwilling, to deliver certificates for.  The string values defined by
+	these options are searched for within the "Issuer" section of the user
+	certificates the Proxy retrieves from remote LDAP certificate servers.
+	If any of the values defined here are found in the Issuer description,
+	the certificate is either passed along to the requestor, or not, based
+	on whether the which of the "cert_issuer_" options you are using.  You
+	can use as many of these options as you wish, each on a separate line.
+	But NOTE: You can only specify all "cert_issuer_accept" options or all
+	"cert_issuer_reject" options.  You *CANNOT* mix the two types of 
+	options together.  The string values are searched in a case-insensitive
+	manner, but otherwise must match exactly part or all of the Issuing 
+	Certificate Authority description.  Each string value should be 
+	surrounded by quotes.  If you are defining "cert_issuer_accept" values,
+	the Proxy will only deliver certificates that contain at least one of 
+	the cert_issuer_accept values in its Issuer section.  If you are 
+	defining "cert_issuer_reject" values, the Proxy not deliver any 
+	certificates that contain any of the values defined here.  These 
+	options are ignored if "the certificate_check" option is set to "0" as 
+	this disables certificate decoding.
+
+	Examples:
+	
+	cert_issuer_accept "C=US, ST=Washington"
+	  - or -
+	cert_issuer_reject "O=Operation Testing"
+	cert_issuer_reject "self signed"
+
+	[Default: NULL]
+
+    normalize_common_name  no
+
+	The CN (CommonName) value returned with the certificates may be in 
+	the form "Last, First".  Since this value will become part of the 
+	DN value returned to the LDAP client, OpenLDAP will have the comma 
+	replaced by "\2C" so that it is not mistaken for a comma delimiter 
+	in the DN string.  However, some LDAP clients aren't smart enough 
+	to understand what "\2C" means.  So we give the proxy admin the 
+	choice of having the CN rewritten to remove the comma.  That should 
+	catch "Last, First" names and rewrite them as "First Last".
+	If there is more than one comma in the CN, we don't know what kind 
+	of data is being represented in the CN and don't try to rewrite it.
+	Setting "normalize_common_name" to "yes" will tell the LDAP Proxy
+	to always rewrite CN values that contain a single comma.
+	[Default: no]
+
+    enforce_keyusage 
+
+	The "enforce_keyusage" option allows you to limit which certificates
+	the LDAP Proxy returns based on the keyUsage flags set in the
+	certificate.  The optional key usage certificate extension defines
+	the intended purpose of the key contained in the certificate.
+	The LDAP Proxy can enforce any combination of the following nine key
+	usage flags:
+	    digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment,
+	    keyAgreement, keyCertSign, cRLSign, encipherOnly, decipherOnly
+	Each enforce_keyusage flag must be specified on a separate line.
+	The key usage flags must be spelled as listed above but are
+	case-insensitive.
+	For example, to require that certificates contain both keyEncipherment
+	and dataEncipherment flags before being delivered by the LDAP Proxy,
+	use the following config options:
+	    enforce_keyusage keyEncipherment
+	    enforce_keyusage dataEncipherment
+	When enforce_keyusage flags are specified, the LDAP Proxy will reject
+	any certificate that does not have *all* of the key usage flags
+	specified in the proxy config file with "enforce_keyusage" options.
+	Note that the key usage is optional in X.509 certificates.  If you
+	specify any enforce_keyusage options and the certificate being
+	examined does not contain keyUsage flags, it will be rejected.
+	Also, if the "certificate_check" option (see above) is set to "0",
+	the certificate is not read and no "enforce_keyusage" checking is done.
+	[Default: NULL]
+
+    ####################################################
+    # The following options are used to fine-tune data #
+    # structures within the LDAP Proxy.  You probably  #
+    # do not want to mess around with them.            #
+    ####################################################
+
+    max_queries 64
+
+	"max_queries" determines the size of the in-memory pending_queries
+	table.  This table keeps track of all the queries currently being
+	processed by the Proxy.  It is used to detect and deal with Proxy
+	query infinite loops and denial of service attacks.  Setting this
+	too high wastes system resources.  Setting it too low causes query
+	rejections.  The default value should be sufficient for typical Proxy
+	configurations, though in extreme cases busy systems could need a
+	larger table while a mostly idle system could use a smaller table.
+	[Default: 64]
+
+    max_results_cache 128
+
+	"max_results_cache" determines the size of an in-memory cache used for
+	short-term storage of certificate search results from completed LDAP
+	SEARCH queries.  Microsoft's Outlook email client sends multiple LDAP
+	commands for each single search.  The client does not actually accept
+	the bulk of the search results until they are send in response to the
+	last LDAP query in the sequence.  So we are forced to save all search
+	results until we can determine if the next search request will meet
+	the criteria.  If so, we must send the results again from the cache.
+	[Default: 128]
+
+    max_results_life 30
+
+	"max_results_life" determines how long (in seconds) a cached search
+	result will be held in the max_results_cache.  Each time the proxy
+	receives a new search query, it removes any cached search results
+	that have been in the max_results_cache longer than max_results_life
+	seconds.
+	[Default: 30]
+
+    max_certificates 128
+
+	"max_certificates" is the maximum number of certificates that the
+	LDAP Proxy will return per search query.
+	[Default: 128]
+
+#--------------------------------------------------------------------------
+</pre>
+
+<p>
+  <a name="Section_7"></a>
+  <li><font size="+1"><b>LDAP Proxy Administration</b></font><br>
+<p>
+  <ul>
+    <a name="subsection_7a"></a>
+    <li><i><b>Install Summary</b></i><p>
+	The following sections outline the details for installing the
+	LDAP proxy using the following steps:
+	<ol>
+	  <li>Untar the proxy.
+	  <li>Modify the Proxy start and stop scripts
+	      <b><i>start_ldap_proxy</i></b> and <b><i>stop_ldap_proxy</i></b>.
+	  <li>Edit the configuration file <b><i>slapd.conf</i></b>.
+	  <li>Add entries to the server list files
+	      <b><i>certificate_server_list.txt</i></b> and 
+	      <b><i>ldap_server_list.txt</i></b>.
+	  <li>Enable logging by updating the <b><i>syslog.conf</i></b> file.
+	  <li>Start the Proxy.
+	</ol>
+	<p>
+    <li><i><b>Installation</b></i><br>
+	<p>
+	The LDAP Proxy software is distributed for Sun Solaris and Linux
+	systems as a tarball named something like ldap_proxy_4.1.tar.gz.
+	Move the tarball to the directory you wish to install ldap_proxy into.
+	Uncompress the tarball via:
+	<p>
+	<font color="blue">gunzip ldap_proxy_4.1.tar.gz</font>
+	<p>
+	and extract the directory tree via:
+	<p>
+	<font color="blue">tar xvf ldap_proxy_4.1.tar</font> 
+	<p>
+	You can now delete the tar file.
+	<p>
+    <a name="subsection_7b"></a>
+    <li><i><b>Configuration</b></i><br>
+	<p>
+	Once ldap_proxy has been installed, you must configure several files:
+	<ol>
+	  <li><font color="blue">ldap_proxy_4.1/bin/start_ldap_proxy</font><br>
+		<font color="blue">ldap_proxy_4.1/bin/stop_ldap_proxy</font><br>
+		<font color="blue">ldap_proxy_4.1/bin/set_permissions.sh</font>
+		<p>
+		Modify the "PROXYHOME" line in these scripts to point to the
+		directory that the Proxy has been installed in.
+		<p>
+	  <li><font color="blue">ldap_proxy_4.1/etc/openldap/slapd.conf</font>
+		<p>
+		See the Configuration File section above for a description of 
+		the conf file entries.  At a minimum you will need to modify
+		the "ucdata-path", "include", "pidfile", "argsfile",
+		"certificate_serverlist", and "ldap_serverlist" entries to
+		reflect the full path to these files.  The remaining options
+		in the configuration file have default values which will be
+		sufficient for most LDAP Proxy uses.
+		<p>
+	  <li><font color="blue">
+		ldap_proxy_4.1/libexec/certificate_server_list.txt</font>
+		<p>
+		Enter LDAP server information for each remote LDAP certificate
+		server or LDAP Proxy that this instance of ldap_proxy will be
+		able to access (see "LDAP Server Lists" above).  The default
+		server list file that is installed via the LDAP Proxy install
+		file will already some entries that can serve as examples.
+		<p>
+	  <li><font color="blue">
+		ldap_proxy_4.1/libexec/ldap_server_list.txt</font>
+		<p>
+		Enter LDAP server information for each remote LDAP CRL server 
+		this instance of ldap_proxy will be able to access.
+		(see "LDAP Server Lists" above).  The default server list file
+		that is installed via the LDAP Proxy install file will already
+		some entries that can serve as examples.
+		<p>
+	  <li><font color="blue">
+		/etc/syslog.conf</font>
+		<p>
+	        Specify a log file for the LDAP Proxy via the syslog facility
+		by adding a line like the following to /etc/syslog.conf<br>
+	        [NOTE: The two fields must be separated by tab characters,
+	        not spaces.]
+	        <p>
+	        <font color="blue">
+	        local4.info;local4.debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+		            /usr/local/logs/ldap_proxy.log</font>
+	        <p>
+	        Then force the syslog daemon to reread the syslog.conf file via:
+	        <p>
+	        <font color="blue">kill -1 PID</font>
+	        <p>
+	        Where "PID" is the process ID of syslogd.  
+		More information about logging options is available below
+		under: <i>Logging</i>.
+	</ol>
+	<p>
+    <a name="subsection_7k"></a>
+    <li><i><b>Migrating from Proxy version 3 to version 4</b></i><br>
+	<p>
+	If you have been running a version 3 LDAP Proxy and are now
+	installing a version 4 LDAP proxy, you will need to move the
+	server entries listed in your 
+	<font color=blue>crl_server_list.txt</font> file to the new
+	<font color=blue>ldap_server_list.txt</font> file located in 
+	<font color=blue>ldap_proxy_4.1/libexec/</font>.  The 
+	<font color=blue>crl_server_list.txt</font> file is no 
+	longer used.
+	<p>
+	There are two differences between version 3 entries and version
+	4 entries in the <font color=blue>ldap_server_list.txt</font>
+	file.  The fouth line of each entry used to be the CRL list
+	attribute name.  In version 4 this can be the attribute name
+	for any single attribute in the LDAP entry pointed to by the
+	BaseDN entry in the first line.  In addition, it is now possible
+	to return all core attributes from an LDAP entry by specifying
+	"all" as the attribute name.
+	<p>
+	The second difference between the versions is the addition of
+	a new, and as yet unimplemented, option in line five of the 
+	<font color=blue>ldap_server_list.txt</font> file entry.  This
+	will be a keyword to describe the type of data represented by
+	the attribute name in line four.  This will allow data verification.
+	But for now, put "none" in line five of each entry.  This moves
+	the "bind dn" and "bind password" entries to lines 6 and 7.
+
+    <a name="subsection_7c"></a>
+    <li><i><b>Platform Issues</b></i><br>
+	<p>
+      <ul>
+	<li>
+	<b>Solaris</b> has a low number of open file descriptors available by
+	default (256 maximum).  Each incoming query to the LDAP Proxy will
+	open one or two new file descriptors to handle network traffic.
+	A busy LDAP Proxy can run out of file descriptors if the LDAP servers
+	it queries are slow to respond.  You can check the file descriptors
+	limit via:
+	<p>
+        <font color="blue">
+          ulimit -a
+        </font>
+        <p>
+	The LDAP Proxy startup script uses the following ulimit command to
+	increase the number of file descriptors available to the Proxy:
+        <p>
+        <font color="blue">
+          ulimit -n 1024
+        </font>
+        <p>
+	<li>
+	Under <b>RedHat Linux</b>, if the network firewall facility is enabled,
+	LDAP and NIS no longer work.  You must disable the firewall in 
+	order to make use of the LDAP protocol and the LDAP Proxy.<br>
+	To configure the firewall using the Gnome user interface:<br>
+	<p>
+	<font color="blue">
+	  Main Menu-&gt;System Settings-&gt;Security Level
+	</font>
+	<p>
+	<li>
+	Most newer <b>Linux</b> releases use a version of syslogd that allows
+	selecting (in /etc/syslog.conf) which log files use asynchronous
+	logging.  This is done by prefixing the path name of the log file with
+	"-". For example:
+	<p>
+	<font color="blue">
+	local4.info;local4.debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+		        -/usr/local/logs/ldap_proxy.log</font>
+	<p>
+	Without this option, LDAP Proxy messages will be logged synchronously
+	which can seriously degrade Proxy performance, especially when 
+	debugging messages are enabled in the slapd.conf file.  To determine
+	if your Linux implementation uses this option, check the 
+	syslog.conf(5) man page or look for entries in the /etc/syslog.conf
+	file that are using this option.
+	<p>
+	<li>
+	<b>Microsoft Active Directory 2003</b>
+	<br>
+	Active Directory 2003 has added security restrictions as compared with
+	earlier versions of Active Directory.  By default, searches are not 
+	permitted by LDAP clients who anonymously bind to the Active Directory 
+	server.  If the data being served is spread across multiple Active 
+	Directory servers, a query from the LDAP Proxy may be redirected (LDAP
+	referral) to other Active Directory servers which the LDAP proxy will
+	access via an anonymous bind.  This will prevent the Proxy from
+	searching this server and the query will not be successful.  In these
+	cases the proxy should be configured to access the primary Active
+	Directory on port 3268 rather than port 389.  Port 3268 allows access
+	to the "Global Catalog" which contains a limited subset of all the
+	directory data in the distributed Active Directory "forest", including
+	certificates.
+	<p>
+      </ul>
+    <a name="subsection_7d"></a>
+    <li><i><b>Starting the Proxy</b></i><br>
+	<p>
+	By default, the LDAP Proxy listens on port 389 for incoming queries.
+	&nbsp; Port 389 is the standard LDAP port and is known to LDAP clients
+	as the default port. &nbsp; However, the proxy can be configured to
+	listen on any port. &nbsp; This is done by use of the "-h" option to
+	the slapd startup command (see below). &nbsp; If the LDAP Proxy is
+	configured to run on any port less than 1024 (including port 389) it
+	must be started and run under the "root" userid. &nbsp; If the proxy
+	is run on a port number higher than 1024, any user can start and run
+	the proxy. &nbsp; However, all LDAP clients that send queries to the
+	proxy must specify the new port number in the LDAP request.
+	<p>
+	Start the Proxy via:<br>
+	<p>
+	<font color="blue">ldap_proxy_4.1/bin/start_ldap_proxy</font>
+	<p>
+	Ldap_proxy process can also be started directly via:
+	<p>
+	<font color="blue">ldap_proxy_4.1/libexec/slapd</font>
+	<p>
+	This command and the startup script launches the slapd daemon in 
+	the background.  
+	<br>
+	slapd supports a number of command-line options as detailed in the
+	slapd(8) manual page.  Below are a few of them:
+	<p>
+	<center>
+	<table width="70%">
+	  <tbody><tr>
+	    <td valign="top" width="5%">-d</td>
+	    <td>&lt;debug level of front-end slapd process&gt;<br>
+		(See "Logging" below).<br>
+		If this option is specified, slapd will run in the foreground
+		and front-end debugging information will display to the screen
+		as slapd runs.<br>
+		&nbsp;
+	     </td>
+	  </tr>
+	  <tr>
+	    <td valign="top">-f</td>
+	    <td>&lt;filename&gt;<br>
+		This option specifies a different slapd.conf file than the
+		default in ldap_proxy_4.1/etc/openldap/slapd.conf.<br>
+		&nbsp;
+	    </td>
+	  </tr>
+	  <tr>
+	    <td valign="top">-h</td>
+	    <td>&lt;URLlist&gt;<br>
+		This option can be used to run the LDAP Proxy on a port other
+		than the default LDAP port 389.  For example, to run the Proxy
+		on port 390, start slapd via:
+		<p>
+		<font color="blue">
+		ldap_proxy_4.1/libexec/slapd -h "ldap://0.0.0.0:390/"
+		</font><br>
+                &nbsp;
+	    </td>
+	  </tr>
+	  <tr>
+	    <td valign="top">-l</td>
+	    <td>&lt;syslog-local-user&gt;<br>
+		Use this to specify a different log file for the Proxy to 
+		log to.  The <font color="blue">syslog-local-user</font> value
+		can be LOCAL0, LOCAL1, and so on, up to LOCAL7.  The default
+		value is LOCAL4.  Use use the 
+		<font color="blue">syslog-local-user</font> value selected here
+		when defining the log file name in /etc/syslog.conf:
+                <p>
+                <font color="blue">
+		 local6.info;local6.debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+		       /usr/local/logs/ldap_proxy_alt.log
+                </font>
+	    </td>
+	  </tr>
+	</tbody></table>
+	</center>
+	<p>
+    <a name="subsection_7e"></a>
+    <li><i><b>Stopping the Proxy</b></i><br>
+	<p>
+	Sending a HUP signal to the slapd process will allow the Proxy to
+	conclude any current LDAP session and shut down cleanly.
+	Stop the Proxy via:<br>
+	<p>
+	<font color="blue">ldap_proxy_4.1/bin/stop_ldap_proxy</font>
+	<p>
+	You can also shut down the Proxy process directly if you know the
+	process ID of the "slapd" process:
+	<p>
+	<font color="blue">kill -1 PID</font>
+	<p>
+	Where "PID" is the process ID of slapd.
+	<p>
+	On Linux systems, each ldap_proxy thread runs as a separate process.
+	So there will be several slapd processes running at any one time.
+	To bring down the ldap_proxy, it is only necessary to kill the process
+	whose parent process is number "1".
+	<p>
+    <a name="subsection_7f"></a>
+    <li><i><b>Logging</b></i><br>
+	<p>
+	There are three types of logging performed by the LDAP Proxy:
+	<ul>
+	  <li>Informational messages written to the LDAP Proxy log file
+	      by the syslog facility.  These messages allow monitoring of
+	      the Proxy status and operation.
+	  <li>Configurable debugging messages produced by the getcert back-end
+	      process and written to the LDAP Proxy log file by the syslog 
+	      facility.  These messages display the internal operation of the
+	      LDAP search, certificate, and data handling processes.
+	  <li>Configurable debugging messages produced by the slapd front-end
+	      process.  These messages display the internal operation of
+	      the LDAP protocol and session handling processes.  The messages
+	      are displayed on the system terminal if the debugging level is
+	      specified via the "-d" option of the slapd command.  Otherwise,
+	      these messages will be logged via the syslog facility using the
+	      debugging level specified by "loglevel" in the slapd.conf file.
+	</ul>
+	<p>
+	Only informational message logging is required for normal LDAP Proxy
+	operations.
+	<p>
+	<ol>
+	  <li><b>syslog</b>
+	    <p>
+	    You must define in the /etc/syslog.conf file the log file(s) to
+	    be used by the LDAP Proxy(s) you intend to run on the system.
+	    By default the Proxy will use the "LOCAL4" syslog log facility
+	    to identify the log file in syslog.conf.  You can override this
+	    default by using the "-l" option of the slapd command (See
+	    "Starting the Proxy" above for more details).  You can specify
+	    LOCAL0, LOCAL1, and so on through LOCAL7 with the "-l" option.
+	    <p>
+	    Specify a log file for ldap_proxy via the syslog facility by
+	    adding a line like the following to /etc/syslog.conf<br>
+	    [NOTE: The two fields must be separated by tab characters,
+	    not spaces.]
+	    <p>
+	    <font color="blue">
+	    local4.info;local4.debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+		        /usr/local/logs/ldap_proxy.log</font>
+	    <p>
+	    Then force the syslog daemon to reread the syslog.conf file via:
+	    <p>
+	    <font color="blue">kill -1 PID</font>
+	    <p>
+	    Where "PID" is the process ID of syslogd.  Syslogd must reread
+	    the syslog.conf file whenever the log file is moved or renamed,
+	    even if it is renamed to the same name (i.e., log file rotation).
+	    <p>
+	  <li><b>Debugging Getcert</b>
+	    <p>
+	    Debugging messages produced by the getcert back-end process can
+	    be configured using the "debugging" option in the slapd.conf
+	    configuration file.  When greater than zero, debugging messages 
+	    from the backend process are logged via syslog to the LDAP Proxy
+	    log.  To select debugging messages from several levels, you can 
+	    add the levels.  For example, to get high-level, low-level, and 
+	    memory management messages logged together, specify "debug 7" 
+	    (level 1 + level 2 + level 4).
+	    Debugging levels greater than "3" are not likely to be useful
+	    except during Proxy software development.
+	    <p>
+	    <table border="1" cellpadding="4" cols="2" width="70%">
+	      <tbody><tr> <td align="center" width="10%">0</td>
+		   <td>No debugging messages are produced.</td>
+	      </tr>
+	      <tr> <td align="center">1</td>
+		   <td>General high-level debugging messages.</td>
+	      </tr>
+	      <tr> <td align="center">2</td>
+		   <td>Additional low-level debugging messages, including
+		       full copies of all certificates returned to the
+		       requester.
+		   </td>
+	      </tr>
+	      <tr> <td align="center">4</td>
+		   <td>Dynamic memory management debugging messages.</td>
+	      </tr>
+	      <tr> <td align="center">8</td>
+		   <td>Messages from the certificate and data parsing routines.
+		       <br>
+		       [WARNING: This level can significantly degrade Proxy 
+		       performance.]</td>
+	      </tr>
+	    </tbody></table>
+	    <p>
+	  <li><b>Debugging slapd</b>
+	    <p>
+	    The OpenLDAP slapd front-end process handles LDAP session and
+	    protocol handling.  The level of debugging messages is specified
+	    with the "loglevel" variable in the slapd.conf file, but can be 
+	    overridden via the "-d" option of the slapd command when slapd is 
+	    started.  When using "-d" the messages are displayed on the
+	    console monitor rather than the log file.
+	    <p>
+	    <font color="blue">ldap_proxy_4.1/libexec/slapd -d NUM</font>
+	    <p>
+	    where "NUM" is a debugging level from the following list:
+	    <p>
+	    <table border="1" cellpadding="4" cols="2" width="50%">
+	      <tbody><tr> <td align="center" width="20%">-1</td>
+		   <td>Enable all debugging levels</td> </tr>
+	      <tr> <td align="center">0</td>
+		   <td>No debugging</td> </tr>
+	      <tr> <td align="center">1</td>
+		   <td>trace function calls</td> </tr>
+	      <tr> <td align="center">2</td>
+		   <td>debug packet handling</td> </tr>
+	      <tr> <td align="center">4</td>
+		   <td>heavy trace debugging</td> </tr>
+	      <tr> <td align="center">8</td>
+		   <td>connection management</td> </tr>
+	      <tr> <td align="center">16</td>
+		   <td>packets sent &amp; received</td> </tr>
+	      <tr> <td align="center">32</td>
+		   <td>search filter processing</td> </tr>
+	      <tr> <td align="center">64</td>
+		   <td>configuration file processing</td> </tr>
+	      <tr> <td align="center">128</td>
+		   <td>access control list processing</td> </tr>
+	      <tr> <td align="center">256</td>
+		   <td>stats log connections/operations/results</td> </tr>
+	      <tr> <td align="center">512</td>
+		   <td>stats log entries sent</td> </tr>
+	      <tr> <td align="center">1024</td>
+		   <td>print communications with shell backends</td> </tr>
+	      <tr> <td align="center">2048</td>
+		   <td>print entry parsing debugging</td> </tr>
+	    </tbody></table>
+	    <p>
+	    The debugging level numbers can be added together to log multiple
+	    levels.  The "-d" option produces messages from the front-end slapd
+	    process only and is likely to be useful only in debugging OpenLDAP
+	    function.
+	    <p>
+	  </ol>
+    <p>
+    <a name="subsection_7g"></a>
+    <li><b>Error Messages and Return Codes</b>
+    <p>
+    The LDAP Proxy will display error messages during start up to the terminal 
+    that is running the "start_ldap_proxy" script.  Once the Proxy has started 
+    successfully, status and error messages will be logged in the LDAP Proxy 
+    log by the syslog process (See "Logging" above).  More detailed status and
+    error messages will be logged in the Proxy log when the "debugging" option 
+    is enabled in the slapd.conf configuration file (See "Configuration File"
+    above).<br> 
+    All informational and error messages passed by the Proxy to LDAP clients 
+    must be in the form of LDAP return codes rather than text messages.
+    Consequently, each LDAP client program will display messages based on
+    its own interpretation of the LDAP return codes it receives.
+    <p>
+    By default, the LDAP Proxy will return only two LDAP Return Codes:
+    LDAP_SUCCESS (0) or LDAP_OPERATIONS_ERROR (1).  However, for development
+    and debugging purposes, the list of possible return codes generated by the
+    Proxy can be expanded via the "limit_return_codes" option in the slapd.conf
+    configuration file.  The use of expanded return codes can confuse some LDAP
+    client programs that are not expecting them or do not understand them.
+    <p>
+    <table border="1" cellpadding="4" cols="4" width="90%">
+	<tbody><tr> <th rowspan="2" align="center" width="30%">Return Code Name</th>
+	     <th colspan="2" align="center" width="10%">limit_return_codes</th>
+	     <th rowspan="2" align="center" width="60%">Description</th>
+	</tr>
+	     <tr><th align="center" width="5%">yes</th>
+	     <th align="center" width="5%">no</th>
+	</tr>
+
+	<tr> <td>LDAP_SUCCESS</td>
+	     <td align="center">0</td>
+	     <td align="center">0</td>
+	     <td>No errors were encountered by the Proxy. 
+		 However, this does not necessarily imply that
+		 any valid certificates or data were found.</td>
+	</tr>
+	<tr> <td>LDAP_OPERATIONS_ERROR</td>
+	     <td align="center">1</td>
+	     <td align="center">1</td>
+	     <td>The Proxy experienced problems while trying
+		 to process LDAP search results.</td>
+	</tr>
+	<tr> <td>LDAP_NO_SUCH_ATTRIBUTE</td>
+	     <td align="center">0</td>
+	     <td align="center">16</td>
+	     <td>Entries were found on at least one of the LDAP
+		 servers listed in the Proxy's server list that
+		 match the email address given to the Proxy, but
+		 no valid certificates were found in those entries.</td>
+	</tr>
+	<tr> <td>LDAP_INVALID_SYNTAX</td>
+	     <td align="center">1</td>
+	     <td align="center">21</td>
+	     <td>One of the entries in the Proxy's LDAP server
+		 list is malformed.</td>
+	</tr>
+	<tr> <td>LDAP_NO_SUCH_OBJECT</td>
+	     <td align="center">0</td>
+	     <td align="center">32</td>
+	     <td>No entry was found on any of the LDAP servers
+		 listed in the server list that match the email
+		 address given to the Proxy.</td>
+	</tr>
+	<tr> <td>LDAP_BUSY</td>
+	     <td align="center">1</td>
+	     <td align="center">51</td>
+	     <td>The query was rejected because the Proxy is currently
+		 processing the maximum number of queries it is configured
+		 for (as defined by the "max_queries" slapd.conf 
+		 configuration option).</td>
+	</tr>
+	<tr> <td>LDAP_UNAVAILABLE</td>
+	     <td align="center">1</td>
+	     <td align="center">52</td>
+	     <td>Either a certificate request is being rejected because 
+		 no certificate server list file was defined on the LDAP
+		 Proxy, or a search request is being rejected because no
+		 LDAP server list file was defined.</td>
+	</tr>
+	<tr> <td>LDAP_LOOP_DETECT</td>
+	     <td align="center">1</td>
+	     <td align="center">54</td>
+	     <td>The query was rejected because the Proxy was already
+		 processing an identical query from the same client
+		 address.</td>
+	</tr>
+	<tr> <td>LDAP_RESULTS_TOO_LARGE</td>
+	     <td align="center">1</td>
+	     <td align="center">70</td>
+	     <td>The Proxy could not allocate enough memory on
+		 the Proxy server to process search results.</td>
+	</tr>
+	<tr> <td>LDAP_TIMEOUT</td>
+	     <td align="center">1</td>
+	     <td align="center">85</td>
+	     <td>A search request was sent by the LDAP Proxy to a
+		 remote LDAP server, but no search results were
+		 returned within the configured timeout period 
+		 (default: thirty seconds).</td>
+	</tr>
+	<tr> <td>LDAP_FILTER_ERROR</td>
+	     <td align="center">1</td>
+	     <td align="center">87</td>
+	     <td>The search filter containing the email address
+		 that was provided by the LDAP client was invalid.
+		 Usually caused by a missing or malformed email 
+		 address or a syntax error in the search string.</td>
+	</tr>
+    </tbody></table>
+    <p>
+    <a name="subsection_7h"></a>
+    <li><b>Testing the Proxy</b>
+    <p>
+    A useful tool for testing the LDAP Proxy or an LDAP server is the 
+    <font color="blue"><i>ldapsearch</i></font> utility included in the
+    LDAP Proxy installation.  For example, to fetch a user's public
+    certificate execute the following:
+    <p>
+    <i>
+    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+    ldap_proxy_4.1/bin/ldapsearch &nbsp; -h &nbsp; &lt;LDAPserver&gt; &nbsp;
+    -p &nbsp; &lt;ldap_port&gt; &nbsp; -b &nbsp; &lt;base_dn&gt; &nbsp; 
+    "(mail=first.i.last@email_domain)"
+    </i>
+    <p>
+    The values for &lt;LDAPserver&gt;, &lt;ldap_port&gt;, and 
+    &lt;base_dn&gt; can be read from the certificate_server_list.txt file.
+    <p>
+    To fetch a CRL, execute the following:
+    <p>
+    <i>
+    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+    ldap_proxy_4.1/bin/ldapsearch &nbsp; -h &nbsp; &lt;LDAPserver&gt;
+    &nbsp; -p &nbsp; &lt;ldap_port&gt; &nbsp; -b &nbsp;&nbsp; &lt;base_dn&gt;
+    &nbsp; "(objectClass=*)" &nbsp; certificateRevocationList
+    </i>
+    <p>
+    The values for &lt;LDAPserver&gt;, &lt;ldap_port&gt;, and 
+    &lt;base_dn&gt; can be read from the ldap_server_list.txt file.
+    <p>
+    To fetch all core data from an LDAP entry, execute the following:
+    <p>
+    <i>
+    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+    ldap_proxy_4.1/bin/ldapsearch &nbsp; -h &nbsp; &lt;CRLserver&gt;
+    &nbsp; -p &nbsp; &lt;ldap_port&gt; &nbsp; -b &nbsp;&nbsp; &lt;base_dn&gt;
+    &nbsp; "(objectClass=*)"
+    </i>
+    <p>
+    The values for &lt;CRLserver&gt;, &lt;ldap_port&gt;, and 
+    &lt;base_dn&gt; can be read from the ldap_server_list.txt file.
+    However, the entry in the ldap_server_list.txt file that matches the
+    &lt;base_dn&gt; must have "all" listed as the attribute name (line 4).
+    <p>
+    The following examples use the Boeing LDAP Proxy to demonstrate the
+    three types of queries the LDAP Proxy is designed to respond to:
+    <p>
+    <i>
+    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+    ldap_proxy_4.1/bin/ldapsearch &nbsp; -h &nbsp; dir.boeing.com 
+    &nbsp; -p &nbsp; 389 &nbsp; '(mail=wen.fang@boeing.com)'
+    </i>
+    <p>
+    This query returns Wen Fang's public encryption certificate.
+    <p>
+    <i>
+    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+    ldap_proxy_4.1/bin/ldapsearch &nbsp; -h &nbsp; dir.boeing.com
+    &nbsp; -p &nbsp; 389 &nbsp; -b &nbsp; 
+    'CN=The Boeing Company Class 2 Certificate Authority,OU=netscape,OU=certservers,O=Boeing,C=US'
+    &nbsp; certificateRevocationList
+    </i>
+    <p>
+    This query returns a Certificate Revocation List from the Boeing Class 2
+    Certificate Authority.
+    <p>
+    <i>
+    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+    ldap_proxy_4.1/bin/ldapsearch &nbsp; -h &nbsp; dir.boeing.com
+    &nbsp; -p &nbsp; 389 &nbsp; -b &nbsp;
+    'CN=Boeing PCA Med Hardware,OU=certservers,O=Boeing,C=US'
+    &nbsp; '(objectClass=*)'
+    </i>
+    <p>
+    This query returns all data found in the Boeing Class 3 Medium Assurance
+    Hardware LDAP entry.
+    <p>
+    <a name="subsection_7i"></a>
+    <li><b>Running Multiple Instances of LDAP Proxy</b>
+    <p>
+    You can run more than one LDAP Proxy on the system at a time.
+    Each instance must be assigned a unique LDAP port number and
+    each instance should be assigned its own log file.  To add a
+    new instance of the LDAP Proxy on a system already running one
+    or more Proxies, do the following:
+    <p>
+    <ul>
+      <li>Install the New Proxy
+	  <p>
+	  Install the new Proxy using the instructions above under
+	  "Installation" and "Configuration".  You may need to change
+	  the name of the directory name this instance is installed
+	  under so that it doesn't conflict with other Proxies already
+	  installed on the system.  For example, to install a new 
+	  instance of LDAP Proxy 4.2 in the same directory that 
+	  contains other instances of the 4.2 Proxy:
+	  <p>
+	  <font color="blue">
+	    mkdir &nbsp; temp<br>
+	    cd &nbsp; temp<br>
+	    tar &nbsp; xf &nbsp; ldap_proxy_4.1.tar<br>
+	    mv &nbsp; ldap_proxy_4.1 &nbsp; ../ldap_proxy_4.1_port395<br>
+	    rm &nbsp; ldap_proxy_4.1.tar<br>
+	    cd &nbsp; ..<br>
+	    rmdir &nbsp; temp
+	  </font>
+	  <p>
+      <li>slapd Configuration
+	  <p>
+	  Edit the <font color="blue">
+	  ldap_proxy_4.1_port395/bin/start_ldap_proxy
+	  </font> script by adding configuration options to the 
+	  "slapd" line.  For example, to run the new Proxy on LDAP
+	  port 395 and using a new log file, enter the "slapd" line 
+	  to look like this:
+	  <p>
+	  <font color="blue">
+	  $PROXYHOME/libexec/slapd &nbsp;
+		-h &nbsp; "ldap://0.0.0.0:395/" &nbsp; 
+		-l &nbsp; LOCAL5
+	  </font>
+	  <p>
+      <li>syslog Configuration
+	  <p>
+	  Add the following line to /etc/syslog.conf to define a 
+	  unique log file for use by this LDAP Proxy instance.
+	  Use the LOCAL value you selected above with the "-l" slapd
+	  option:
+	  <p>
+	  <font color="blue">
+          local5.info;local5.debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+	        /usr/local/logs/ldap_proxy_395.log</font>
+	  <p>
+	  [NOTE: The two fields must be separated by tab characters,
+	   not spaces.]
+	  
+	  <p>
+	  Tell syslogd to reread its configuration file via:
+	  <p>
+	  <font color="blue">
+	    kill&nbsp;&nbsp;-1&nbsp;&nbsp;&lt;PID&gt;
+	  </font>
+	  <p>
+	  Where <pid> is the process ID of then syslogd process.
+      </pid><li>Use the Start and Stop Scripts
+	  <p>
+	  Change the PROXYHOME line at the top of the start and stop
+	  scripts in the bin directory so that it points to the 
+	  directory into which you have installed this version of the proxy.
+	  <p>
+	  You can now start and stop this instance of the LDAP Proxy
+	  using the scripts in bin directory.
+    </ul>
+    <p>
+    <a name="subsection_7j"></a>
+    <li><b>Reporting Problems</b>
+    <p>
+    If the LDAP Proxy has problems, the ldap_proxy.log file will be the 
+    most useful tool for identifying the source of the error.  Debugging
+    messages from the Proxy's back-end should pinpoint the error.  Set
+    the "debugging" option in the slapd.conf file to "3" to gather as
+    much useful data as possible.  The Proxy will log messages with the
+    "[error]" tag if it recognizes the problem as an error.  Check for 
+    these messages first.
+    <p>
+    If the problem is not obvious, sent a copy of the log file to the
+    <a href="#Section_13">LDAP Proxy Development Team</a> (email addresses
+    below). If the log file is large, it can be compressed before being emailed
+    using utilities like gzip, zip, compress, bzip2, etc.  Include also 
+    a copy of the X.509 certificate if it appears that the Proxy is having 
+    trouble interpreting it.  You can use the 
+    <font color="blue"><i>ldapsearch</i></font> utility (see above) to 
+    download a base64 encoded copy of the certificate.
+  </ul>
+<p>
+  <a name="Section_8"></a>
+  <li><font size="+1"><b>LDAP Proxy Web Interface</b></font>
+<p>
+    A <a href="http://www.boeing.com/companyoffices/doingbiz/ldap_proxy/get_cert.html">
+    web interface</a> to the LDAP Proxy is available on the Boeing web site.
+    This web page will
+    allow certificate lookups to be made through a web server.  The web 
+    interface is made up of a web page and a corresponding CGI program.
+    The web page allows the user to specify the email address of the person 
+    you want the public certificate(s) for, and the type of certificate 
+    (i.e., the certificate issuer).  The web page will invoke the CGI program 
+    which will perform the LDAP search using the Boeing LDAP Proxy.  
+    <p>
+    This interface has two primary advantages over client-based LDAP queries.
+    First, it allows access to the LDAP Proxy through firewalls that may be 
+    blocking LDAP ports which would prevent the user from doing email 
+    client-based LDAP queries to that Proxy.  This assumes, of course, 
+    that the firewall is not also blocking the HTTP port (80).  Secondly, 
+    the web interface will (hopefully) provide an easier means of getting 
+    public X.509 certificates imported into various email clients.  
+    <p>
+    The web interface is currently configured to help load certificates into
+    the Mozilla, Firefox, and Internet Explorer web browsers and the Entrust
+    Address Book.  Once the certificates are loaded into Mozilla, the built-in
+    Mozilla Communicator email client has access
+    to the certificates for use in email encryption and digital signing.  Also,
+    the Outlook email client has access to the public certificates once they
+    are loaded into Internet Explorer.  Once user certificates are loaded
+    into any of the web browsers, they can be exported and then imported into
+    the Thunderbird email client.
+    <p>
+    Alternatively, an option is available to have the certificate(s) returned
+    by the web interface displayed to the browser window.  This allows the user
+    to cut-and-paste each certificate to a file that can then be stored in PKI
+    client using the client's certificate import procedure.
+    <p>
+    A <a href=http://sourceforge.net/projects/ldap-proxy/>sourcecode kit</a>
+    is used to distribute the open-source LDAP Proxy Web Interface to those
+    who wish to build their own web interface.  In addition to the source
+    code kit, building the web interface will require additional open-source
+    software: OpenLDAP, GNUTLS, libgcrypt, and libgpg-error.
+    <p>
+<p>
+  <a name="Section_9"></a>
+  <li><font size="+1"><b>LDAP Proxy Development</b></font>
+<p>
+    <ul>
+      <li><a href=ldap_proxy_build.txt>
+            Building the LDAP Proxy From Source Code
+          </a>
+      <li><a href=flowcharts/ldap_proxy_flowcharts.html>
+	    Flow Charts
+          </a>
+    </ul>
+<p>
+  <a name="Section_11"></a>
+  <li><font size="+1"><b>Changelog</b></font>
+<p>
+<ul>
+  <li><b>Current Versions</b>
+    <ul>
+      <li>Version 4.2
+	<ul>
+	  <li>Change default logging level to produce only one line of log
+	      data per LDAP transaction when debugging is turned off.
+	  <li>Patch the CRL integrity check routine to prevent crashes 
+	      when CRL verification option is selected.
+	</ul>
+      <li>Version 4.1
+	<ul>
+          <li>Add a configuration option ("search_all_servers") that enables
+	      the searching of all relevant LDAP servers listed in the
+              certificate_server_lists.txt for certificates.  By default, the
+	      proxy stops searching LDAP servers once valid certificates are
+              found on a server.
+          <li>Return userSMIMECertificate values using the same process that
+              returns userCertificate (specifying "userSMIMECertificate" as
+              the certificate attribute name in the certificate_server_lists.txt
+              file).
+          <li>Use dynamic memory allocation rather than pre-allocated memory
+              for certificate buffers.<br>
+	      Add "max_certificates" configuration option to allow resizing
+	      of the buffers.
+          <li>Skip the BIND step for servers that do not require authentication
+              so we can avoid the four minute BIND timeout when the server is
+              unreachable.
+          <li>Change the tag on "No such object" log messages from "error" to
+              "debug".
+	  <li>Changes to certificate parsing routines to reduce variations 
+	      in code execution created by different C compilers.
+	  <li>Patch error handling to prevent OpenLDAP crash when releasing
+	      memory after remote LDAP server returns search errors.
+	  <li>Patch to prevent proxy crash when releasing memory allocated
+	      for certificate decoding when certificate decoding is disabled
+	      in the proxy configuration.
+	</ul>
+      <li>Version 4.0
+	<ul>
+	  <li>Rewrite search module to improve process flow of proxy
+	      enhancements.
+	  <li>Add the capability of finding and returning CA and signing
+	      certificates.
+	  <li>Add the ability to return all core data attributes found in an
+	      LDAP database entry, rather than just one selected attribute.
+	  <li>Update start & stop procedures to allow running the proxy 
+	      on alternate LDAP ports and under non-root accounts.
+	  <li>Enhance the parsing of search filters to improve ability to
+	      extract email address filters.
+	</ul>
+      <li>Version 3.3
+	<ul>
+          <li>Add a configurable option to filter certificates based on
+	      keyUsage flags.
+	  <li>Making improvements to CRL retrieval functions.
+	  <li>Add a CRL attribute name variable to the CRL server list file.
+	  <li>Log LDAP session "unbind" commands as debugging messages
+	      rather than info messages so that they match the logging
+	      level of the "bind" commands.
+	  <li>Change some logged messages from informational category to
+	      debugging category to reduce the size of the proxy log file.
+	</ul>
+      <li>Version 3.2.5
+	<ul>
+	  <li>Added objectClass record to proxy response to support Lotus
+	      Domino server.
+	  <li>Do not reject version 3 certificates that contain no Extensions
+	      section.
+	</ul>
+      <li>Version 3.2.4
+	<ul>
+	  <li>Modifications to support queries from Entrust messaging clients.
+	  <li>Update the certificate server list distributed with the install
+	      kit.
+	</ul>
+      <li>Version 3.2.3
+	<ul>
+	  <li>Patched certificate parsing routine to correct parsing of
+	      certificates returned from PGP server.
+	  <li>More improvements made to CRL parsing routines.
+	</ul>
+      <li>Version 3.2.2
+	<ul>
+	  <li>Improvements made to CRL parsing routines.
+	  <li>Increase the maximum number of open sessions OpenLDAP will
+		maintain from 1024 to 8192 (FD_SETSIZE).
+	</ul>
+      <li>Version 3.2.1
+	<ul>
+	  <li>When incoming LDAP search filter contains no email address,
+		return LDAP_SUCCESS rather than LDAP_OPERATIONS_ERROR.
+		This prevents problems caused by "look-ahead" queries sent 
+		by the LDAP client while the user is still typing in the 
+		search criteria.
+	</ul>
+    </ul>
+  <li><b>Superseded Versions</b>
+    <ul>
+      <li>Version 3.2
+	<ul>
+          <li>Strip quotes from email addresses when parsing search filters.
+          <li>Option to rewrite CN (CommonName) contents to remove
+                encoded comma.
+          <li>Skip bind step if LDAP server rejects LDAP version 2
+                clients.
+	  <li>Add configurable option to control amount of time
+		query results remain in the last_search_results cache.
+	</ul>
+      <li>Version 3.1:
+	<ul>
+	  <li> Add configurable option to do integrity checks
+		on CRL lists.
+	  <li> Add unbind in exception exit.
+	  <li> Implement "-l" slapd command line option to select
+		syslog logging facility allowing multiple log files.
+	  <li> Modify Proxy start and stop scripts to work in 
+		multi-Proxy environments.
+          <li> Add vCard output format option to the Proxy's web 
+		interface.
+	</ul>
+      <li>Version 3.0:
+	<ul>
+	  <li> Boeing Application Vulnerability Assessment.
+	  <li> Develop a web interface (Web page and cgi program).
+	  <li> Add the ability to find and return Certificate 
+		Revocation Lists (CRL).
+	  <li> Add configuration options to filter certificates
+		based on issuing Certificate Authority.
+	  <li> Add configurable certificate attribute name option
+		to the certificate server list file.
+	  <li> Separate debugging messages into user selectable
+		categories.
+	  <li> Add debugging messages to monitor dynamic memory 
+		management in the back-end process.
+	  <li> Tag debugging messages with "[error]" and "[debug]"
+		to simplify log file scanning.
+	  <li> Add ucdata-path info to slapd configuration file.
+	</ul>
+      <li>Version 2.5.1:
+	<ul>
+          <li> Use ldap_search_st() routine to perform LDAP searches for
+		application portability.
+	  <li> Do an explicit anonymous bind to each LDAP server before
+		issuing search command in order to verify server availability.
+	  <li> Deal with attribute name upper/lower case sensitivity 
+		issues by removing log_all_attributes option.
+	  <li> Boeing Application Vulnerability Assessment.
+	</ul>
+      <li>Version 2.5:
+	<ul>
+          <li> Upgrade OpenLDAP to version 2.1.30.
+          <li> Search multiple LDAP entries for certificates if more than
+		one entry matches search filter.
+	  <li> Handle situations where a replacement attribute for CN
+		is specified in the ldap_server_list but no value is returned
+		for that attribute by the LDAP search.
+	</ul>
+      <li>Version 2.4:
+	<ul>
+	  <li> LDAP protocol modifications to handle Outlook clients.
+	  <li> Add configuration option to size the last results cache.
+	  <li> Make "limit_return_codes yes" option the default.
+	</ul>
+      <li>Version 2.3:
+	<ul>
+	  <li> Upgrade OpenLDAP to version 2.1.29.
+	  <li> Configurable option to control certificate verification.
+	  <li> Decode certificate UTF8String values.
+	  <li> Expanded decoding of ASN.1 SET structure.
+	</ul>
+      <li>Version 2.2.2:
+	<ul>
+	  <li> Implement code modifications to meet specifications 
+                   of Boeing Application Vulnerability Assessment.
+	</ul>
+      <li>Version 2.2.1:
+	<ul>
+	  <li> Patch to fix handling of very long Object IDs.
+	</ul>
+      <li>Version 2.2:
+	<ul>
+	  <li> Enhance email address checking in certificates.
+	  <li> Configurable option to limit LDAP return codes.
+	  <li> Configurable option to log LDAP entry attributes.
+	</ul>
+      <li>Version 2.1:
+	<ul>
+	  <li> Deal with query infinite loops and denial of service attacks.
+	  <li> Configurable pending_queries table size.
+	  <li> Upgrade slapd to OpenLDAP 2.1.25.
+	</ul>
+      <li>Version 2.0:
+	<ul>
+	  <li> Source code rewrite &amp; cleanup.
+	  <li> Configurable timeout for search requests.
+	  <li> Kill Proxy if normal shutdown fails.
+          <li> Configurable debugging message level.
+          <li> Read certificate extension fields.
+	</ul>
+      <li>Version 1.11.3:
+	<ul>
+	  <li> Expand certificate decoding capabilities.
+	</ul>
+      <li>Version 1.11.2:
+	<ul>
+	  <li> Problems when following certificate chains that contain 
+                     multiple valid certificates.
+	</ul>
+      <li>Version 1.11.1:
+	<ul>
+	  <li> Reset email filter attribute before each server query.
+	</ul>
+      <li>Version 1.11:
+	<ul>
+	  <li> Upgrade OpenLDAP to Version 2.1.22.
+	  <li> Workaround RedHat Linux firewall issues.
+	  <li> Certificate chain issues.
+	  <li> Escaping special chars in DN strings.
+	</ul>
+      <li>Version 1.10:
+	<ul>
+	  <li> Upgrade OpenLDAP to Version 2.1.12.
+	  <li> Port LDAP Proxy to Linux (RedHat 8.0).
+	  <li> Return unique DN rather than baseDN.
+	</ul>
+      <li>Version 1.9:
+	<ul>
+	  <li> Multithreading issues.
+	</ul>
+      <li>Version 1.8:
+	<ul>
+	  <li> Recognize &amp; decode certs stored in hexdump format.
+	  <li> Don't return unreadable certificates.
+	  <li> Log client's IP &amp; LDAP version.
+	  <li> Add session ID to log entries.
+	</ul>
+      <li>Version 1.7:
+	<ul> 
+	  <li> Upgrade Version of OpenLDAP to 2.0.27.
+	</ul> 
+      <li>Version 1.6:
+	<ul>
+          <li> Boeing-specific user documentation.
+          <li> Search every relevant server in the serverlist list until
+	      the first valid certificate is returned.
+          <li> Failure to start if only one server defined in server list.
+	</ul>
+      <li>Version 1.5 and earlier:
+	<ul>
+      <li> Develop process to reload server list while Proxy is running.
+      <li> Convert error message text from development info to end user info.
+      <li> Add config option to limit access by certificate version.
+      <li> Ignore Spurious "(objectClass=*)" queries.
+      <li> Add debug mode configuration file option.
+      <li> Replace Debug routine calls with calls to syslog.
+      <li> Case sensitivity issues with email address.
+      <li> Have backend's ldap search query return only selected attributes.
+      <li> Do not return expired certificates (will require certificate
+	  decoding).
+      <li> Confirm that the email address searched for matches the
+	  address in the returned certificate.
+      <li> Return all non-expired personal certificates found.
+	</ul>
+    </ul>
+  <li><b>Possible Future Development</b>
+    <ul>
+      <li>Add the ability to validate found certificates by querying OCSP
+		responders.
+      <li>Add the ability to search a DNS server for service records
+		which define additional LDAP servers to be queried (RFC2782).
+      <li>Add ability to follow LDAP search referrals.
+      <li>Monitor & report number of open LDAP sessions.
+      <li>Provide https capability.
+      <li>Configurable option to return values of additional LDAP entry 
+		attributes.
+      <li>Use asynchronous LDAP searches to combine certificates returned 
+		from multiple LDAP servers.
+      <li>Adapt Kemp-Guttman dumpasn1 utility to replace locally written 
+		readcert code.
+      <li>Determine OpenLDAP multithreading techniques so certificate
+		reading code can be separated from ldap search routine.
+      <li>Scripts to gather metrics from Proxy log file.
+      <li>Process client side abort requests.
+      <li>Include support for userSMIMECertificate.
+      <li>Syntax checking of basedn and other entries in ldap server list.
+      <li>No thread timeout in OpenLDAP.
+      <li>Authentication for ldapmodify use.
+      <li>Implement init.d start/kill configuration.
+      <li>Configurable runtime UID/GID.
+      <li>Configurable install script.
+      <li>Change server list from positional ordered to keyword ordered.
+      <li>Web-based admin interface.
+    </ul>
+</ul>
+<p>
+  <a name="Section_13"></a>
+  <li><font size="+1"><b>LDAP Proxy Team</b></font>
+<p>
+<ul>
+<a href="mailto:wen.fang@boeing.com">
+Wen Fang</a>  -  Architecture &amp; Design<br>
+<a href="mailto:marc.amis@boeing.com">
+Marc Amis</a>  -  Development &amp; Implementation<br>
+<a href="mailto:darryl.p.lang@boeing.com">
+Darryl Lang</a>  -  Proxy Support<br>
+<p>
+<a href="mailto:ldap.proxy@boeing.com">
+ldap.proxy@boeing.com</a> - Development Team Mailbox
+</ul>
+<p>
+<center>
+<hr>
+<i>Last Update: August 2007<br>
+  Marc Amis
+</i>
+<p>
+<a href="http://sourceforge.net">
+    <img src="http://sourceforge.net/sflogo.php?group_id=126646&amp;type=3"
+    width="125" height="37" border="0" alt="SourceForge.net Logo">
+</a>
+</center>
+
+</ul>
+</body>
+</html>
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/etc/openldap/slapd.conf openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/etc/openldap/slapd.conf
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/etc/openldap/slapd.conf	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/etc/openldap/slapd.conf	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,244 @@
+#
+# See slapd.conf(5) for details on configuration options defined for
+# the OpenLDAP front-end process.  See the LDAP Proxy documentation 
+# (and the comments below) for details on configuration options for 
+# the Proxy backend process.
+# This file should NOT be world readable.
+#
+ucdata-path	/usr/local/apps/ldap_proxy_4.2/share/openldap/ucdata
+include		/usr/local/apps/ldap_proxy_4.2/etc/openldap/schema/core.schema
+include		/usr/local/apps/ldap_proxy_4.2/etc/openldap/schema/cosine.schema
+include		/usr/local/apps/ldap_proxy_4.2/etc/openldap/schema/inetorgperson.schema
+pidfile		/usr/local/apps/ldap_proxy_4.2/var/slapd.pid
+argsfile	/usr/local/apps/ldap_proxy_4.2/var/slapd.args
+
+# This loglevel pertains to frontend logging only.
+#loglevel 1024
+loglevel 0
+
+# Allow access by clients speaking LDAP version 2.
+allow bind_v2
+
+# Specify the number of seconds to wait before forcibly
+# closing an idle client connection. An idletimeout of 0,
+# the default, disables this feature.
+idletimeout 600
+
+#######################################################################
+# ldap_proxy backend definitions
+#######################################################################
+
+database getcert
+readonly off
+lastmod off
+
+# Allow anyone to search for certificates
+access to * by anonymous read
+
+# Set SUFFIX as "" so that slapd accepts any base dn value.
+suffix ""
+
+###################################################
+# The following options have default values which #
+# will be used if the option is not defined here. #
+###################################################
+
+# The "debugging" option sets the debugging message level of the backend
+# getcert process.  When greater than zero, debugging messages from the
+# backend process are logged via syslog to the LDAP Proxy log.  If no
+# debugging level is specified (the default level 0), the backend process
+# will log one line of informational data per LDAP transaction.
+# To select debugging messages from several levels, you can add the levels.
+# For example, to get high-level, low-level, and memory management messages
+# logged together, specify "7" (level 1 + level 2 + level 4).
+# Debugging levels greater than "3" are not likely to be useful except
+# during software development.
+# Debugging levels:
+#       0 = No debugging messages are logged.
+#       1 = General high-level debugging messages.
+#       2 = Additional low-level debugging messages.
+#       4 = Dynamic memory management messages.
+#       8 = Messages from data parsing routines.
+#           [WARNING: Level 8 debugging will significantly
+#                     degrade proxy performance.]
+# [Default: 0]
+debugging 0
+
+# "certificate_serverlist" is the full path name of the 
+# certificate_server_list file.  This file lists all the LDAP
+# servers that we can query for public X.509 certificates.
+# [Default: NULL]
+certificate_serverlist  /usr/local/apps/ldap_proxy_4.2/libexec/certificate_server_list.txt
+
+# "ldap_serverlist" is the full path name of the ldap_server_list file.
+# If this file exists and is not empty, the LDAP Proxy will be able
+# to fetch attribute values such as CRL lists and signing certificates.
+# [Default: NULL]
+ldap_serverlist  /usr/local/apps/ldap_proxy_4.2/libexec/ldap_server_list.txt
+
+# "certificate_check" determines how much checking the LDAP Proxy will do 
+# on the X.509 public encryption certificates it finds on the remote LDAP servers.
+# Valid options are:
+#	0 = No certificate checking.  Certificates are not examined and
+#	    are sent the the requesting client just as they are found.
+#	1 = Each certificate is decoded to confirm that it is a readable
+#	    X.509 certificate.
+#	2 = Each certificate is decoded and must meet the following
+#	    criteria before being sent to the requesting client:
+#	        a) The certificate is rejected if it is not readable and 
+#	           identifiable as an X.509 certificate.
+#	        b) The certificate validity dates are checked and the
+#		   certificate is rejected if found to be expired or premature.
+#	        c) The email address supplied by the client is compared with
+#	           any email addresses defined in the certificate.  If email 
+#		   addresses are defined in the certificate but none match the 
+#		   client specified email address, the certificate is rejected.
+# [Default: 2]
+certificate_check 2
+
+# "search_timeout" sets the maximum number of seconds that the proxy will
+# wait for a response to its LDAP search request from a remote LDAP server 
+# or LDAP proxy.  A value of "0" seconds means no timeout limit (i.e., 
+# wait forever).  [Default: 30 seconds].
+search_timeout 30
+
+# "certificatetype" limits the proxy to returning only one version of
+# X.509 certificate.  This option is ignored if the "certificate_check"
+# option is set to skip certificate decoding.
+#       0 = Return any version of certificate
+#       1 = Return only version 1 certificates
+#       2 = Return only version 2 certificates
+#       3 = Return only version 3 certificates
+# [Default: 0]
+certificatetype 0
+
+# "limit_return_codes" controls the type of return codes the LDAP proxy can
+# return to the LDAP client.  The LDAP Proxy communicates with LDAP clients 
+# by means of LDAP Return Codes.  By default, the proxy will return either 
+# LDAP_SUCCESS (0) or LDAP_OPERATIONS_ERROR (1) on completion of an LDAP
+# request.  If limit_return_codes is set to "no", the proxy will return codes 
+# selected from an expanded set of LDAP Return Codes (see the list of possible
+# return codes in the LDAP Proxy documentation [ldap_proxy_release_notes.html]).
+# The use of expanded return codes allow more descriptive status messages
+# during development and debugging.  However, some client programs may have
+# problems interpreting return codes they do not understand or expect.
+# [Default: yes]
+limit_return_codes   yes
+
+# "search_all_servers" determines whether the LDAP proxy will search all LDAP
+# servers listed in the certificate_server_lists.txt file for encryption
+# certificates that can be used with the email address specified in the LDAP
+# search request.  The default behavior of the Proxy is to return only the
+# certificates found at the first LDAP server that contains usable certificates
+# for the specified email address.  Setting "search_all_servers" to "yes" tells
+# the LDAP proxy to keep searching for more certificates even if it has already
+# found some usable certificates.  All certificates found are returned.
+# [Default: no] 
+search_all_servers   no
+
+# The "cert_issuer_accept" and "cert_issuer_reject" options allow you to 
+# select which Issuing Certificate Authorities you are willing, or unwilling,
+# to deliver certificates for.  The string values defined by these options 
+# are searched for within the "Issuer" section of the user certificates the 
+# Proxy retrieves from remote LDAP certificate servers.  If any of the values 
+# defined here are found in the Issuer description, the certificate is either 
+# passed along to the requestor, or not, based on whether the which of the 
+# "cert_issuer_" options you are using.  You can use as many of these options 
+# as you wish, each on a separate line.  But NOTE: You can only specify all 
+# "cert_issuer_accept" options or all "cert_issuer_reject" options.  You
+# *CANNOT* mix the two types of options together.  The string values are 
+# searched in a case-insensitive manner, but otherwise must match exactly
+# part or all of the Issuing Certificate Authority description.  Each string
+# value should be surrounded by quotes.  If you are defining 
+# "cert_issuer_accept" values, the Proxy will only deliver certificates that 
+# contain at least one of the cert_issuer_accept values in its Issuer section.
+# If you are defining "cert_issuer_reject" values, the Proxy not deliver any
+# certificates that contain any of the values defined here.
+# These options are ignored if the "certificate_check" option is set to "0" 
+# as this disables certificate decoding.
+# Examples:
+# cert_issuer_accept "The Boeing Company"
+# cert_issuer_accept "C=US, ST=Washington"
+#   - or -
+# cert_issuer_reject "O=Operation Testing"
+# cert_issuer_reject "self signed"
+#[Default: NULL]
+
+# The CN (CommonName) value returned with the certificates may be in the 
+# form "Last, First".  Since this value will become part of the DN value 
+# returned to the LDAP client, OpenLDAP will have the comma replaced by 
+# "\2C" so that it is not mistaken for a comma delimiter in the DN string.
+# However, some LDAP clients aren't smart enough to understand what "\2C" 
+# means.  So we give the proxy admin the choice of having the CN rewritten 
+# to remove the comma.  That should catch "Last, First" names and rewrite 
+# them as "First Last".  If there is more than one comma in the CN, we 
+# don't know what kind of data is being represented in the CN and don't 
+# try to rewrite it.  Setting "normalize_common_name" to "yes" will tell
+# the LDAP Proxy to always rewrite CN values that contain a single comma.
+#[Default: no]
+normalize_common_name  no
+
+# The "enforce_keyusage" option allows you to limit which certificates the
+# LDAP Proxy returns based on the keyUsage flags set in the certificate.
+# The optional key usage certificate extension defines the intended purpose
+# of the key contained in the certificate.  The LDAP Proxy can enforce any
+# combination of the following nine key usage flags:
+#     digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment,
+#     keyAgreement, keyCertSign, cRLSign, encipherOnly, decipherOnly
+# Each enforce_keyusage flag must be specified on a separate line.
+# The key usage flags must be spelled as listed above but are case-insensitive.
+# For example, to require that certificates contain both keyEncipherment and
+# dataEncipherment flags before being delivered by the LDAP Proxy, use the
+# following config options:
+#     enforce_keyusage keyEncipherment
+#     enforce_keyusage dataEncipherment
+# When enforce_keyusage flags are specified, the LDAP Proxy will reject
+# any certificate that does not have *all* of the key usage flags specified
+# in the proxy config file with "enforce_keyusage" options.  Note that the
+# key usage is optional in X.509 certificates.  If you specify any
+# enforce_keyusage options and the certificate being examined does not
+# contain keyUsage flags, it will be rejected.  Also, if the
+# "certificate_check" option (see above) is set to "0", the certificate is
+# not read and no "enforce_keyusage" checking is done.
+#[Default: NULL]
+
+####################################################
+# The following options are used to fine tune data #
+# structures within the LDAP Proxy.  You probably  #
+# do not want to mess around with them.            #
+####################################################
+
+# "max_queries" determines the size of the in-memory pending_queries table.
+# This table keeps track of all the queries currently being processed by the
+# proxy.  It is used to detect and deal with proxy query infinite loops and
+# denial of service attacks.  Setting this too high wastes system resources.  
+# Setting it too low causes query rejections.  The default value should be
+# sufficient for typical proxy configurations, though in extreme cases busy
+# systems could need a larger table while a mostly idle system could use a
+# smaller table.  [Default: 64]
+max_queries 64
+
+# "max_results_cache" determines the size of an in-memory cache used for
+# short-term storage of certificate search results from completed LDAP SEARCH 
+# queries.  Microsoft's Outlook email client sends multiple LDAP commands 
+# for each single search.  The client does not actually accept the bulk of 
+# the search results until they are send in response to the last LDAP query
+# in the sequence.  So we are forced to save all search results until we can
+# determine if the next search request will meet the criteria.
+# If so, we must send the results again from the cache.
+# [Default: 128]
+max_results_cache 128
+
+# "max_results_life" determines how long (in seconds) a cached search result
+# will be held in the max_results_cache.  Each time the proxy receives a new
+# search query, it removes any cached search results that have been in the
+# max_results_cache longer than max_results_life seconds.
+# [Default: 30]
+max_results_life 30
+
+# "max_certificates" is the maximum number of certificates that the
+# LDAP Proxy will return per search query.
+# [Default: 128]
+max_certificates 128
+
+#--------------------------------------------------------------------------
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/libexec/certificate_server_list.txt openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/libexec/certificate_server_list.txt
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/libexec/certificate_server_list.txt	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/libexec/certificate_server_list.txt	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,57 @@
+#
+#  certificate_server_list     (for use with ldap_proxy version 4.x)
+#
+#       The LDAP Proxy service uses this file to look up
+#       LDAP certificate servers based on email domain names.
+#       Each server entry is listed as either seven or nine lines
+#       with each server entry separated by a blank line.
+#
+#       1) Email domain name (or "*" to match any email domain)
+#       2) LDAP server FQDN or IP address
+#       3) LDAP port number
+#       4) Base DN for certificate search
+#       5) Name of email address attribute (default "mail")
+#       6) Name of person name attribute (default "cn")
+#	7) Name of Certificate attribute (default "userCertificate")
+#       8) Bind DN (if required)
+#       9) Bind password (if required)
+#
+#       The first seven items are required.
+#       Comments have '#' in column one.
+#
+# The Boeing Company - Seattle - LDAP Proxy
+boeing.com
+dir.boeing.com
+389
+NULL
+mail
+cn
+userCertificate
+
+# Verisign LDAP server for all classes of certificates
+verisign.com
+directory.verisign.com
+389
+NULL
+mail
+cn
+userCertificate
+
+# ORC directory for ECA Class 3 certificates
+orc.com
+eca-ds.orc.com
+389
+O=U.S. Government,c=US
+mail
+cn
+userCertificate
+
+# Digital Signature Trust for ECA Class 3 certificates
+digsigtrust.com
+ldap.digsigtrust.com
+389
+NULL
+mail
+cn
+userCertificate
+
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/libexec/ldap_server_list.txt openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/libexec/ldap_server_list.txt
--- openldap-2.3.41-clean/servers/slapd/back-getcert/PROTO_FILES/libexec/ldap_server_list.txt	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/PROTO_FILES/libexec/ldap_server_list.txt	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,34 @@
+#
+#  ldap_server_list     (for use with ldap_proxy version 4.x)
+#
+#       The LDAP Proxy uses this file to look for LDAP servers
+#	that contain the "Attribute name" at the "Base DN" listed
+#	in this file.
+#       Each server entry is listed as either five or seven lines
+#       with each server entry separated by a blank line.
+#
+#       1) Base DN for search
+#       2) LDAP server FQDN or IP address
+#       3) LDAP port number
+#	4) Attribute to be searched for
+#		(example: certificateRevocationList)
+#		If specified as "all", then all attribute values
+#		found at the specified BaseDN are returned.
+#	5) Verification type (crl, cert, or none)
+#       6) Bind DN (if required)
+#       7) Bind password (if required)
+#
+#       The first five items are required.
+#       Comments have '#' in column one.
+#
+CN=The Boeing Company Class 2 Certificate Authority,OU=netscape,OU=certservers,O=Boeing,C=US
+ldapcrl.cs.boeing.com
+389
+certificateRevocationList;binary
+none
+
+CN=CA E:SECURE 1:PN,O=Zertifizierungsstelle E:Secure,c=DE
+ldap.crl.esecure.datev.de
+389
+certificateRevocationList
+none
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/bind.c openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/bind.c
--- openldap-2.3.41-clean/servers/slapd/back-getcert/bind.c	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/bind.c	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,78 @@
+/* bind.c   3.0   6/16/2004  */
+/*
+ *  This is the bind.c file for the getcert SLAPD backend.
+ *  Marc Amis  (marc.amis@boeing.com)
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "portable.h"
+#include "slap.h"
+#include "proto-getcert.h"
+#include "getcert.h"
+
+/*
+ *  All access to the getcert backend is granted regardless of the
+ *  type of bind requested by the client.  The only time this routine
+ *  is called is when the LDAP request comes with a BIND dn and password,
+ *  which we ignore.  The front end will reply to bind requests that
+ *  contain a null dn (null bind).
+ */
+int
+getcert_back_bind(Operation *op, SlapReply *rs)
+{
+    struct getcert_data  *getcert_shared;
+    getcert_shared = op->o_bd->be_private;
+
+    if (getcert_shared->debugging & DEBUG_GEN_HI) {
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Bind requested: \n", op->o_hdr->oh_connid);
+        syslog(LOG_DEBUG,
+            "[%lu][debug]      DN = %.*s\n",
+            op->o_hdr->oh_connid, op->o_req_dn.bv_len, op->o_req_dn.bv_val);
+	syslog(LOG_DEBUG,
+	    "[%lu][debug]     NDN = %.*s\n",
+	    op->o_hdr->oh_connid, op->o_req_ndn.bv_len, op->o_req_ndn.bv_val);
+	switch(op->orb_method) {
+	case LDAP_AUTH_NONE:
+		syslog(LOG_DEBUG,
+		    "[%lu][debug]    BIND = LDAP_AUTH_NONE\n",
+		    op->o_hdr->oh_connid); 
+		break;
+	case LDAP_AUTH_SIMPLE:
+		syslog(LOG_DEBUG,
+		    "[%lu][debug]    BIND = LDAP_AUTH_SIMPLE\n",
+		    op->o_hdr->oh_connid); 
+		break;
+	case LDAP_AUTH_SASL:
+		syslog(LOG_DEBUG,
+		    "[%lu][debug]    BIND = LDAP_AUTH_SASL\n",
+		    op->o_hdr->oh_connid); 
+		break;
+	case LDAP_AUTH_KRBV4:
+		syslog(LOG_DEBUG,
+		    "[%lu][debug]    BIND = LDAP_AUTH_KRBV4\n",
+		    op->o_hdr->oh_connid); 
+		break;
+	case LDAP_AUTH_KRBV41:
+		syslog(LOG_DEBUG,
+		    "[%lu][debug]    BIND = LDAP_AUTH_KRBV41\n",
+		    op->o_hdr->oh_connid); 
+		break;
+	case LDAP_AUTH_KRBV42:
+		syslog(LOG_DEBUG,
+		    "[%lu][debug]    BIND = LDAP_AUTH_KRBV42\n",
+		    op->o_hdr->oh_connid); 
+		break;
+	default:
+                syslog(LOG_DEBUG,
+                    "[%lu][debug]    BIND = unknown (%d)\n",
+                    op->o_hdr->oh_connid, op->orb_method); 
+		break;
+	}
+    }
+
+    /* Let 'em in. */
+    /* Front end will sent SUCCESS return code. */
+    return(0);
+}
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/close.c openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/close.c
--- openldap-2.3.41-clean/servers/slapd/back-getcert/close.c	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/close.c	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,124 @@
+/* close.c   4.1  12/08/2006  */
+/*
+ *  This is the close.c file for the getcert SLAPD backend.
+ *  Marc Amis  (marc.amis@boeing.com)
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "portable.h"
+#include "slap.h"
+#include "proto-getcert.h"
+#include "getcert.h"
+
+/*
+ *  Release all allocated memory
+ *  used by the LDAP Proxy.
+ */
+int
+getcert_back_close(be)
+    Backend *be;
+{
+    int  i;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    syslog(LOG_INFO, "Closing the LDAP Proxy.\n");
+
+    if ((getcert_shared->debugging & DEBUG_GEN_HI) || 
+	(getcert_shared->debugging & DEBUG_MEM))
+        syslog(LOG_DEBUG, "[debug] Freeing memory used by LDAP Proxy.\n");
+
+    if (getcert_shared->cert_server_list_filename != NULL) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[debug] %.800s\n",
+		"Releasing memory allocated for cert server list file name.");
+        free(getcert_shared->cert_server_list_filename);
+    }
+    if (getcert_shared->cert_serverlist != NULL) {
+        for (i = 0; getcert_shared->cert_serverlist[i] != NULL; i++) {
+	    if (getcert_shared->debugging & DEBUG_MEM)
+		syslog(LOG_DEBUG,
+		    "[debug] %.128s %d.\n",
+		    "Releasing memory allocated for cert server chain link", i);
+            free(getcert_shared->cert_serverlist[i]);
+	}
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+	        "[debug] Releasing memory allocated for cert server chain.\n");
+	free(getcert_shared->cert_serverlist);
+    }
+
+    if (getcert_shared->ldap_server_list_filename != NULL) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[debug] %.800s\n",
+		"Releasing memory allocated for LDAP server list file name.");
+        free(getcert_shared->ldap_server_list_filename);
+    }
+    if (getcert_shared->ldap_serverlist != NULL) {
+        for (i = 0; getcert_shared->ldap_serverlist[i] != NULL; i++) {
+	    if (getcert_shared->debugging & DEBUG_MEM)
+		syslog(LOG_DEBUG,
+		    "[debug] %.128s %d.\n",
+		    "Releasing memory allocated for LDAP server chain link", i);
+            free(getcert_shared->ldap_serverlist[i]);
+	}
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+	        "[debug] Releasing memory allocated for LDAP server chain.\n");
+	free(getcert_shared->ldap_serverlist);
+    }
+
+    if (getcert_shared->cert_issuer_filters != NULL) {
+	for (i = 0; i < (MAX_ISSUER_FILTERS - 1); i++) {
+    	    if (getcert_shared->cert_issuer_filters[i] != NULL) {
+		if (getcert_shared->debugging & DEBUG_MEM)
+            	    syslog(LOG_DEBUG,
+			"[debug] %.400s %.400s %d\n",
+			"Releasing memory allocated for",
+			"cert_issuer_filters list entry", i);
+		free(getcert_shared->cert_issuer_filters[i]);
+		getcert_shared->cert_issuer_filters[i] = NULL;
+	    }
+	}
+	if (getcert_shared->debugging & DEBUG_MEM)
+            syslog(LOG_DEBUG,
+                "[debug] %.800s\n",
+                "Releasing memory allocated for cert_issuer_filters list.");
+	if (getcert_shared->cert_issuer_filters != NULL) {
+	    free(getcert_shared->cert_issuer_filters);
+	    getcert_shared->cert_issuer_filters = NULL;
+	}
+    } 
+
+    if (getcert_shared->pending_queries != NULL) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[debug] %.800s\n",
+		"Releasing memory allocated for pending queries list.");
+        free(getcert_shared->pending_queries);
+    }
+    if (getcert_shared->last_search_results != NULL) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[debug] %.800s\n",
+		"Releasing memory allocated for last search results cache.");
+        free(getcert_shared->last_search_results);
+    }
+
+    if (getcert_shared->debugging & DEBUG_MEM)
+	syslog(LOG_DEBUG,
+	    "[debug] %.800s\n",
+	    "Releasing memory allocated for backend private data.");
+    free(be->be_private);
+    be->be_private = NULL;
+
+    if ((getcert_shared->debugging & DEBUG_GEN_HI) ||
+	(getcert_shared->debugging & DEBUG_MEM))
+	syslog(LOG_DEBUG, "[debug] All allocated memory freed.\n");
+
+    return(0);
+}
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/config.c openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/config.c
--- openldap-2.3.41-clean/servers/slapd/back-getcert/config.c	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/config.c	2008-03-25 12:18:48.000000000 -0400
@@ -0,0 +1,707 @@
+/* config.c   version 4.2    February 22, 2007  */
+/*
+ *  This is the config.c file for the getcert SLAPD backend.
+ *  Marc Amis	(marc.amis@boeing.com)
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "portable.h"
+#include "slap.h"
+#include "proto-getcert.h"
+#include "getcert.h"
+
+extern int  strcasecmp(const char *s1, const char *s2);
+int  add_cert_issuer_value(Backend  *be,
+			   const char  *cfg_filename,
+			   int   cfg_linenumber,
+			   char  **strvalue);
+
+/*
+ * Add a string entry to the end of the
+ * NULL terminated cert_issuer_filters list.
+ * Return 0 if successful.
+ * Return 1 on error.
+ */
+int
+add_cert_issuer_value(
+    Backend     *be,
+    const char	*cfg_filename,
+    int		cfg_linenumber,
+    char	**strvalue
+)
+{
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+    int  i, len, stringindex;
+
+    if (getcert_shared->cert_issuer_filters == NULL) {
+	/* Initialize filter list */
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+	        "[debug] Allocating %d bytes of memory for %.64s\n",
+		MAX_ISSUER_FILTERS * sizeof(char *),
+		"cert_issuer filter list.");
+	getcert_shared->cert_issuer_filters =
+		malloc(MAX_ISSUER_FILTERS * sizeof(char *));
+	if (getcert_shared->cert_issuer_filters == NULL) {
+	    fprintf(stderr,
+	        "%.256s: line %d: Cannot allocate memory for %.64s\n",
+		cfg_filename, cfg_linenumber, "cert_issuer filter list.");
+	    syslog(LOG_INFO,
+		"[error] %.256s: line %d: %.64s %.64s\n",
+		cfg_filename, cfg_linenumber, "Cannot allocate memory for",
+		"cert_issuer filter list.");
+	    return(1);
+	}
+	for (i = 0; i < MAX_ISSUER_FILTERS; i++)
+	    getcert_shared->cert_issuer_filters[i] = NULL;
+    }
+    /* Add this string to the filter list. */
+    for (stringindex = 0;
+	 stringindex < (MAX_ISSUER_FILTERS - 1);
+	 stringindex++) {
+	if (getcert_shared->cert_issuer_filters[stringindex] == NULL) {
+	    getcert_shared->cert_issuer_filters[stringindex] =
+		    strdup(strvalue[1]);
+	    getcert_shared->cert_issuer_filters[stringindex + 1] = NULL;
+	    if (getcert_shared->debugging & DEBUG_MEM)
+	        syslog(LOG_DEBUG,
+		   "[debug] Allocated %d bytes of memory for %.64s %d\n",
+		   strlen(getcert_shared->cert_issuer_filters[stringindex]) + 1,
+		   "cert_issuer filter value", stringindex);
+	    break;
+	}
+    }
+    if (stringindex >= (MAX_ISSUER_FILTERS - 1)) {
+	fprintf(stderr,
+	    "%.256s: line %d: Too many cert_issuer filter entries.\n",
+	    cfg_filename, cfg_linenumber);
+	fprintf(stderr,
+	    "%.256s: line %d: Maximum entries allowed is %d.\n",
+	    cfg_filename, cfg_linenumber, MAX_ISSUER_FILTERS - 1);
+	syslog(LOG_INFO,
+	    "[error] %.256s: line %d: %.256s\n",
+	    cfg_filename, cfg_linenumber,
+	    "Too many cert_issuer filter entries.");
+	syslog(LOG_INFO,
+	    "[error] %.256s: line %d: Maximum entries allowed is %d.\n",
+	    cfg_filename, cfg_linenumber, MAX_ISSUER_FILTERS - 1);
+	return(1);
+    }
+    /* Convert string value to lower case for case-insensitive compares. */
+    len = strlen(getcert_shared->cert_issuer_filters[stringindex]);
+    for (i = 0; i < len; i++)
+	getcert_shared->cert_issuer_filters[stringindex][i] =
+		tolower(getcert_shared->cert_issuer_filters[stringindex][i]);
+    return(0);
+} /* add_cert_issuer_value */
+
+/*
+ * getcert configuration
+ *
+ * Process the following configuration variables from slapd.conf:
+ *	cert_issuer_accept
+ *	cert_issuer_reject
+ *	certificate_check
+ *	certificate_serverlist
+ *	certificatetype
+ *	debugging
+ *      enforce_keyusage
+ *	ldap_serverlist
+ *	limit_return_codes
+ *	normalize_common_name
+ *	search_all_servers
+ *	search_timeout
+ *	max_certificates
+ *	max_queries	
+ *	max_results_cache
+ *	max_results_life
+ *	getcert_use_pathfinder
+ *      getcert_pf_policy
+ */
+int
+getcert_back_config(
+    Backend     *be,
+    const char	*fname,
+    int         lineno,
+    int         argc,
+    char        **argv
+)
+{
+    int   i, cert_type, len, rc;
+
+    /* Get the private data. */
+    struct getcert_data  *getcert_shared;
+    getcert_shared = be->be_private;
+    if (getcert_shared == NULL) {
+	syslog(LOG_INFO, 
+	    "[error] No memory has been allocated for this program.\n");
+	return(1);
+    }
+
+    /*
+     * Looking at a config file entry.
+     */
+    if (getcert_shared->debugging & DEBUG_NONE)
+	syslog(LOG_DEBUG,
+	    "[debug] argc is %d and argv[0] is %.990s\n", argc, argv[0]);
+
+    if (strcasecmp(argv[0], "debugging") == 0) {
+	/*
+	 * The "debugging" config file entry.
+	 * There are several debugging levels represented by bit numbers.
+	 */
+	i = atoi(argv[1]);
+	if (i > DEBUG_NONE)
+	    syslog(LOG_DEBUG,
+	        "Found debugging level of %d in slapd.conf\n", i);
+	if ((i < 0) || (i > 32)) {
+	    syslog(LOG_DEBUG,
+		"[error] %.256s: line %d: %.128s\n",
+		fname, lineno, "debugging level must be in the range 0-31.");
+	} else {
+	    getcert_shared->debugging = i;
+	}
+    } else 
+    if (strcasecmp(argv[0], "certificate_serverlist") == 0) {
+        /*
+         * The "certificate_serverlist" config file entry.
+         * It documents the file containing the list of 
+         * LDAP servers getcert can query for certificates.
+         */
+	if (argc < 2) {
+	    fprintf(stderr,
+		"%.970s: line %d: No certificate server list file specified.\n",
+		fname, lineno);
+	    syslog(LOG_INFO,
+		"[error] %.970s: line %d: %.128s\n",
+		fname, lineno, "No certificate server list file specified.");
+	    return(1);
+	} else {
+    	    if (getcert_shared->debugging & DEBUG_GEN_HI) {
+		syslog(LOG_DEBUG, "[debug] argv[0] is %.1000s\n", argv[0]);
+		syslog(LOG_DEBUG, "[debug] argv[1] is %.1000s\n", argv[1]);
+    	    }
+	    len = strlen(argv[1]);
+	    if (len >= MAX_FILENAME) {
+		fprintf(stderr,
+		    "%.64s: line %d: Server list name too long: %.900s\n",
+		    fname, lineno, argv[1]);
+		syslog(LOG_INFO,
+		  "[error] %.64s: line %d: Server list name too long: %.900s\n",
+		  fname, lineno, argv[1]);
+		return(1);
+	    } 
+	    if (strncasecmp(argv[1], "null", 4) == 0) {
+		getcert_shared->cert_server_list_filename = NULL;
+		if (getcert_shared->debugging > DEBUG_NONE)
+		    syslog(LOG_DEBUG,
+		        "No certificate server list name defined in slapd.conf.\n");
+	    } else {
+		getcert_shared->cert_server_list_filename = strdup(argv[1]);
+		if (getcert_shared->debugging > DEBUG_NONE) {
+	            syslog(LOG_DEBUG,
+	                "Found certificate server list file name in slapd.conf:\n");
+	            syslog(LOG_DEBUG, "    %.900s\n",
+		        getcert_shared->cert_server_list_filename);
+		}
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+			"[debug] Allocated %d bytes of memory for %.64s\n",
+			strlen(getcert_shared->cert_server_list_filename) + 1,
+			"certificate server list file name.");
+	    }
+	}
+    } else 
+    if (strcasecmp(argv[0], "ldap_serverlist") == 0) {
+        /*
+         * The "ldap_serverlist" config file entry.
+         * It documents the file containing the list of LDAP
+         * servers getcert can query for various attributes.
+         */
+	if (argc < 2) {
+	    getcert_shared->ldap_server_list_filename[0] = '\0';
+	} else {
+    	    if (getcert_shared->debugging & DEBUG_GEN_HI) {
+		syslog(LOG_DEBUG, "[debug] argv[0] is %.1000s\n", argv[0]);
+		syslog(LOG_DEBUG, "[debug] argv[1] is %.1000s\n", argv[1]);
+    	    }
+	    len = strlen(argv[1]);
+	    if (len >= MAX_FILENAME) {
+		fprintf(stderr,
+		    "%.64s: line %d: LDAP server list name too long: %.900s\n",
+		    fname, lineno, argv[1]);
+		syslog(LOG_INFO,
+		    "[error] %.64s: line %d: %.64s %.900s\n",
+		    fname, lineno, "LDAP server list name too long:", argv[1]);
+		return(1);
+	    }
+	    if (strncasecmp(argv[1], "null", 4) == 0) {
+		getcert_shared->ldap_server_list_filename = NULL;
+		if (getcert_shared->debugging > DEBUG_NONE)
+		    syslog(LOG_DEBUG,
+		        "No LDAP server list name defined in slapd.conf.\n");
+	    } else {
+		getcert_shared->ldap_server_list_filename = strdup(argv[1]);
+		if (getcert_shared->debugging > DEBUG_NONE) {
+	            syslog(LOG_DEBUG,
+	                "Found LDAP server list file name in slapd.conf:\n");
+	            syslog(LOG_DEBUG, "    %.900s\n",
+		        getcert_shared->ldap_server_list_filename);
+		}
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+			"[debug] Allocated %d bytes of memory for %.64s\n",
+			strlen(getcert_shared->cert_server_list_filename) + 1,
+			"LDAP server list file name.");
+	    }
+	}
+    } else 
+    if (strcasecmp(argv[0], "certificatetype") == 0) {
+        /*
+	 * The "certificatetype" config file entry.
+	 * If set it specifies the version of X.509 certificates
+	 * we are allowed to return:
+	 *     0 = all versions
+	 *     1 = return version 1 certs only
+	 *     2 = return version 2 certs only
+	 *     3 = return version 3 certs only
+	 */
+	cert_type = atoi(argv[1]);
+	if (getcert_shared->debugging > DEBUG_NONE)
+	    syslog(LOG_DEBUG,
+	        "Found certificatetype value of %d in slapd.conf\n", cert_type);
+	getcert_shared->certificate_type = cert_type;
+    } else 
+    if (strcasecmp(argv[0], "search_timeout") == 0) {
+	/*
+	 * The "search_timeout" config file entry.
+	 * Timeout in seconds for ldap_search_ext_s().
+	 */
+	getcert_shared->search_timeout = atoi(argv[1]);
+	if (getcert_shared->search_timeout < 0) {  
+	    fprintf(stderr,
+		"%.256s: line %d: Invalid value for search timeout option.\n",
+		fname, lineno);
+	    syslog(LOG_INFO,
+		"[error] %.256s: line %d: %.64s\n",
+		fname, lineno, "Invalid value for search timeout option.");
+	    return(1);
+	} else {
+	    if (getcert_shared->debugging > DEBUG_NONE)
+	        syslog(LOG_DEBUG,
+		    "Found search_timeout value of %d seconds in slapd.conf\n",
+		    getcert_shared->search_timeout);
+	}
+    } else
+    if (strcasecmp(argv[0], "search_all_servers") == 0) {
+	/*
+	 * The "search_all_servers" config file entry.
+	 * Value is a case-insensitive boolean "yes" or "no".
+	 * Limits LDAP return codes to just 0 or 1.
+	 */
+	if (strcasecmp(argv[1], "no") == 0)
+	    getcert_shared->search_all_servers = FALSE;
+	else 
+	if (strcasecmp(argv[1], "yes") == 0)
+	    getcert_shared->search_all_servers = TRUE;
+	else
+	if (strcasecmp(argv[1], "false") == 0)
+	    getcert_shared->search_all_servers = FALSE;
+	else 
+	if (strcasecmp(argv[1], "true") == 0)
+	    getcert_shared->search_all_servers = TRUE;
+	else {
+	    syslog(LOG_INFO,
+		"[error] %.256s: line %d: %.64s %.64s\n", fname, lineno, 
+		"limit_return_codes must be \"yes\", \"no\", \"true\" or \"false\".",
+		"Using default.");
+	}
+	if (getcert_shared->debugging > DEBUG_NONE) {
+	    if (getcert_shared->search_all_servers) 
+	        syslog(LOG_DEBUG,
+	            "%.64s Value set to TRUE.\n",
+	            "Found search_all_servers value in slapd.conf.");
+	    else
+	        syslog(LOG_DEBUG,
+	            "%.64s Value set to FALSE.\n",
+	            "Found search_all_servers value in slapd.conf.");
+	}
+    } else 
+#ifdef HAVE_PATHFINDER
+    if (strcasecmp(argv[0], "getcert_pathfinder") == 0) {
+	/*
+	 * The "use_pathfinder" config file entry.
+	 * Value is a case-insensitive boolean "yes" or "no".
+	 */
+	if (strcasecmp(argv[1], "no") == 0)
+	    getcert_shared->use_pathfinder = FALSE;
+	else 
+	if (strcasecmp(argv[1], "yes") == 0)
+	    getcert_shared->use_pathfinder = TRUE;
+	else
+	if (strcasecmp(argv[1], "false") == 0)
+	    getcert_shared->use_pathfinder = FALSE;
+	else 
+	if (strcasecmp(argv[1], "true") == 0)
+	    getcert_shared->use_pathfinder = TRUE;
+        else
+        if (strcasecmp(argv[1], "off") == 0)
+            getcert_shared->use_pathfinder = FALSE;
+        else
+        if (strcasecmp(argv[1], "on") == 0)
+            getcert_shared->use_pathfinder = TRUE;
+	else {
+	    syslog(LOG_INFO,
+		"[error] %.256s: line %d: %.64s %.64s\n", fname, lineno, 
+		"getcert_pathfinder must be \"yes\", \"no\", \"true\", \"false\", \"on\", or \"off\".",
+		"Using default.");
+	}
+	if (getcert_shared->debugging > DEBUG_NONE) {
+	    if (getcert_shared->use_pathfinder) 
+	        syslog(LOG_DEBUG,
+	            "%.64s Value set to TRUE.\n",
+	            "Found getcert_pathfinder value in slapd.conf.");
+	    else
+	        syslog(LOG_DEBUG,
+	            "%.64s Value set to FALSE.\n",
+	            "Found getcert_pathfinder value in slapd.conf.");
+	}
+    } else 
+    if (strcasecmp(argv[0], "getcert_pf_policy") == 0) {
+        /*
+         * The "getcert_pf_policy" config file entry.
+         * This OID (represented just as a string) is the target policy
+         * that pathfinder uses when performing path validation on a
+         * certificate.  If unspecified, anyPolicy is used.
+         */
+        if (argc < 2 && getcert_shared->pf_policy) {
+	    getcert_shared->pf_policy[0] = '\0';
+	} else {
+    	    if (getcert_shared->debugging & DEBUG_GEN_HI) {
+		syslog(LOG_DEBUG, "[debug] argv[0] is %.1000s\n", argv[0]);
+		syslog(LOG_DEBUG, "[debug] argv[1] is %.1000s\n", argv[1]);
+    	    }
+	    if (strncasecmp(argv[1], "null", 4) == 0) {
+		getcert_shared->pf_policy = NULL;
+		if (getcert_shared->debugging > DEBUG_NONE)
+		    syslog(LOG_DEBUG,
+		        "No pathfinder policy defined in slapd.conf.\n");
+	    } else {
+		getcert_shared->pf_policy = strdup(argv[1]);
+		if (getcert_shared->debugging > DEBUG_NONE) {
+	            syslog(LOG_DEBUG,
+	                "Found pathfinder policy in slapd.conf:\n");
+	            syslog(LOG_DEBUG, "    %.900s\n",
+		        getcert_shared->pf_policy);
+		}
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+			"[debug] Allocated %d bytes of memory for %.64s\n",
+			strlen(getcert_shared->pf_policy) + 1,
+			"pathfinder policy string.");
+	    }
+	}
+    } else
+#endif
+    if (strcasecmp(argv[0], "cert_issuer_accept") == 0) {
+	/*
+	 * The "cert_issuer_accept" config file entry.
+	 * Add each accept string value to the cert_issuer_filters
+	 * list and convert it to lower-case.
+	 */
+	if (getcert_shared->debugging > DEBUG_NONE)
+	    syslog(LOG_DEBUG,
+	        "Found cert_issuer_accept option slapd.conf\n");
+        if (argc < 2) {
+	    /* No string value configured. */
+	    fprintf(stderr,
+	       "%.256s: line %d: No value for cert_issuer_accept option.\n",
+	       fname, lineno);
+	    syslog(LOG_INFO,
+		"[error] %.256s: line %d: %.64s\n",
+		fname, lineno, "No value for cert_issuer_accept option.");
+	    return(1);
+	}
+	if (getcert_shared->issuer_filter_type == reject_cert) {
+	    /* Cannot use both accept and reject options. */
+	    fprintf(stderr,
+		"%.256s: line %d: Cannot use both accept and reject options.",
+		fname, lineno);
+	    syslog(LOG_INFO,
+                "[error] %.256s: line %d: %.64s\n",
+		fname, lineno, "Cannot use both accept and reject options.");
+	    return(1);
+	}
+	getcert_shared->issuer_filter_type = accept_cert;
+	rc = add_cert_issuer_value(be, fname, lineno, argv);
+	if (rc != 0)
+	    return(1);
+    } else
+    if (strcasecmp(argv[0], "cert_issuer_reject") == 0) {
+	/*
+	 * The "cert_issuer_reject" config file entry.
+	 * Add each accept string value to an array 
+	 * after converting to lower-case.
+	 */
+	if (getcert_shared->debugging > DEBUG_NONE)
+	    syslog(LOG_DEBUG,
+	        "Found cert_issuer_reject option slapd.conf\n");
+        if (argc < 2) {
+	    /* No string value configured. */
+	    fprintf(stderr,
+	       "%.256s: line %d: No value for cert_issuer_reject option.\n",
+	       fname, lineno);
+	    syslog(LOG_INFO,
+		"[error] %.256s: line %d: %.64s\n",
+		fname, lineno, "No value for cert_issuer_reject option.");
+	    return(1);
+	}
+	if (getcert_shared->issuer_filter_type == accept_cert) {
+	    /* Cannot use both accept and reject options. */
+	    fprintf(stderr,
+		"%.256s: line %d: Cannot use both accept and reject options.",
+		fname, lineno);
+	    syslog(LOG_INFO,
+                "[error] %.256s: line %d: %.64s\n",
+		fname, lineno, "Cannot use both accept and reject options.");
+	    return(1);
+	}
+	getcert_shared->issuer_filter_type = reject_cert;
+	rc = add_cert_issuer_value(be, fname, lineno, argv);
+	if (rc != 0)
+	    return(1);
+    } else
+    if (strcasecmp(argv[0], "max_queries") == 0) {
+	/*
+	 * The "max_queries" config file entry.
+	 * The maximum number of queries we can be processing
+	 * before we start rejecting new query requests.
+	 */
+	getcert_shared->MAX_QUERIES = atoi(argv[1]);
+	if (getcert_shared->MAX_QUERIES < MIN_TABLE_SIZE) {
+	    syslog(LOG_INFO,
+		"[error] %.256s: line %d: max_queries must be at least %d\n",
+		fname, lineno, MIN_TABLE_SIZE);
+	    return(1);
+	} 
+	if (getcert_shared->debugging > DEBUG_NONE)
+	    syslog(LOG_DEBUG,
+	        "Found max_queries value of %d in slapd.conf\n",
+	        getcert_shared->MAX_QUERIES);
+    } else
+    if (strcasecmp(argv[0], "max_results_cache") == 0) {
+	/*
+	 * The "max_results_cache" config file entry.
+	 * The maximum number of unexpired search results we can save.
+	 * Saved results expire after MAX_RESULTS_LIFE seconds. 
+	 */
+	getcert_shared->MAX_RESULTS_CACHE = atoi(argv[1]);
+	if (getcert_shared->MAX_RESULTS_CACHE < MIN_TABLE_SIZE) {
+	    syslog(LOG_INFO,
+		"[error] %.256s: line %d: %.64s %d\n",
+		fname, lineno, "max_results_cache must be at least",
+		MIN_TABLE_SIZE);
+	    return(1);
+	} 
+	if (getcert_shared->debugging > DEBUG_NONE)
+	    syslog(LOG_DEBUG,
+	        "Found max_results_cache value of %d in slapd.conf\n",
+	        getcert_shared->MAX_RESULTS_CACHE);
+    } else
+    if (strcasecmp(argv[0], "max_results_life") == 0) {
+	/*
+	 * The "max_results_life" config file entry.
+	 * Number of seconds to keep cached search results
+	 * in the max_results_queue.
+	 */
+	getcert_shared->MAX_RESULTS_LIFE = atoi(argv[1]);
+        if (getcert_shared->MAX_RESULTS_LIFE < 1) {
+            syslog(LOG_INFO,
+                "[error] %.256s: line %d: %.64s\n",
+                fname, lineno, "max_results_life must greater than zero.");
+            return(1);
+        }
+	if (getcert_shared->debugging > DEBUG_NONE)
+            syslog(LOG_DEBUG,
+                "Found max_results_life value of %d in slapd.conf\n",
+                getcert_shared->MAX_RESULTS_LIFE);
+    } else
+    if (strcasecmp(argv[0], "max_certificates") == 0) {
+        /*
+	 * The "max_certificates" config file entry.
+	 * The maximum number of certificates that can 
+	 * be returned per query.
+	 */
+	getcert_shared->MAX_CERTIFICATES = atoi(argv[1]);
+	if (getcert_shared->MAX_CERTIFICATES < 1) {
+	    syslog(LOG_INFO,
+		"[error] %.256s: line %d: %.64s\n",
+		fname, lineno, "max_certificates must greater than zero.");
+	    return(1);
+        }
+	if (getcert_shared->debugging > DEBUG_NONE)
+            syslog(LOG_DEBUG,
+                "Found max_certificates value of %d in slapd.conf\n",
+	        getcert_shared->MAX_CERTIFICATES);
+    } else
+    if (strcasecmp(argv[0], "limit_return_codes") == 0) {
+	/*
+	 * The "limit_return_codes" config file entry.
+	 * Value is a case-insensitive boolean "yes" or "no".
+	 * Limits LDAP return codes to just 0 or 1.
+	 */
+	if (strcasecmp(argv[1], "no") == 0)
+	    getcert_shared->limit_return_codes = FALSE;
+	else 
+	if (strcasecmp(argv[1], "yes") == 0)
+	    getcert_shared->limit_return_codes = TRUE;
+	else
+	if (strcasecmp(argv[1], "false") == 0)
+	    getcert_shared->limit_return_codes = FALSE;
+	else 
+	if (strcasecmp(argv[1], "true") == 0)
+	    getcert_shared->limit_return_codes = TRUE;
+	else {
+	    syslog(LOG_INFO,
+		"[error] %.256s: line %d: %.64s %.64s\n", fname, lineno, 
+		"limit_return_codes must be \"yes\", \"no\", \"true\" or \"false\".",
+		"Using default.");
+	}
+	if (getcert_shared->debugging > DEBUG_NONE) {
+	    if (getcert_shared->limit_return_codes) 
+	        syslog(LOG_DEBUG,
+	            "%.64s Value set to TRUE.\n",
+	            "Found limit_return_codes value in slapd.conf.");
+	    else
+	        syslog(LOG_DEBUG,
+	            "%.64s Value set to FALSE.\n",
+	            "Found limit_return_codes value in slapd.conf.");
+	}
+    } else
+    if (strcasecmp(argv[0], "normalize_common_name") == 0) {
+	/*
+	 * The "normalize_common_name" config file entry.
+	 * Value is a case-insensitive boolean "yes" or "no".
+	 * If set to yes, the CN (CommonName) value returned
+	 * from the LDAP Server will be rewritten to remove
+	 * embedded commas.  These commas are translated to "\2C"
+	 * by LDAP to distinguish them from DN delimiters.  These
+	 * will cause names supplied as "Last\2C First" to be
+	 * rewritten as "First Last" in the CN value which forms
+	 * part of the DN string returned to the LDAP client.
+	 */
+	if (strcasecmp(argv[1], "no") == 0)
+	    getcert_shared->normalize_common_name = FALSE;
+	else 
+	if (strcasecmp(argv[1], "yes") == 0)
+	    getcert_shared->normalize_common_name = TRUE;
+	else {
+	    syslog(LOG_INFO,
+		"[error] %.256s: line %d: %.64s %.64s\n", fname, lineno, 
+		"normalize_common_name must be \"true\" or \"false\".",
+		"Using default.");
+	}
+	if (getcert_shared->debugging > DEBUG_NONE) {
+	    if (getcert_shared->normalize_common_name) 
+	        syslog(LOG_DEBUG,
+	            "%.64s Value set to TRUE.\n",
+	            "Found normalize_common_name value in slapd.conf.");
+	    else
+	        syslog(LOG_DEBUG,
+	            "%.64s Value set to FALSE.\n",
+	            "Found normalize_common_name value in slapd.conf.");
+	    }
+    } else
+    if (strcasecmp(argv[0], "certificate_check") == 0) {
+	/*
+	 * The "certificate_check" config file entry.
+         * This determines how closely the search routine will 
+	 * look at the certificate to verify format & usability.
+	 */
+	getcert_shared->certificate_check = atoi(argv[1]);
+	if ((getcert_shared->certificate_check < 0) || 
+	    (getcert_shared->certificate_check > 2)) {
+	    fprintf(stderr,
+	       "%.256s: line %d: Invalid value for certificate check option.\n",
+		fname, lineno);
+	    syslog(LOG_INFO,
+	       "[error] %.256s: line %d: %.128s\n",
+		fname, lineno, "Invalid value for certificate check option.");
+	    return(1);
+	}
+	if (getcert_shared->debugging > DEBUG_NONE)
+	    syslog(LOG_DEBUG,
+	        "Found certificate check value of %d in slapd.conf\n",
+	        getcert_shared->certificate_check);
+    } else
+    if (strcasecmp(argv[0], "enforce_keyusage") == 0) {
+	/*
+	 * The "enforce_keyusage" config file entry.
+	 * Each occurrence of this option will define a specific
+	 * keyUsage flag that certificates must contain before
+	 * the LDAP Proxy will deliver the certificate.
+	 */
+	if (argc < 2) {
+	    fprintf(stderr,
+		"%.970s: line %d: No keyUsage flag specified %.128s\n",
+		fname, lineno, "with enforce_keyusage option.");
+	    syslog(LOG_INFO,
+		"[error] %.970s: line %d: No keyUsage flag specified %.128s\n",
+		fname, lineno, "with enforce_keyusage option.");
+	    return(1);
+	} else {
+    	    if (getcert_shared->debugging & DEBUG_GEN_LO) {
+		syslog(LOG_DEBUG, "[debug] argv[0] is %.1000s\n", argv[0]);
+		syslog(LOG_DEBUG, "[debug] argv[1] is %.1000s\n", argv[1]);
+    	    }
+	    len = strlen(argv[1]);
+	    if (len >= MAX_STRING) {
+		fprintf(stderr,
+		    "%.64s: line %d: keyUsage flag name too long: %.900s\n",
+		    fname, lineno, argv[1]);
+		syslog(LOG_INFO,
+		"[error] %.64s: line %d: keyUsage flag name too long: %.900s\n",
+		    fname, lineno, argv[1]);
+		return(1);
+	    } 
+	    if (strncasecmp(argv[1], "null", 4) != 0) {
+		if (strncasecmp(argv[1], "digitalsignature", 16) == 0)
+		    getcert_shared->enforce_digitalSignature = TRUE;
+		else if (strncasecmp(argv[1], "nonrepudiation", 14) == 0)
+		    getcert_shared->enforce_nonRepudiation = TRUE;
+		else if (strncasecmp(argv[1], "keyencipherment", 15) == 0)
+		    getcert_shared->enforce_keyEncipherment = TRUE;
+		else if (strncasecmp(argv[1], "dataencipherment", 16) == 0)
+		    getcert_shared->enforce_dataEncipherment = TRUE;
+		else if (strncasecmp(argv[1], "keyagreement", 12) == 0)
+		    getcert_shared->enforce_keyAgreement = TRUE;
+		else if (strncasecmp(argv[1], "keycertSign", 11) == 0)
+		    getcert_shared->enforce_keyCertSign = TRUE;
+		else if (strncasecmp(argv[1], "crlsign", 7) == 0)
+		    getcert_shared->enforce_cRLSign = TRUE;
+		else if (strncasecmp(argv[1], "encipheronly", 12) == 0)
+		    getcert_shared->enforce_encipherOnly = TRUE;
+	    }
+	    if (getcert_shared->debugging > DEBUG_NONE)
+	        syslog(LOG_DEBUG,
+	            "Found enforce_keyusage value of %s in slapd.conf\n", argv[1]);
+	}
+    } else {
+	syslog(LOG_INFO,
+             "[error] %.64s: line %d: unknown directive \"%.850s\""
+             " in GETCERT backend definition (ignored)\n",
+             fname, lineno, argv[0]);
+        return(0);
+    }
+
+    if (getcert_shared->debugging & DEBUG_GEN_LO)
+	syslog(LOG_DEBUG,
+	    "[debug] Configuration option %.900s has been processed.\n",
+	    argv[0]);
+
+    return(0);
+}
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/getcert.h openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/getcert.h
--- openldap-2.3.41-clean/servers/slapd/back-getcert/getcert.h	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/getcert.h	2008-03-25 12:18:48.000000000 -0400
@@ -0,0 +1,471 @@
+/*  getcert.h      July 12, 2007  */
+static char ldap_proxy_version[] = "4.2";
+/*
+ *  Data structures and definitions for LDAP Proxy getcert backend process.
+ *	Marc Amis      marc.amis@boeing.com
+ */
+
+enum boolean {FALSE, TRUE};
+enum ifilter_types {none, reject_cert, accept_cert};
+enum verify_types {NONE, CERT, CRL};
+typedef int Bool;
+
+#define TRUE  1
+#define FALSE 0
+
+#define BLANK ' '
+#define TAB   '\t'
+
+#define MIN_ASCII 33
+#define MAX_ASCII 126
+#define MAX_ATTRIBUTE_NAME 128
+#define MAX_ATTRIBUTES 64
+#define MAX_CERTIFICATE_SIZE 16384
+#define MAX_CONTENT 4096
+#define MAX_DN_LENGTH 256
+#define MAX_EMAIL_LENGTH 256
+#define MAX_FILENAME 256
+#define MIN_FILTER_LEN 7
+#define MAX_FILTER_LEN 512
+#define MAX_IP_LENGTH 32
+#define MAX_ISSUER_FILTERS 64
+#define MAX_LDAP_SERVERS 1024
+#define MAX_LINE 256
+#define MAX_LOG_REC 1024
+#define MAX_STRING 128
+#define MIN_TABLE_SIZE 10
+#define MAX_TYPE_LEN 32
+#define BUFF_BLOCK_SIZE 8192
+
+/*
+ * User selectable debugging message levels for the back-end process.
+ * Used with the "debugging" option in the slapd configuration file.
+ */
+#define DEBUG_NONE   0x00       /* No debugging statements.                */
+#define DEBUG_GEN_HI 0x01	/* General program flow - High level.      */
+#define DEBUG_GEN_LO 0x02	/* General program flow - Low level.       */
+#define DEBUG_MEM    0x04	/* Dynamic memory allocation/deallocation. */
+#define DEBUG_DATA   0x08	/* Data parsing and conversion routines.   */
+
+static char  generic_filter[] = "(objectClass=*)";
+FILE  *infile;
+char  linebuff[MAX_LINE];
+int   linenum, server_count;
+
+/*
+ * The cert_server structure defines a single certificate server.
+ * Used to create the in-memory copy of the certificate_server_list file.
+ */
+struct cert_server {
+    char  email_domain[MAX_STRING];
+    char  server_name[MAX_STRING];
+    int   port;
+    char  base_dn[MAX_DN_LENGTH];
+    char  mail_attr[MAX_ATTRIBUTE_NAME];
+    char  personname_attr[MAX_ATTRIBUTE_NAME];
+    char  cert_attr[MAX_ATTRIBUTE_NAME];
+    char  bind_dn[MAX_DN_LENGTH];
+    char  bind_password[MAX_STRING];
+} **cert_server_list, cert_server_buffer;
+
+/*
+ * The ldap_server structure defines a single LDAP server.
+ * Used to create the in-memory copy of the ldap_server_list file.
+ */
+struct ldap_server {
+    char  ldap_dn[MAX_DN_LENGTH];
+    char  server_name[MAX_STRING];
+    int   port;
+    char  ldap_attr[MAX_ATTRIBUTE_NAME];
+    enum verify_types verification;
+    char  bind_dn[MAX_DN_LENGTH];
+    char  bind_password[MAX_STRING];
+} **ldap_server_list, ldap_server_buffer;
+
+/*
+ * A list of all pending search queries is maintained in order to spot 
+ * query loops.  If an additional query is received from the same client 
+ * for the same email address (certificate search) or search base DN 
+ * (LDAP search), and an existing query is still pending, reject the new
+ * query as a possible proxy loop.
+ */
+struct active_query {
+    long int   connection_id;
+    char  client_ip_addr[MAX_IP_LENGTH];
+    char  query_filter[MAX_EMAIL_LENGTH];
+    char  base_dn[MAX_DN_LENGTH];
+}; 
+
+/*
+ * This structure is used to cache search query results.  We do this for
+ * two reasons:
+ *     First, some LDAP clients use multiple search queries to fetch a
+ * single piece of data.  However, not all the queries in the sequence have
+ * the information we need to do the search.  Also, these clients ignore the
+ * results we send back until they have send the last query in the sequence.
+ * So we cache the results and keep resending them on subsequent queries in
+ * the sequence.
+ *     Second, we can respond to identical queries from the same client with
+ * cached data rather than doing the LDAP search again, at least for the
+ * sort period of time (MAX_RESULTS_LIFE) the data remains in the cache.
+ */
+struct search_result {
+    char    client_ip_addr[MAX_IP_LENGTH];  /* Client IP address */
+    char    unique_ndn[MAX_DN_LENGTH];      /* DN returned with results */
+    char    filterstr[MAX_FILTER_LEN];      /* Search filter */
+    char    *search_attrs[MAX_ATTRIBUTES];  /* Array of search attr names */
+    time_t  timestamp;			    /* Time results returned */
+    char    *ldif_ptr;                      /* LDIF of returned results */
+};
+
+/*
+ * Private structure for storing global data that is available for use
+ * by all backend threads via the private "be" structure pointer.
+ * Initial values are set from the slapd configuration file.
+ */
+struct getcert_data {
+    int    debugging;
+    int    certificate_type;
+    int    certificate_check;
+    int    search_timeout;
+    Bool   search_all_servers;
+    Bool   limit_return_codes;
+    Bool   normalize_common_name;
+#ifdef HAVE_PATHFINDER
+    Bool   use_pathfinder;
+    char   *pf_policy;
+#endif
+
+    /* In-memory copy of the certificate_server_list file. */
+    char   *cert_server_list_filename;
+    struct cert_server  **cert_serverlist;
+    /* In-memory copy of the ldap_server_list file. */
+    char   *ldap_server_list_filename;
+    struct ldap_server  **ldap_serverlist;
+
+    /* Null terminated array of string values.             */
+    /* Accept or reject certificates if the certificate's  */
+    /* issuer section contains any of these string values. */
+    enum ifilter_types issuer_filter_type;
+    char   **cert_issuer_filters;
+
+    /* keyUsage flags specified via "enforce_keyusage" options. */
+    /* Reject certs that have a keyUsage section but do not     */
+    /* have *all* of the keyUsage flags specified with          */
+    /* "enforce_keyusage" options in the slapd config file.     */
+    Bool    enforce_digitalSignature;
+    Bool    enforce_nonRepudiation;
+    Bool    enforce_keyEncipherment;
+    Bool    enforce_dataEncipherment;
+    Bool    enforce_keyAgreement;
+    Bool    enforce_keyCertSign;
+    Bool    enforce_cRLSign;
+    Bool    enforce_encipherOnly;
+    Bool    enforce_decipherOnly;
+
+    /* List of all search queries currently being processed. */
+    /* Blank entries in this table have a negative number in */
+    /* the connection_id field.                              */
+    int	   MAX_QUERIES;
+    struct active_query  *pending_queries;
+
+    /* List of all certificate search results returned recently.      */
+    /* Blank entries in this table have a NULL in the ldif_ptr field. */
+    int    MAX_RESULTS_CACHE;
+    int    MAX_RESULTS_LIFE;
+    struct search_result  *last_search_results;
+
+    /* The maximum number of certificates that    */
+    /* can be returned for a single search query. */
+    int    MAX_CERTIFICATES;
+};
+
+/*
+ * This structure holds a single certificate.
+ * It will be chained with other certificates as they are found.
+ */
+struct certlist {
+    char   *der_certificate;	/* Pointer to certificate in DER format. */
+    char   *b64_certificate;	/* Pointer to certificate in Base64 format. */
+    char   cert_attribute[MAX_ATTRIBUTE_NAME]; /* This cert's attribute name */
+    int    cert_der_length;	/* Certificate DER length   */
+    int    cert_b64_length;	/* Certificate Base64 length   */
+};
+
+/******************************************
+ **                                      **
+ **  The following data structures are   **
+ **  part of the decode_cert functions.  **
+ **                                      **
+ ******************************************/
+
+#define MAX_SERIALNUMBER 256
+#define MAXOIDLEN  9
+
+enum  tagclasstype { Universal, Application, Context_specific, Private };
+enum  tagpctype    { Primitive, Constructed };
+static char  hex[] = {'0','1','2','3','4','5','6','7',
+		      '8','9','A','B','C','D','E','F'};
+
+/*
+ * For building a chain of email addresses.
+ */
+struct  rfc822name_link {
+    char   *email_name;
+    struct rfc822name_link  *next_rfc822Name;
+};
+
+/*
+ * Information collected from the certificate currently being examined.
+ */
+struct   X509_certificate {
+    int	    certlength;
+    int     certversion;
+    int     serialnumber_length;
+    char    serialnumber[MAX_SERIALNUMBER];
+    char    *subject_algorithm_id;
+    char    issuer[MAX_DN_LENGTH];
+    char    validity_notbefore[16];
+    char    validity_notafter[16];
+    char    subject[MAX_DN_LENGTH];
+    char    emailAddress[MAX_EMAIL_LENGTH];
+    char    *subject_pkidata;
+    char    *signature_algorithm_id;
+    /* The following ver2 or ver3 only. */
+    /* char    *issuer_uniqueid;	*/
+    /* char    *subject_uniqueid;	*/
+    /* The following ver3 only. */
+    Bool    key_usage_criticality;
+    Bool    key_usage_digitalSignature;
+    Bool    key_usage_nonRepudiation;
+    Bool    key_usage_keyEncipherment;
+    Bool    key_usage_dataEncipherment;
+    Bool    key_usage_keyAgreement;
+    Bool    key_usage_keyCertSign;
+    Bool    key_usage_cRLSign;
+    Bool    key_usage_encipherOnly;
+    Bool    key_usage_decipherOnly;
+    Bool    subjectAltName_criticality;
+    char    first_rfc822Name[MAX_EMAIL_LENGTH];
+    struct rfc822name_link  rfc822Name_chain;
+    Bool    ns_cert_type_sslclient;
+    Bool    ns_cert_type_sslserver;
+    Bool    ns_cert_type_smime;
+    Bool    ns_cert_type_objsigning;
+    Bool    ns_cert_type_sslca;
+    Bool    ns_cert_type_smimeca;
+    Bool    ns_cert_type_objsigningca;
+};
+
+/*
+ * Information collected from the CRL currently being examined.
+ */
+struct  X509_crl {
+    int    crl_number;
+    int    crl_length;
+    int    crl_version;
+    char   *signature_algorithm_id;
+    char   crl_issuer[MAX_DN_LENGTH];
+    char   thisUpdate[16];
+    char   nextUpdate[16];
+    int    revoked_certs;
+};
+
+/*
+ * Private structure for storing global data that is available for
+ * use by all routines in search.c in a single backend thread.
+ */
+struct getcert_private {
+    int    cert_number;			  /* Number of certs found           */
+    int    total_octets;                  /* Counter into certificate        */
+    int    tag_number, tag_class, tag_pc; /* ASN.1 cert encoding tag         */
+    Bool   integer_error;		  /* errors while decoding integers  */
+    unsigned long	bitstring; 
+    Bool   criticality;			  /* Criticality of cert extensions. */
+    int    oid_encoded[MAXOIDLEN];	  /* Encoded OID octets from cert    */
+    int	   oidsubnumber;	    /* Number of sub-ids in oid_decimal array */
+    long   oid_decimal[16];	          /* OID as decimal numbers          */
+    char   oid_string[MAX_STRING];        /* OID numbers as printable string */
+    char   client_ip[MAX_IP_LENGTH];	  /* LDAP client's IP address        */
+    char   unique_ndn[MAX_DN_LENGTH];	  /* DN returned with search results */
+    char   mailfilter[MAX_FILTER_LEN];    /* Email address filter (mail=...) */
+    struct tm  current_time;              /* Current time breakdown          */
+	/* Certificate & LDAP buffers */
+    struct certlist  **certificates;
+    char   certbuffer[MAX_CERTIFICATE_SIZE];
+    char   content_buffer[MAX_CONTENT];   /* Temp buffer for cert values     */
+    char   log_buffer[MAX_LOG_REC];	  /* Current transaction log record  */
+    struct X509_certificate  current_certificate;  /* Info from current cert */
+    struct X509_crl current_crl;	      /* Info from current CRL       */
+    struct berval **attr_vals;
+			     /* A list of attribute values and their lengths */
+    int    *object_lengths;  /* Lengths of attribute values in a data chain  */
+};
+
+/*
+ *  getcert return codes 
+ */
+#define GETCERT_SUCCESS                 0
+#define GETCERT_ERR_BADUSAGE            1
+#define GETCERT_ERR_INFILE              2
+#define GETCERT_ERR_LDAPINIT            3
+#define GETCERT_ERR_LDAPBIND            4
+#define GETCERT_ERR_SIZELIMIT           5
+#define GETCERT_ERR_SEARCH              6
+#define GETCERT_ERR_NOCERT              7
+#define GETCERT_ERR_NOSRVRLIST          8
+#define GETCERT_ERR_SERVERLIST_SYNTAX   9
+#define GETCERT_ERR_BAD_EMAILADDR       10
+#define GETCERT_ERR_NOSERVER            11
+#define GETCERT_ERR_TOO_LARGE           12
+#define GETCERT_NO_VALID_CERTS          13
+#define GETCERT_NO_SUCH_PERSON          14
+#define GETCERT_NO_MEMORY	        15
+#define GETCERT_CANNOT_PROCESS	        16
+#define GETCERT_SERVER_BUSY	        17
+#define GETCERT_LOOP_DETECT		18
+#define GETCERT_NO_BASEDN		19
+#define GETCERT_NO_CRL_FOUND		20
+#define GETCERT_NO_VALID_DATA		21
+
+static char *getcert_err_msg[] = {
+                "Successful",
+                "USAGE: get_certificate [ options ] email_address.",
+                "Cannot open LDAP server list file.",
+                "Cannot contact LDAP server.",
+                "Cannot establish session with LDAP server.",
+                "Too many entries matched from LDAP database.",
+                "LDAP search error.",
+                "Could not find certificate for this user.",
+                "No valid server entries found in server list file.",
+                "Invalid syntax in server list file.",
+                "Invalid email address.",
+                "No LDAP server listed for this email address.",
+                "Cannot allocate enough memory to hold large certificates.",
+		"No valid certificates found for this user.",
+		"No person found for this email address.",
+		"Not enough memory available to service this request.",
+		"Cannot process this request.",
+		"Proxy server busy.  Too many LDAP queries being processed.",
+		"Duplicate LDAP query received.  New query rejected.",
+		"No Search Base DN specified in search request.",
+		"No Certificate Revocation Lists found."
+};
+
+/*
+ * Object ID entries of possible interest us.
+ */
+#define MAXOIDNUM  50			/* The number of OIDs defined */
+					/* in the following arrays.   */
+static char *oid_name[MAXOIDNUM] = {
+	"unknownOID",			/*  { 0 0 0 0 0 0 0 0 0 }	*/
+					/* CertificateRevocationList    */
+	"cert_suspended",		/* { 1 2 840 10040 2 1 }        */
+	"cert_suspended_callissuer",	/* { 1 2 840 10040 2 2 }        */
+	"cert_rejected",		/* { 1 2 840 10040 2 3 }        */
+					/* PKCS-1			*/
+	"RSA", 				/*  { 1 2 840 113549 1 1 1 }	*/
+	"MD2withRSA",			/*  { 1 2 840 113549 1 1 2 }	*/
+	"MD4withRSA",			/*  { 1 2 840 113549 1 1 3 }	*/
+	"MD5withRSA",			/*  { 1 2 840 113549 1 1 4 }	*/
+	"SHA1withRSA",			/*  { 1 2 840 113549 1 1 5 }	*/
+					/* PKCS-9 Signatures		*/
+	"emailAddress",			/*  { 1 2 840 113549 1 9 1 }	*/
+					/* X.500 attribute types	*/
+	"CN",				/*  { 2 5 4 3 }			*/
+	"S",				/*  { 2 5 4 4 }			*/
+	"SN",				/*  { 2 5 4 5 }			*/
+	"C",				/*  { 2 5 4 6 }			*/
+	"L",				/*  { 2 5 4 7 }			*/
+	"ST",				/*  { 2 5 4 8 }			*/
+	"O",				/*  { 2 5 4 10 }		*/
+	"OU",				/*  { 2 5 4 11 }		*/
+	"T",				/*  { 2 5 4 12 }		*/
+	"D",				/*  { 2 5 4 13 }		*/
+					/* certificateExtension (id-ce)	*/
+	"subjectKeyIdentifier",		/*  { 2 5 29 14 }		*/
+	"keyUsage",			/*  { 2 5 29 15 }		*/
+	"privateKeyUsagePeriod",	/*  { 2 5 29 16 }		*/
+	"subjectAltName",		/*  { 2 5 29 17 }		*/
+	"issuerAltName",		/*  { 2 5 29 18 }		*/
+	"basicConstraints",		/*  { 2 5 29 19 }		*/
+	"cRLNumber",			/*  { 2 5 29 20 }		*/
+	"reasonCode",			/*  { 2 5 29 21 }		*/
+	"holdInstructionCode",		/*  { 2 5 29 23 }		*/
+	"invalidityDate",		/*  { 2 5 29 24 }		*/
+	"deltaCRLIndicator",		/*  { 2 5 29 27 }		*/
+	"issuingDistributionPoint",	/*  { 2 5 29 28 }		*/
+	"certificateIssuer",		/*  { 2 5 29 29 }		*/
+	"nameConstraints",		/*  { 2 5 29 30 }		*/
+	"cRLDistributionPoints",	/*  { 2 5 29 31 }		*/
+	"certificatePolicies",		/*  { 2 5 29 32 }		*/
+	"policyMappings",		/*  { 2 5 29 33 }		*/
+	"authorityKeyIdentifier",	/*  { 2 5 29 35 }		*/
+	"policyConstraints",		/*  { 2 5 29 36 }		*/
+					/* Netscape certificate		*/
+	"netscape_cert_extension",	/*  { 2 16 840 1 113730 1 }	*/
+	"netscape_cert_type",		/*  { 2 16 840 1 113730 1 1 }   */
+	"netscape_base_url",		/*  { 2 16 840 1 113730 1 2 }   */
+	"netscape_revocation_url",	/*  { 2 16 840 1 113730 1 3 }   */
+	"netscape_ca_revocation_url",	/*  { 2 16 840 1 113730 1 4 }   */
+	"netscape_renewal_url",		/*  { 2 16 840 1 113730 1 7 }   */
+	"netscape_ca_policy_url",	/*  { 2 16 840 1 113730 1 8 }   */
+	"netscape_ssl_server_name",	/*  { 2 16 840 1 113730 1 12 }  */
+	"netscape_comment",		/*  { 2 16 840 1 113730 1 13 }  */
+	"netscape_data_type",		/*  { 2 16 840 1 113730 2 }     */
+	"netscape_cert_sequence"	/*  { 2 16 840 1 113730 2 5 }   */
+};
+static int oid_type[MAXOIDNUM][MAXOIDLEN] = {
+	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x2A,0x86,0x48,0xCE,0x38,0x02,0x01,0x00,0x00},
+	{0x2A,0x86,0x48,0xCE,0x38,0x02,0x02,0x00,0x00},
+	{0x2A,0x86,0x48,0xCE,0x38,0x02,0x03,0x00,0x00},
+	{0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x01},
+	{0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x02},
+	{0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x03},
+	{0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x04},
+	{0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x05},
+	{0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x09,0x01},
+	{0x55,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x04,0x05,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x04,0x06,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x04,0x07,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x04,0x08,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x04,0x0A,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x04,0x0B,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x04,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x04,0x0D,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x0E,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x0F,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x10,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x11,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x12,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x13,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x14,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x15,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x17,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x18,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x1B,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x1C,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x1D,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x1E,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x1F,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x20,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x21,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x23,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x55,0x1D,0x24,0x00,0x00,0x00,0x00,0x00,0x00},
+	{0x60,0x86,0x48,0x01,0x86,0xF8,0x42,0x01,0x00},
+	{0x60,0x86,0x48,0x01,0x86,0xF8,0x42,0x01,0x01},
+	{0x60,0x86,0x48,0x01,0x86,0xF8,0x42,0x01,0x02},
+	{0x60,0x86,0x48,0x01,0x86,0xF8,0x42,0x01,0x03},
+	{0x60,0x86,0x48,0x01,0x86,0xF8,0x42,0x01,0x04},
+	{0x60,0x86,0x48,0x01,0x86,0xF8,0x42,0x01,0x07},
+	{0x60,0x86,0x48,0x01,0x86,0xF8,0x42,0x01,0x08},
+	{0x60,0x86,0x48,0x01,0x86,0xF8,0x42,0x01,0x0C},
+	{0x60,0x86,0x48,0x01,0x86,0xF8,0x42,0x01,0x0D},
+	{0x60,0x86,0x48,0x01,0x86,0xF8,0x42,0x02,0x00},
+	{0x60,0x86,0x48,0x01,0x86,0xF8,0x42,0x02,0x05}
+};
+
+/* End of getcert.h */
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/init.c openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/init.c
--- openldap-2.3.41-clean/servers/slapd/back-getcert/init.c	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/init.c	2008-03-25 12:18:48.000000000 -0400
@@ -0,0 +1,157 @@
+/* init.c   version 4.1   October 4, 2006  */
+
+#include "portable.h"
+#include <stdio.h>
+#include "slap.h"
+#include "proto-getcert.h"
+#include "getcert.h"
+
+extern get_line(char s[], int lim);
+
+#ifdef SLAPD_GETCERT_DYNAMIC
+
+int back_getcert_LTX_init_module(int argc, char *argv[]) {
+    BackendInfo bi;
+
+    memset( &bi, '\0', sizeof(bi) );
+    bi.bi_type = "getcert";
+    bi.bi_init = getcert_back_initialize;
+
+    backend_add(&bi);
+    return 0;
+}
+
+#endif /* SLAPD_GETCERT_DYNAMIC */
+
+int
+getcert_back_initialize(
+    BackendInfo	*bi
+)
+{
+	bi->bi_open = 0;
+	bi->bi_config = 0;
+	bi->bi_close = 0;
+	bi->bi_destroy = 0;
+
+	bi->bi_db_init = getcert_back_init;
+	bi->bi_db_config = getcert_back_config;
+	bi->bi_db_open = getcert_back_open;
+	bi->bi_db_close = getcert_back_close;
+	bi->bi_db_destroy = getcert_back_destroy;
+
+	bi->bi_op_bind = getcert_back_bind;
+	bi->bi_op_unbind = getcert_back_unbind;
+	bi->bi_op_search = getcert_back_search;
+	bi->bi_op_compare = 0;
+	bi->bi_op_modify = 0;
+	bi->bi_op_modrdn = 0;
+	bi->bi_op_add = 0;
+	bi->bi_op_delete = 0;
+	bi->bi_op_abandon = 0;
+
+	bi->bi_extended = 0;
+
+#ifdef SLAP_OVERLAY_ACCESS
+	bi->bi_acl_group = 0;
+	bi->bi_acl_attribute = 0;
+#endif
+	bi->bi_chk_referrals = 0;
+
+	bi->bi_connection_init = 0;
+	bi->bi_connection_destroy = 0;
+
+	return 0;
+}
+
+/*
+ *  Create the private data area to be
+ *  used by all the getcert routines.
+ */
+int
+getcert_back_init(be)
+    Backend  *be;
+{
+    int   i, log_facility, rc, recsize, structsize;
+    char  *ptr;
+    struct getcert_data  *getcert_shared;
+
+    syslog(LOG_INFO,
+	"Initializing LDAP Proxy version %.256s\n", ldap_proxy_version);
+
+    structsize = sizeof(struct getcert_data);
+    
+/*
+ *  syslog(LOG_INFO,
+ *      "Allocating %d bytes of memory for backend process.\n", structsize);
+ */
+    getcert_shared = malloc(structsize);
+    if (getcert_shared == NULL) {
+        fprintf(stderr,
+            "Not enough memory (%d) for private area.\n", structsize);
+        syslog(LOG_INFO,
+            "[error] Not enough memory (%d) for private area.\n", structsize);
+        return(1);
+    }
+
+    /* Set the initial default values for the global options. */
+    /* These can be overridden in the slapd.conf file.        */
+    getcert_shared->debugging = 1;
+    getcert_shared->certificate_type = 0;
+    getcert_shared->certificate_check = 2;
+    getcert_shared->search_timeout = 30;
+    getcert_shared->search_all_servers = FALSE;
+#ifdef HAVE_PATHFINDER
+    getcert_shared->use_pathfinder = FALSE;
+    getcert_shared->pf_policy = NULL;
+#endif
+    getcert_shared->limit_return_codes = TRUE;
+    getcert_shared->normalize_common_name = FALSE;
+    getcert_shared->cert_server_list_filename = NULL;
+    getcert_shared->cert_serverlist = NULL;
+    getcert_shared->ldap_server_list_filename = NULL;
+    getcert_shared->ldap_serverlist = NULL;
+    getcert_shared->issuer_filter_type = none;
+    getcert_shared->cert_issuer_filters = NULL;
+    getcert_shared->enforce_digitalSignature = FALSE;
+    getcert_shared->enforce_nonRepudiation = FALSE;
+    getcert_shared->enforce_keyEncipherment = FALSE;
+    getcert_shared->enforce_dataEncipherment = FALSE;
+    getcert_shared->enforce_keyAgreement = FALSE;
+    getcert_shared->enforce_keyCertSign = FALSE;
+    getcert_shared->enforce_cRLSign = FALSE;
+    getcert_shared->enforce_encipherOnly = FALSE;
+    getcert_shared->enforce_decipherOnly = FALSE;
+    getcert_shared->MAX_QUERIES = 64;
+    getcert_shared->pending_queries = NULL;
+    getcert_shared->MAX_RESULTS_CACHE = 128;
+    getcert_shared->MAX_RESULTS_LIFE = 30;
+    getcert_shared->last_search_results = NULL;
+    getcert_shared->MAX_CERTIFICATES = 128;
+
+    be->be_private = getcert_shared;
+
+    return(0);
+}
+
+/*
+ *  Free up the memory allocated for
+ *  use by the private data area.
+ */
+int
+getcert_back_destroy(be)
+    Backend  *be;
+{
+    struct getcert_data  *getcert_shared;
+
+    if (be->be_private != NULL) {
+	getcert_shared = be->be_private;
+	if ((getcert_shared->debugging & DEBUG_MEM) ||
+	    (getcert_shared->debugging & DEBUG_GEN_HI))
+            syslog(LOG_DEBUG,
+		"[debug] Releasing memory allocated to private area.\n");
+        free(be->be_private);
+        be->be_private = NULL;
+    }
+
+    return(0);
+}
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/open.c openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/open.c
--- openldap-2.3.41-clean/servers/slapd/back-getcert/open.c	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/open.c	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,347 @@
+/* open.c   4.2   February 22, 2007  */
+/*
+ *  This is the open.c file for the getcert SLAPD backend.
+ *  Marc Amis  (marc.amis@boeing.com)
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "portable.h"
+#include "slap.h"
+#include "proto-getcert.h"
+#include "getcert.h"
+
+extern void release_cert_server_list();
+extern int  read_cert_serverlist();
+
+/*
+ *  Verify that all required slapd.conf configuration options
+ *  have been set.  Then allocate memory for required structures.
+ */
+int
+getcert_back_open(be)
+    Backend *be;
+{
+    struct getcert_data  *getcert_shared;
+    int  i, rc, tablesize;
+    struct cert_server *cert_server_list_new[MAX_LDAP_SERVERS];
+    struct cert_server **certlistptr;
+    struct ldap_server *ldap_server_list_new[MAX_LDAP_SERVERS];
+    struct ldap_server **ldaplistptr;
+
+    getcert_shared = be->be_private;
+
+    if (getcert_shared->debugging & DEBUG_GEN_HI)
+        syslog(LOG_DEBUG,
+	    "[debug] Verifying presence of required configuration options.\n");
+
+    if ((getcert_shared->cert_server_list_filename == NULL) && 
+	(getcert_shared->ldap_server_list_filename == NULL)) {
+	syslog(LOG_INFO,
+	    "[error] %.200s %.200s\n",
+	    "No valid certificate_server_list or ldap_server_list files",
+	    "specified in the slapd.conf file");
+	return(1);
+    }
+
+    /*
+     * Build a new certificate server list in memory.
+     */
+    if (getcert_shared->cert_server_list_filename != NULL) {
+	if (getcert_shared->debugging > DEBUG_NONE)
+            syslog(LOG_DEBUG,
+	        "Reading %.900s\n", getcert_shared->cert_server_list_filename);
+        rc = read_cert_serverlist(be,
+			      getcert_shared->cert_server_list_filename,
+		              cert_server_list_new);
+        if (rc < 0) {
+	    syslog(LOG_INFO,
+	        "[error] Unable to read %.900s\n",
+		getcert_shared->cert_server_list_filename);
+	    return(1);
+        }
+        if (rc == 0) {
+	    syslog(LOG_INFO,
+	        "[error] No servers defined in %.900s\n",
+		getcert_shared->cert_server_list_filename);
+	    return(1);
+        }
+	/* 
+	 * Allocate memory for the null terminated 
+	 * cert list pointer array.
+	 */
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+	        "[debug] Allocating %d bytes of memory for a %d %.64s\n",
+		(rc + 1) * sizeof(struct cert_server *), rc, 
+		"element certificate list pointer array.");
+	certlistptr = malloc((rc + 1) * sizeof(struct cert_server *));
+	if (certlistptr == NULL) {
+	    syslog(LOG_INFO,
+		"[error] Not enough memory for certificate list array.\n");
+	    release_cert_server_list(be, cert_server_list_new); 
+	    return(1);
+	}
+	/* Copy the new server list into permanent memory. */
+        for (i = 0; i < rc; i++)
+            certlistptr[i] = cert_server_list_new[i];
+        certlistptr[rc] = NULL;
+        getcert_shared->cert_serverlist = certlistptr;
+    }
+
+    /* Debug output of the new certificate servers list. */
+    if ((getcert_shared->debugging & DEBUG_GEN_LO) && 
+        (getcert_shared->cert_serverlist != NULL)) {
+	syslog(LOG_DEBUG,
+	    "[debug] %.900s\n",
+	    "Following is the in-memory copy of the certificate server list:");
+	for (i = 0; getcert_shared->cert_serverlist[i] != NULL; i++) {
+	    syslog(LOG_DEBUG,
+		"[debug]    Certificate server list entry %d:\n", i);
+	    syslog(LOG_DEBUG,
+		"[debug]        %.900s\n",
+		getcert_shared->cert_serverlist[i]->email_domain);
+	    syslog(LOG_DEBUG,
+		"[debug]        %.900s\n",
+		getcert_shared->cert_serverlist[i]->server_name);
+	    syslog(LOG_DEBUG,
+		"[debug]        %d\n",
+		getcert_shared->cert_serverlist[i]->port);
+	    if (getcert_shared->cert_serverlist[i]->base_dn[0] == '\0')
+	        syslog(LOG_DEBUG,
+		    "[debug]        NULL\n");
+	    else
+	        syslog(LOG_DEBUG,
+		    "[debug]        %.900s\n",
+		    getcert_shared->cert_serverlist[i]->base_dn);
+	    syslog(LOG_DEBUG,
+		"[debug]        %.900s\n",
+		getcert_shared->cert_serverlist[i]->mail_attr);
+	    syslog(LOG_DEBUG,
+		"[debug]        %.900s\n",
+		getcert_shared->cert_serverlist[i]->personname_attr);
+	    syslog(LOG_DEBUG,
+		"[debug]        %.900s\n",
+		getcert_shared->cert_serverlist[i]->cert_attr);
+	    if (getcert_shared->cert_serverlist[i]->bind_dn[0] == '\0')
+		syslog(LOG_DEBUG,
+		    "[debug]        NULL\n");
+	    else
+	        syslog(LOG_DEBUG,
+		    "[debug]        <Bind DN>\n");
+	    if (getcert_shared->cert_serverlist[i]->bind_password[0] == '\0')
+	        syslog(LOG_DEBUG,
+		    "[debug]        NULL\n");
+	    else
+	        syslog(LOG_DEBUG,
+		    "[debug]        <Bind Password>\n");
+	}
+    }
+
+    /*
+     * Build a new ldap server list in memory.
+     */
+    if (getcert_shared->ldap_server_list_filename != NULL) {
+	if (getcert_shared->debugging > DEBUG_NONE)
+            syslog(LOG_DEBUG,
+	        "Reading %.900s\n", getcert_shared->ldap_server_list_filename);
+        rc = read_ldap_serverlist(be,
+			     getcert_shared->ldap_server_list_filename,
+		             ldap_server_list_new);
+        if (rc < 0) {
+	    syslog(LOG_INFO,
+	        "[error] Unable to read %.900s file.\n",
+		getcert_shared->ldap_server_list_filename);
+	    return(1);
+        }
+	if (rc == 0) {
+            syslog(LOG_INFO,
+                "[error] No servers defined in %.900s\n",
+                getcert_shared->ldap_server_list_filename);
+            return(1);
+        }
+	/*
+         * Allocate memory for the null terminated
+         * LDAP server list pointer array.
+         */
+	if (getcert_shared->debugging & DEBUG_MEM)
+            syslog(LOG_DEBUG,
+                "[debug] Allocating %d bytes of memory for a %d %.64s\n",
+                (rc + 1) * sizeof(struct ldap_server *), rc,
+                "element LDAP server list pointer array.");
+	ldaplistptr = malloc((rc + 1) * sizeof(struct ldap_server *));
+        if (ldaplistptr == NULL) {
+            syslog(LOG_INFO,
+                "[error] Not enough memory for LDAP server list array.\n");
+            release_ldap_server_list(be, ldap_server_list_new);
+            return(1);
+        }
+        /* Copy the new server list into permanent memory. */
+        for (i = 0; i < rc; i++)
+            ldaplistptr[i] = ldap_server_list_new[i];
+        ldaplistptr[rc] = NULL;
+        getcert_shared->ldap_serverlist = ldaplistptr;
+    }
+
+    /* We know there is at least one LDAP server list. */
+    /* Are any servers actually defined in them?       */
+    if ((getcert_shared->cert_serverlist == NULL) && 
+	(getcert_shared->ldap_serverlist == NULL)) {
+	syslog(LOG_INFO,
+	    "[error] %.900s\n",
+	    "No LDAP servers defined in either of the LDAP server lists.");
+	return(1);
+    }
+
+    /* Debug output of the new LDAP server list. */
+    if ((getcert_shared->debugging & DEBUG_GEN_LO) && 
+        (getcert_shared->ldap_serverlist != NULL)) {
+	syslog(LOG_DEBUG,
+	   "[debug] Following is the in-memory copy of the LDAP server list:\n");
+	for (i = 0; getcert_shared->ldap_serverlist[i] != NULL; i++) {
+	    syslog(LOG_DEBUG,
+		"[debug]    LDAP server list entry %d:\n", i + 1);
+	    syslog(LOG_DEBUG,
+		"[debug]        %.900s\n",
+		getcert_shared->ldap_serverlist[i]->ldap_dn);
+	    syslog(LOG_DEBUG,
+		"[debug]        %.900s\n",
+		getcert_shared->ldap_serverlist[i]->server_name);
+	    syslog(LOG_DEBUG,
+		"[debug]        %d\n",
+		getcert_shared->ldap_serverlist[i]->port);
+	    syslog(LOG_DEBUG,
+		"[debug]        %.900s\n",
+		getcert_shared->ldap_serverlist[i]->ldap_attr);
+	    switch (getcert_shared->ldap_serverlist[i]->verification) {
+		case NONE:
+		    syslog(LOG_DEBUG, "[debug]        none\n");
+		    break;
+		case CERT:
+		    syslog(LOG_DEBUG, "[debug]        cert\n");
+		    break;
+		case CRL:
+		    syslog(LOG_DEBUG, "[debug]        crl\n");
+		    break;
+	    }
+	    if (getcert_shared->ldap_serverlist[i]->bind_dn[0] == '\0')
+	        syslog(LOG_DEBUG,
+		    "[debug]        NULL\n");
+	    else 
+	        syslog(LOG_DEBUG,
+		    "[debug]        <Bind DN>\n");
+	    if (getcert_shared->ldap_serverlist[i]->bind_password[0] == '\0')
+	        syslog(LOG_DEBUG,
+		    "[debug]        NULL\n");
+	    else 
+	        syslog(LOG_DEBUG,
+		    "[debug]        <Bind Password>\n");
+	}
+    }
+
+    /*
+     * Debug output of the cert_issuer filters (if any).
+     */
+    if (getcert_shared->issuer_filter_type != none) {
+	if (getcert_shared->debugging & DEBUG_GEN_LO) {
+	    if (getcert_shared->issuer_filter_type == accept_cert) {
+	        syslog(LOG_DEBUG,
+		    "[debug] %.400s %.400s\n",
+		    "Accepting certificates based on",
+		    "the following issuer filter(s):");
+	    } else {
+	        syslog(LOG_DEBUG,
+		    "[debug] %.400s %.400s\n",
+		    "Rejecting certificates based on",
+		    "the following issuer filter(s):");
+	    }
+	    for (i = 0; i < MAX_ISSUER_FILTERS; i++) {
+		if (getcert_shared->cert_issuer_filters[i] == NULL)
+		    break;
+		else
+		    syslog(LOG_DEBUG,
+			"[debug]    %.900s\n",
+			getcert_shared->cert_issuer_filters[i]);
+	    }
+	}
+    }
+
+    /*
+     * Allocate memory for and initialize the pending_queries list.
+     */
+    if (getcert_shared->MAX_QUERIES < MIN_TABLE_SIZE) {
+	syslog(LOG_INFO, 
+	    "[error] max_queries value set too low (%d) in slapd.conf.\n",
+	    getcert_shared->MAX_QUERIES);
+	return(1);
+    } else {
+	tablesize = getcert_shared->MAX_QUERIES * sizeof(struct active_query);
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[debug] Allocating %d bytes of memory %.64s\n",
+		tablesize, "for pending_queries list.");
+	getcert_shared->pending_queries =
+		calloc(getcert_shared->MAX_QUERIES,
+		       sizeof(struct active_query));
+	if (getcert_shared->pending_queries == NULL) {
+	     syslog(LOG_INFO,
+		 "[error] Not enough memory (%d bytes) %.64s\n",
+		 tablesize, "for pending_queries list.");
+	     return(1);
+	} else {
+            if (getcert_shared->debugging & DEBUG_MEM)
+	        syslog(LOG_DEBUG,
+	           "[debug] Allocated %d bytes of memory for %d %.80s\n",
+	           tablesize, getcert_shared->MAX_QUERIES,
+		   "pending_queries entries.\n");
+    	    /* Initialize pending_queries table. */
+	    /* Each empty entry in the list has  */
+	    /* a -1 in the connection_id field.  */
+	    for (i = 0; i < getcert_shared->MAX_QUERIES; i++) {
+	        getcert_shared->pending_queries[i].connection_id = -1;
+	        getcert_shared->pending_queries[i].client_ip_addr[0] = '\0';
+	        getcert_shared->pending_queries[i].query_filter[0] = '\0';
+	        getcert_shared->pending_queries[i].base_dn[0] = '\0';
+	    }
+	}
+    
+    }
+
+    /*
+     * Allocate memory for and initialize the last_search_results cache.
+     */
+    tablesize =
+	getcert_shared->MAX_RESULTS_CACHE * sizeof(struct search_result);
+    if (getcert_shared->debugging & DEBUG_MEM)
+        syslog(LOG_DEBUG,
+            "[debug] Allocating %d %.128s\n",
+            tablesize, "bytes of memory for last_search_results cache.");
+    getcert_shared->last_search_results =
+		calloc(getcert_shared->MAX_RESULTS_CACHE,
+		       sizeof(struct search_result));
+    if (getcert_shared->last_search_results == NULL) {
+	syslog(LOG_INFO,
+	    "[error] Not enough memory (%d bytes) %.80s\n",
+            tablesize, "for last_search_results list.");
+        return(1);
+    } else {
+        if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+	        "[debug] Allocated %d bytes of memory for %d entry %.80s\n",
+	        tablesize, getcert_shared->MAX_RESULTS_CACHE,
+		"last_search_results cache.");
+        /* Initialize last_search_results table. */
+        /* Each empty entry in the list has  */
+        /* a NULL in the ldif_ptr field.     */
+        for (i = 0; i < getcert_shared->MAX_RESULTS_CACHE; i++) {
+            getcert_shared->last_search_results[i].client_ip_addr[0] = '\0';
+            getcert_shared->last_search_results[i].unique_ndn[0] = '\0';
+            getcert_shared->last_search_results[i].filterstr[0] = '\0';
+	    getcert_shared->last_search_results[i].search_attrs[0] = NULL;
+            getcert_shared->last_search_results[i].timestamp = (time_t)0;
+            getcert_shared->last_search_results[i].ldif_ptr = NULL;
+        }
+    }
+
+    return(0);
+}
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/proto-getcert.h openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/proto-getcert.h
--- openldap-2.3.41-clean/servers/slapd/back-getcert/proto-getcert.h	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/proto-getcert.h	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,20 @@
+#ifndef _GETCERT_EXTERNAL_H
+#define _GETCERT_EXTERNAL_H
+
+LDAP_BEGIN_DECL
+
+extern BI_init  	getcert_back_initialize;
+
+extern BI_db_init       getcert_back_init;
+extern BI_db_config     getcert_back_config;
+extern BI_db_open       getcert_back_open;
+extern BI_db_close      getcert_back_close;
+extern BI_db_destroy    getcert_back_destroy;
+
+extern BI_op_bind       getcert_back_bind;
+extern BI_op_unbind     getcert_back_unbind;
+extern BI_op_search     getcert_back_search;
+
+LDAP_END_DECL
+
+#endif /* _GETCERT_EXTERNAL_H */
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/read_cert_serverlist.c openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/read_cert_serverlist.c
--- openldap-2.3.41-clean/servers/slapd/back-getcert/read_cert_serverlist.c	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/read_cert_serverlist.c	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,416 @@
+/*  read_cert_serverlist.c  version 3.1   10/3/2004  */
+/*
+ *  This is the read_cert_serverlist.c file for use by the
+ *  getcert SLAPD backend.
+ *  Marc Amis	(marc.amis@boeing.com)
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "portable.h"
+#include "slap.h"
+#include "proto-getcert.h"
+#include "getcert.h"
+
+/*
+ *  Read in a line from the input file (without the NEWLINE).
+ *  Return number of chars read or EOF.
+ *  On input, "s" is a pointer to the destination character buffer
+ *  and "limit" is the maximum size of the character buffer.
+ */
+int
+get_line(s, limit)
+    char s[];
+    int limit;
+{
+    int c, i;
+
+    i = 0;
+    while (--limit > 0 && (c=getc(infile)) != EOF && c != '\n')
+        s[i++] = c;
+    s[i] = '\0';
+    linenum++;
+    if (c == EOF)
+        return(EOF);
+    else
+        return(i);
+} /* get_line */
+
+/*
+ *  Release all memory allocated for server chain.
+ */
+void
+release_cert_server_list(be, server_list_ptr)
+    Backend *be;
+    struct cert_server **server_list_ptr;
+{
+    int  i;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    for (i = 0; i < server_count; i++) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+	        "[debug] %.900s\n",
+		"Releasing memory allocated for cert server chain link.");
+        free(server_list_ptr[i]);
+    }
+    return;
+} /* release_cert_server_list */
+
+/*
+ * Allocate memory and store one certificate server structure.
+ */
+int
+store_cert_server(be, server_number, server_list_ptr)
+    Backend *be;
+    int server_number;
+    struct cert_server **server_list_ptr;
+{
+    struct cert_server *blockptr;
+    int    structsize;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    structsize = sizeof(struct cert_server);
+    if (getcert_shared->debugging & DEBUG_MEM)
+	syslog(LOG_DEBUG,
+	    "[debug] Allocating %d bytes of memory %.64s %d.\n",
+	    structsize, "for cert server chain link", server_number);
+    blockptr = malloc(structsize);
+    if (blockptr == NULL) {
+	syslog(LOG_INFO,
+	    "[error] Not enough memory for certificate server list.\n");
+        release_cert_server_list(be, server_list_ptr);
+        return(1);
+    }
+
+    /*
+     * Copy server info from buffer into this memory block.
+     * It's not possible to overflow the block copy as the
+     * memory block as allocated is the same size as the buffer.
+     */
+    strncpy(blockptr->email_domain, cert_server_buffer.email_domain,
+	strlen(cert_server_buffer.email_domain) + 1);
+    strncpy(blockptr->server_name, cert_server_buffer.server_name,
+	strlen(cert_server_buffer.server_name) + 1);
+    blockptr->port = cert_server_buffer.port;
+    strncpy(blockptr->base_dn, cert_server_buffer.base_dn,
+	strlen(cert_server_buffer.base_dn) + 1);
+    strncpy(blockptr->mail_attr, cert_server_buffer.mail_attr,
+	strlen(cert_server_buffer.mail_attr) + 1);
+    strncpy(blockptr->personname_attr, cert_server_buffer.personname_attr,
+	strlen(cert_server_buffer.personname_attr) + 1);
+    strncpy(blockptr->cert_attr, cert_server_buffer.cert_attr,
+	strlen(cert_server_buffer.cert_attr) + 1);
+    if (cert_server_buffer.bind_dn[0] == '\0')
+        blockptr->bind_dn[0] = '\0';
+    else
+        strncpy(blockptr->bind_dn, cert_server_buffer.bind_dn,
+	    strlen(cert_server_buffer.bind_dn) + 1);
+    if (cert_server_buffer.bind_password[0] == '\0')
+        blockptr->bind_password[0] = '\0';
+    else
+        strncpy(blockptr->bind_password, cert_server_buffer.bind_password,
+	    strlen(cert_server_buffer.bind_password) + 1);
+
+    server_list_ptr[server_number] = blockptr;
+
+    return(0);
+} /* store_cert_server */
+
+/*
+ *  Read in the certificate server list from filename
+ *  and return an in-memory cert_server structure list.
+ *  Return Code:
+ *	Success = Return number of servers in the list.
+ *      Failure = Return -1
+ */
+int
+read_cert_serverlist(be, filename, server_list_ptr)
+    Backend     *be;
+    char	*filename;
+    struct cert_server **server_list_ptr;
+{
+    int  len, offset, recsize, server_attribute;
+    char *ptr;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    /* Open the certificate server list file */
+    if ((infile = fopen(filename, "r")) == NULL) {
+	syslog(LOG_INFO,
+	    "[error] Can't open certificate server list file %.900s\n",
+	    filename);
+	return(-1);
+    }
+
+    /* Build a new certificate server list in memory. */
+    linenum = 0;
+    server_count = 0;
+    server_attribute = 0;
+    do {
+        recsize = get_line(linebuff, MAX_LINE);
+	if (recsize == EOF) {
+	    if (getcert_shared->debugging & DEBUG_GEN_LO)
+		syslog(LOG_DEBUG, "[debug] EOF at line %d\n", linenum);
+	    fclose(infile);
+	    infile = NULL;
+	}
+	if ((recsize == EOF) && (server_attribute < 7)) {
+	    if (server_count < 1) {
+		release_cert_server_list(be, server_list_ptr);
+		syslog(LOG_INFO,
+		    "[error] No servers in certificate server list %.900s\n",
+		    filename);
+		return(-1);
+	    }
+	    if ((server_attribute > 0) && (server_attribute < 7)) {
+	        /* Last server in list is too short. */
+		if (getcert_shared->debugging & DEBUG_GEN_HI)
+		    syslog(LOG_DEBUG,
+		        "[debug] Last server_attribute is %d\n",
+			server_attribute);
+		release_cert_server_list(be, server_list_ptr);
+		syslog(LOG_INFO,
+		    "[error] Last server entry is too short in %.900s\n",
+		    filename);
+		return(-1);
+	    } else {
+		if (server_attribute > 0) {
+		    /* Set default values for unspecified attrs. */
+		    switch (server_attribute) {
+		        case 7:
+			    cert_server_buffer.bind_dn[0] = '\0';	
+			case 8:
+			    cert_server_buffer.bind_password[0] = '\0';
+			    break;
+		    }
+		    if (store_cert_server(be, server_count, server_list_ptr)
+				!= 0)
+		        return(-1);
+		    else
+			server_count++;
+		}
+	    }
+	} else {
+	    /* Comment line? */
+	    if (linebuff[0] != '#') {
+                offset = 0;
+                /* Blank line? */
+		while (((linebuff[offset] == BLANK) ||
+			(linebuff[offset] == TAB)) &&
+		       (offset < MAX_LINE))
+                    offset++;
+                if ((offset > MAX_LINE) ||
+                    (linebuff[offset] == '\n') ||
+                    (linebuff[offset] == '\0')) {
+                    /* This is a blank line. */
+		    /* Are we finished with this server definition? */
+                    if ((server_attribute > 0) && (server_attribute < 7)) {
+                        /* We're lost in the certificate server list file. */
+			syslog(LOG_INFO,
+			    "[error] Syntax error on line %d %80s %.900s\n",
+			    linenum, "in certificate server list file:",
+			    filename);
+			if (infile != NULL)
+			    fclose(infile);
+			release_cert_server_list(be,server_list_ptr);
+			return(-1);
+		    } 
+		    if (server_attribute != 0) {
+		        switch (server_attribute) {
+                            case 7:
+                                cert_server_buffer.bind_dn[0] = '\0';
+                            case 8:
+                                cert_server_buffer.bind_password[0] = '\0';
+                                break;
+                        }
+			if (store_cert_server(be, server_count, server_list_ptr)
+				!= 0)
+			    return(-1);
+			else {
+                            server_count++;
+                            server_attribute = 0;
+			}
+		    }
+		} else {
+		    /* This is a server entry attribute. */
+		    /* Ignore excess attribute entries   */
+                    /* (accept only the first nine).     */
+                    if (server_attribute < 9) {
+		        len = strlen(&linebuff[offset]);
+                        switch (server_attribute) {
+                            case 0:
+				/* Email domain name */
+				if (len < MAX_LINE) {
+				    strncpy(cert_server_buffer.email_domain,
+				        &linebuff[offset], len + 1);
+				} else {
+				    syslog(LOG_INFO,
+					"[error] %64s %d: %.900s\n",
+					"Email domain too long: line",
+					linenum, filename);
+                                    return(-1);
+				}
+                                break;
+			    case 1:
+				/* LDAP server FQDN or IP address */
+				if (len < MAX_LINE) {
+                                    strncpy(cert_server_buffer.server_name,
+                                        &linebuff[offset], len + 1);
+				} else {
+				    syslog(LOG_INFO,
+					"[error] %.64s %d: %.900s\n",
+					"Server name too long: line",
+					linenum, filename);
+                                    return(-1);
+				}
+                                break;
+                            case 2:
+				/* LDAP port number */
+                                if (isdigit(linebuff[offset]) == 0) {
+                                    fclose(infile);
+				    release_cert_server_list(be,server_list_ptr);
+				    syslog(LOG_INFO,
+					"[error] %.64s %d: %.900s\n",
+					"Invalid port number on line",
+					linenum, filename);
+                                    return(-1);
+                                } else 
+                                   cert_server_buffer.port =
+					atoi(&linebuff[offset]);
+                                break;
+                            case 3:
+				/* Base DN */
+				if (len < MAX_LINE) {
+                                    strncpy(cert_server_buffer.base_dn,
+				        &linebuff[offset], len + 1);
+				} else {
+				    syslog(LOG_INFO,
+					"[error] %.64s %d: %.900s\n",
+					"Base DN too long: line",
+					linenum, filename);
+                                    return(-1);
+				}
+				/*
+				 * The base DN can be NULL, but must be
+				 * specified in the certificate server
+				 * list by the "null" keyword.
+				 */
+				if (strcasecmp(cert_server_buffer.base_dn,
+						"NULL") == 0) {
+				    cert_server_buffer.base_dn[0] = '\0';
+				} else {
+				   /* A valid DN has an '=' in it (RFC2253). */
+				   if ((ptr = strchr(cert_server_buffer.base_dn,
+						      '=')) == NULL) {
+				        syslog(LOG_INFO,
+					    "[error] %.64s %d: %.900s\n",
+					    "Base DN value is invalid in line",
+					    linenum, filename);
+				        return(-1);
+				    }
+				}
+                                break;
+                            case 4:
+				/* Email address attribute name */
+				if (len < MAX_LINE) {
+				    strncpy(cert_server_buffer.mail_attr,
+				        &linebuff[offset], len + 1);
+				} else {
+				    syslog(LOG_INFO,
+ 					"[error] %.64s %d: %.900s\n",
+					"Email attribute too long in line",
+					linenum, filename);
+                                    return(-1);
+                                }
+				break;
+                            case 5:
+				/* person name attribute name */
+				if (len < MAX_LINE) {
+				    strncpy(cert_server_buffer.personname_attr,
+				        &linebuff[offset], len + 1);
+				} else {
+				    syslog(LOG_INFO,
+				       "[error] %.64s %d: %.900s\n",
+				       "Person name attribute too long in line",
+				       linenum, filename);
+                                    return(-1);
+                                }
+				break;
+			    case 6:
+				/* Certificate attribute name */
+				ptr = strstr(&linebuff[offset], ";binary");
+				if (ptr != NULL) {
+				    /* Strip off binary tag. */
+				    len = (int)(ptr - &linebuff[offset]);
+				    if (getcert_shared->debugging &
+					    DEBUG_GEN_LO) {
+					syslog(LOG_DEBUG,
+					  "[debug] Line %d: %.32s %.32s\n",
+					  linenum,
+					  "Stripping binary tag from",
+					  "certificate attribute name.");
+				    }
+				}
+				if ((len >= MAX_LINE) ||
+				    (len > MAX_ATTRIBUTE_NAME + 7)) {
+				    syslog(LOG_INFO,
+				       "[error] %.64s %d: %.900s\n",
+				       "Certificate attribute too long in line",
+				       linenum, filename);
+				    return(-1);
+				}
+				strncpy(cert_server_buffer.cert_attr,
+					&linebuff[offset], len + 1);
+				cert_server_buffer.cert_attr[len] = '\0';
+                                break;
+                            case 7:
+				/* Bind DN */
+				if (len < MAX_LINE) {
+                                    strncpy(cert_server_buffer.bind_dn,
+				        &linebuff[offset], len + 1);
+				} else {
+				    syslog(LOG_INFO,
+					"[error] %.64s %d: %.900s\n",
+					"Bind DN is too long in line",
+					linenum, filename);
+                                    return(-1);
+                                }
+                                break;
+                            case 8:
+				/* Bind password */
+				if (len < MAX_LINE) {
+				    strncpy(cert_server_buffer.bind_password,
+                                            &linebuff[offset], len + 1);
+				} else {
+				    syslog(LOG_INFO,
+					"[error] %.64s %d: %.900s\n",
+					"Bind password is too long in line",
+					 linenum, filename);
+                                    return(-1);
+                                }
+                                break;
+                        }
+                        server_attribute++;
+                    }
+                }
+            }
+        }
+    } while (recsize != EOF);
+    if (infile != NULL)
+        fclose(infile);
+
+    /* Terminate the certificate server list */
+    server_list_ptr[server_count] = NULL;
+
+    if (getcert_shared->debugging & DEBUG_GEN_HI)
+	syslog(LOG_DEBUG,
+	    "[debug] Read in %d servers from %.900s\n", server_count, filename);
+    return(server_count);
+} /* read_cert_serverlist */
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/read_ldap_serverlist.c openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/read_ldap_serverlist.c
--- openldap-2.3.41-clean/servers/slapd/back-getcert/read_ldap_serverlist.c	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/read_ldap_serverlist.c	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,395 @@
+/*  read_ldap_serverlist.c  version 3.4   4/28/2006  */
+/*
+ *  This is the read_ldap_serverlist.c file for use by the getcert SLAPD
+ *  backend.  It reads in the ldap_server_list.txt file on start up and
+ *  creates an in-memory copy for use by getcert while the LDAP Proxy
+ *  is running.
+ *  Marc Amis	(marc.amis@boeing.com)
+ * 
+ *  Format of ldap_server_list.txt entries:
+ *
+ *       1) Base DN for LDAP search
+ *       2) LDAP server FQDN or IP address
+ *       3) LDAP port number
+ *       4) Attribute name (i.e., "certificateRevocationList")
+ *       5) Verify type ("crl", "cert", or "none")
+ *       5) Bind DN (if required)
+ *       6) Bind password (if required)
+ *
+ *       The first four items are required.
+ *       Comments have '#' in column one.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "portable.h"
+#include "slap.h"
+#include "proto-getcert.h"
+#include "getcert.h"
+
+extern get_line(char s[], int lim);
+
+/*
+ * Allocate memory and store one ldap server structure.
+ */
+int
+store_ldap_server(be, server_number, server_list_ptr)
+    Backend     *be;
+    int server_number;
+    struct ldap_server **server_list_ptr;
+{
+    struct ldap_server *blockptr;
+    int    structsize;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    structsize = sizeof(struct ldap_server);
+    if (getcert_shared->debugging & DEBUG_MEM)
+	syslog(LOG_DEBUG,
+	   "[debug] Allocating %d bytes of memory %.64s %d.\n",
+	   structsize, "for LDAP server chain link", server_number);
+    blockptr = malloc(structsize);
+    if (blockptr == NULL) {
+	syslog(LOG_INFO,
+	    "[error] Not enough memory for ldap server list.\n");
+        release_ldap_server_list(be, server_list_ptr);
+        return(1);
+    }
+
+    /*
+     * Copy server info from buffer into this memory block.
+     * It's not possible to overflow the block copy as the
+     * target memory block as allocated is the same size as
+     * the source buffer.
+     */
+    strncpy(blockptr->ldap_dn, ldap_server_buffer.ldap_dn,
+	strlen(ldap_server_buffer.ldap_dn) + 1);
+    strncpy(blockptr->server_name, ldap_server_buffer.server_name,
+	strlen(ldap_server_buffer.server_name) + 1);
+    blockptr->port = ldap_server_buffer.port;
+    blockptr->verification = ldap_server_buffer.verification;
+    strncpy(blockptr->ldap_attr, ldap_server_buffer.ldap_attr,
+	strlen(ldap_server_buffer.ldap_attr) + 1);
+    if (ldap_server_buffer.bind_dn[0] == '\0')
+        blockptr->bind_dn[0] = '\0';
+    else
+        strncpy(blockptr->bind_dn, ldap_server_buffer.bind_dn,
+	    strlen(ldap_server_buffer.bind_dn) + 1);
+    if (ldap_server_buffer.bind_password[0] == '\0')
+        blockptr->bind_password[0] = '\0';
+    else
+        strncpy(blockptr->bind_password, ldap_server_buffer.bind_password,
+	    strlen(ldap_server_buffer.bind_password) + 1);
+
+    server_list_ptr[server_number] = blockptr;
+
+    return(0);
+} /* store_ldap_server */
+
+/*
+ *  Release all memory allocated for server chain.
+ */
+release_ldap_server_list(be, server_list_ptr)
+    Backend     *be;
+    struct cert_server **server_list_ptr;
+{
+    int  i;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    for (i = 0; i < server_count; i++) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+	        "[debug] %.900s\n",
+		"Releasing memory allocated for LDAP server chain link.");
+        free(server_list_ptr[i]);
+    }
+    return;
+} /* release_ldap_server_list */
+
+/*
+ *  Read in the ldap server list from filename and
+ *  return an in-memory ldap_server structure list.
+ *  Return Code:
+ *      Success = Return number of servers in the list.
+ *      Failure = Return -1
+ */
+int
+read_ldap_serverlist(be, filename, server_list_ptr)
+    Backend     *be;
+    char	*filename;
+    struct ldap_server **server_list_ptr;
+{
+    int  len, offset, recsize, server_attribute;
+    char *ptr;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    /* Open the server list file */
+    if ((infile = fopen(filename, "r")) == NULL) {
+	syslog(LOG_INFO,
+	    "[error] Cannot open ldap server list file %.900s\n", filename);
+	return(-1);
+    }
+
+    /* Build a new server list in memory. */
+    linenum = 0;
+    server_count = 0;
+    server_attribute = 0;
+    do {
+        recsize = get_line(linebuff, MAX_LINE);
+	if (recsize == EOF) {
+	    if (getcert_shared->debugging & DEBUG_GEN_LO)
+		syslog(LOG_DEBUG, "[debug] EOF at line %d\n", linenum);
+	    fclose(infile);
+	    infile = NULL;
+	}
+	if ((recsize == EOF) && (server_attribute < 4)) {
+	    if (server_count < 1) {
+		release_ldap_server_list(be, server_list_ptr);
+		syslog(LOG_INFO,
+		    "[error] No servers in ldap server list %.900s\n",
+		    filename);
+		return(-1);
+	    }
+	    if ((server_attribute > 0) && (server_attribute < 4)) {
+	        /* Last server in list is too short. */
+		if (getcert_shared->debugging & DEBUG_GEN_HI)
+		    syslog(LOG_DEBUG,
+		        "[debug] Last server_attribute is %d\n",
+			server_attribute);
+		release_ldap_server_list(be, server_list_ptr);
+		syslog(LOG_INFO,
+		    "[error] Last ldap server entry is too short in %.900s\n",
+		    filename);
+		return(-1);
+	    } else {
+		if (server_attribute > 0) {
+		    /* Set default values for unspecified attrs. */
+		    switch (server_attribute) {
+		        case 4:
+			    ldap_server_buffer.verification = NONE;
+		        case 5:
+			    ldap_server_buffer.bind_dn[0] = '\0';	
+			case 6:
+			    ldap_server_buffer.bind_password[0] = '\0';
+			    break;
+		    }
+		    if (store_ldap_server(be, server_count, server_list_ptr) != 0)
+		        return(-1);
+		    else
+			server_count++;
+		}
+	    }
+	} else {
+	    /* Comment line? */
+	    if (linebuff[0] != '#') {
+                offset = 0;
+                /* Blank line? */
+		while (((linebuff[offset] == BLANK) ||
+			(linebuff[offset] == TAB)) &&
+		       (offset < MAX_LINE))
+                    offset++;
+                if ((offset > MAX_LINE) ||
+                    (linebuff[offset] == '\n') ||
+                    (linebuff[offset] == '\0')) {
+                    /* This is a blank line. */
+		    /* Are we finished with this server definition? */
+                    if ((server_attribute > 0) && (server_attribute < 4)) {
+                        /* We're lost in the ldap server list file. */
+			syslog(LOG_INFO,
+			   "[error] %.64s %d in ldap server list %.900s:\n",
+			   "Syntax error on line", linenum, filename);
+			if (infile != NULL)
+			    fclose(infile);
+			release_ldap_server_list(be, server_list_ptr);
+			return(-1);
+		    } 
+		    if (server_attribute != 0) {
+		        switch (server_attribute) {
+                            case 4:
+				ldap_server_buffer.verification = NONE;
+                            case 5:
+                                ldap_server_buffer.bind_dn[0] = '\0';
+                            case 6:
+                                ldap_server_buffer.bind_password[0] = '\0';
+                                break;
+                        }
+			if (store_ldap_server(be, server_count, server_list_ptr)
+				!= 0)
+			    return(-1);
+			else {
+                            server_count++;
+                            server_attribute = 0;
+			}
+		    }
+		} else {
+		    /* This is a server entry attribute. */
+		    /* Ignore excess attribute entries   */
+                    /* (accept only the first seven).    */
+                    if (server_attribute < 7) {
+		        len = strlen(&linebuff[offset]);
+                        switch (server_attribute) {
+                            case 0:
+				/* Base DN */
+				if (len < MAX_LINE) {
+				    strncpy(ldap_server_buffer.ldap_dn,
+				        &linebuff[offset], len + 1);
+				} else {
+				    syslog(LOG_INFO,
+				    "[error] %.64s %d of server list %.900s\n",
+					"LDAP DN is too long in line",
+					linenum, filename);
+                                    return(-1);
+				}
+                                /* The ldap DN can be NULL, but must be  */
+                                /* specified in the server list by the  */
+                                /* "null" keyword.                      */
+                                if (strcasecmp(ldap_server_buffer.ldap_dn,
+                                                "NULL") == 0) {
+                                    ldap_server_buffer.ldap_dn[0] = '\0';
+                                } else {
+                                    /* A valid DN has an '=' in it (RFC2253). */
+                                    if ((ptr = strchr(ldap_server_buffer.ldap_dn,
+                                                      '=')) == NULL) {
+                                        syslog(LOG_INFO,
+                                            "[error] %.64s %d %32s %.900s\n",
+                                            "Base DN value is invalid in line",
+					    "of ldap server list",
+                                            linenum, filename);
+                                        return(-1);
+                                    }
+                                }
+                                break;
+			    case 1:
+				/* LDAP server FQDN or IP address */
+				if (len < MAX_LINE) {
+                                    strncpy(ldap_server_buffer.server_name,
+                                        &linebuff[offset], len + 1);
+				} else {
+				    syslog(LOG_INFO,
+					"[error] %.64s %d %s %.900s\n",
+					"Server name is too long in line",
+					linenum, "of ldap server list",
+					filename);
+                                    return(-1);
+				}
+                                break;
+                            case 2:
+				/* LDAP port number */
+                                if (isdigit(linebuff[offset]) == 0) {
+                                   fclose(infile);
+				   release_ldap_server_list(be, server_list_ptr);
+				   syslog(LOG_INFO,
+					"[error] %.64s %d %s %.900s\n",
+					"Invalid port number on line",
+					linenum, "in ldap server list",
+					filename);
+                                   return(-1);
+                                } else 
+                                   ldap_server_buffer.port =
+					atoi(&linebuff[offset]);
+                                break;
+                            case 3:
+				/* LDAP attribute name */
+                                if (len < MAX_LINE) {
+                                    strncpy(ldap_server_buffer.ldap_attr,
+                                        &linebuff[offset], len + 1);
+                                } else {
+                                    syslog(LOG_INFO,
+                                        "[error] %.64s %d %s %.900s\n",
+                                        "LDAP attribute name too long in line",
+                                        linenum, "of ldap server list",
+					filename);
+                                    return(-1);
+                                }
+				break;
+                            case 4:
+				/* Verification */
+				if (len < MAX_TYPE_LEN) {
+				    if ((len == 0) ||
+					(strncasecmp(&linebuff[offset],
+						"none", 4) == 0) ||
+					(strncasecmp(&linebuff[offset],
+						"null", 4) == 0)) {
+					ldap_server_buffer.verification = NONE;
+				    } else
+				    if ((strncasecmp(&linebuff[offset],
+						"cert", 4) == 0) ||
+					(strncasecmp(&linebuff[offset],
+					    "certificate", 11) == 0)) {
+					ldap_server_buffer.verification = CERT;
+				    } else
+				    if ((strncasecmp(&linebuff[offset],
+					    "crl", 3) == 0) ||
+					(strncasecmp(&linebuff[offset],
+			"certificaterevocationlist", 25) == 0)) {
+					ldap_server_buffer.verification = CRL;
+				    } else {
+					syslog(LOG_INFO,
+					    "[error] %.64s %d %s %.900s\n",
+					    "Invalid Verify Type in line",
+					    linenum, "of ldap server list",
+					    filename);
+					return(-1); 
+				    } 
+                                } else {
+                                    syslog(LOG_INFO,
+                                        "[error] %.64s %d %s %.900s\n",
+                                        "LDAP attribute name too long in line",
+                                        linenum, "of ldap server list",
+					filename);
+                                    return(-1);
+                                }
+				break;
+                            case 5:
+				/* Bind DN */
+				if (len < MAX_LINE) {
+                                    strncpy(ldap_server_buffer.bind_dn,
+				        &linebuff[offset], len + 1);
+				} else {
+				    syslog(LOG_INFO,
+					"[error] %.64s %d %s %.900s\n",
+					"Bind DN is too long in line",
+					linenum, "of ldap server list",
+					filename);
+                                    return(-1);
+                                }
+                                break;
+                            case 6:
+				/* Bind password */
+				if (len < MAX_LINE) {
+				    strncpy(ldap_server_buffer.bind_password,
+                                            &linebuff[offset], len + 1);
+				} else {
+				    syslog(LOG_INFO,
+					"[error] %.64s %d %s %.900s\n",
+					"Bind password is too long in line",
+					linenum, "of ldap server list",
+					filename);
+                                    return(-1);
+                                }
+                                break;
+                        }
+                        server_attribute++;
+                    }
+                }
+            }
+        }
+    } while (recsize != EOF);
+    if (infile != NULL)
+        fclose(infile);
+
+    /* Terminate the server list */
+    server_list_ptr[server_count] = NULL;
+
+    if (getcert_shared->debugging & DEBUG_GEN_HI)
+	syslog(LOG_DEBUG,
+	    "[debug] Read in %d ldap servers from %.900s\n",
+	    server_count, filename);
+    return(server_count);
+} /* read_ldap_serverlist */
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/search.c openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/search.c
--- openldap-2.3.41-clean/servers/slapd/back-getcert/search.c	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/search.c	2008-03-25 12:18:48.000000000 -0400
@@ -0,0 +1,8156 @@
+/* search.c    4.2    August 22, 2007    marc.amis@boeing.com */
+/*
+ *  This is the part of the "getcert" backend to 
+ *  SLAPD that processes LDAP search requests.
+ *
+ *  This routine services LDAP search commands issued by an LDAP client
+ *  and passed along to this backend subroutine by the OpenLDAP front end.
+ *  We are searching for either public X.509 user certificates matching
+ *  the filter passed in to us of "mail=emailaddress@emaildomain", or we
+ *  are searching for some other LDAP object (CRL, CA certificate, etc.) 
+ *  matching the search DN and attribute name passed to us in the search
+ *  attribute list.
+ *
+ *  If the search filter contains an email address, we assume we are 
+ *  searching for a user certificate from one of the servers listed in
+ *  certificate_server_list.txt.  Otherwise, we are searching for any
+ *  attribute listed in the search attribute list that match an
+ *  attribute name and BaseDN listed in ldap_server_lists.txt.
+ *
+ *	Marc Amis      The Boeing Company       marc.amis@boeing.com
+ */
+
+/* Set editor column width to 100. */
+
+#define LDAP_DEPRECATED 1
+#include "portable.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <string.h>
+#include <unistd.h>
+#include <ctype.h>
+#ifdef HAVE_PATHFINDER
+#include <libpathfinder.h>
+#endif
+#include "lber.h"
+#include "ldap.h"
+#include "slap.h"
+#include "proto-getcert.h"
+#include "getcert.h"
+
+/*
+ *  certificate_server_list.txt
+ *
+ *       The getcert program uses the LDAPSERVER_LIST file to
+ *	 look up LDAP certificate servers based on email domain 
+ *	 names.  Each server entry is listed as seven or nine
+ *	 lines with each server entry separated by a blank line. 
+ *
+ *       1) Email domain name (or "*" to match any email domain)
+ *       2) LDAP server fully qualified domain name or IP address
+ *       3) LDAP port number (default 389)
+ *       4) Base DN for certificate search (or "null" if none needed)
+ *	 5) Name of email address attribute (default "mail")
+ *	 6) Name of person name attribute (default "cn")
+ *	 7) Certificate attribute name (default "userCertificate")
+ *       8) Bind DN (if required)
+ *       9) Bind password (if required)
+ *
+ *       The first seven items are required.
+ *       Comments have '#' in column one.
+ *
+ *  # Example entry:
+ *  #
+ *  boeing.com
+ *  preprod.ca.boeing.com
+ *  389
+ *  ou=People,o=Boeing,c=US
+ *  mail
+ *  boeingDisplayName
+ *  userCertificate
+ *  boeingAppCn=ldap-test,ou=applications,o=Boeing,c=US
+ *  password
+ */
+
+/*
+ * ldap_server_list.txt
+ *
+ *       The ldap_proxy service uses this file to look up
+ *       LDAP servers based on Base DN (or Search DN).
+ *       Each server entry is listed as either four or six lines
+ *       with each server entry separated by a blank line.
+ *
+ *       1) Base DN for LDAP search
+ *       2) LDAP server FQDN or IP address
+ *       3) LDAP port number
+ *       4) Attribute name (i.e., "certificateRevocationList")
+ *	 5) Verify Type ("crl", "cert", or "none")
+ *       6) Bind DN (if required)
+ *       7) Bind password (if required)
+ *
+ *       The first five items are required.
+ *       Comments have '#' in column one.
+ *
+ *  # Example entry:
+ *  #
+ *  DC=nw,DC=nos,DC=boeing,DC=com
+ *  adc-nw-26.nw.nos.boeing.com
+ *  389
+ *  certificateRevocationList
+ *  crl
+ *  AccessID
+ *  password
+ */
+
+/*******************
+ *******************
+ **               **
+ **  SUBROUTINES  **
+ **               **
+ *******************
+ *******************/
+
+/*
+ *  Function prototypes
+ */
+extern int strcasecmp(
+	const char *s1,
+	const char *s2);
+extern int strncasecmp(
+	const char *s1,
+	const char *s2,
+	size_t n);
+extern struct tm *gmtime_r(
+	const time_t *timep,
+	struct tm *result);
+extern int sprintf(
+	char *str,
+	const char *format,
+	...);
+extern int snprintf(
+	char *str,
+	size_t size,
+	const char *format,
+	...);
+int base64_encode(
+	Backend *be,
+	Connection *conn,
+	struct getcert_private *priv,
+	char *binStr,
+	unsigned length,
+	char *destination,
+	unsigned maxout); 
+int hextobin(
+	int digit);
+int unhexify(
+	Backend *be,
+	Connection *conn,
+	struct getcert_private *priv,
+	int cert_num);
+enum ifilter_types filter_by_issuer(
+	Backend  *be,
+	Connection  *conn,
+	struct getcert_private  *priv);
+int filter_by_keyusage(
+	Backend  *be,
+	Connection  *conn,
+	struct getcert_private  *priv);
+int cert_validity_checking(
+	Backend *be,
+	Connection *conn,
+	struct getcert_private *priv,
+	int this_cert,
+	char *mailaddr);
+int get_certificates(
+	Backend *be, 
+        Connection *conn, 
+        struct getcert_private *priv,
+	LDAP *ld,
+	LDAPMessage *entry,
+	char *attr,
+	char *mailaddr,
+	int valid_certs);
+int get_mail_filter(
+	Backend *be,
+        Connection *conn,
+        struct berval  *filterstr,
+	struct getcert_private *priv);
+int search_cert_server_list(
+        Backend  *be,
+        Connection  *conn,
+        char  *edomain,
+        int  server_index);
+int search_ldap_server_list(
+        Backend  *be,
+        Connection  *conn,
+        struct berval  *base,
+        AttributeName  *attrs,
+        int  server_index);
+int verify_email_addr(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv,
+        char  *mailaddr);
+void release_rfc822Name_chain(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv);
+void release_certificate_buffers(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv);
+int add_pending_query(
+        Backend  *be,
+        Connection  *conn,
+        struct berval  *filterstr,
+        struct berval  *base,
+        struct getcert_private   *priv);
+void remove_pending_query(
+        Backend  *be,
+        Connection  *conn);
+int check_pending_queries(
+        Backend  *be,
+        Connection  *conn,
+        Operation  *op,
+        struct berval  *filterstr,
+        struct berval  *base,
+        struct getcert_private  *priv,
+        SlapReply *rs);
+void search_failed(
+        Backend  *be,
+        Connection  *conn,
+        int  search_rc,
+	char  *server_name,
+        LDAPMessage  *result);
+int compare_ldap_attr_names(
+        Backend  *be,
+        Connection  *conn,
+        AttributeName  *attrs,
+        int  attr_list_index,
+        int  ldap_list_index);
+void find_certificate(
+        Backend  *be,
+        Connection  *conn,
+        Operation  *op,	
+        struct berval  *base,
+        struct berval  *nbase,
+        struct berval  *filterstr,
+        AttributeName  *attrs,
+        int  attrsonly,
+        struct getcert_private  *priv,
+        SlapReply *rs);
+void find_object(
+        Backend  *be,
+        Connection  *conn,
+        Operation  *op,	
+        struct berval  *base,
+        struct berval  *nbase,
+        struct berval  *filterstr,
+        AttributeName  *attrs,
+        int  attrsonly,
+        struct getcert_private  *priv,
+        SlapReply *rs);
+void find_all(
+        Backend  *be,
+        Connection  *conn,
+        Operation  *op,	
+        struct berval  *base,
+        struct berval  *nbase,
+        struct berval  *filterstr,
+        AttributeName  *attrs,
+        int  attrsonly,
+        struct getcert_private  *priv,
+        SlapReply *rs);
+int send_search_results(
+        Backend  *be,
+        Connection  *conn,
+        Operation  *op,
+        AttributeName  *attrs,
+        int  attrsonly,
+        char  *ldif_data,
+        char  *returned_ndn,
+        SlapReply *rs);
+int decodecert_get_octet(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv);
+int decodecert_get_identifier(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv);
+unsigned decodecert_get_length(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private   *priv);
+int decodecert_get_content(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private   *priv,
+        unsigned  length);
+int decodecert_get_integer(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv,
+        int  length);
+int decodecert_get_oid(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv,
+        int  oidlength);
+unsigned long decodecert_get_bitstring(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv,
+        int  bitlen);
+int decodecert_get_serial_number(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv);
+int decodecert_check_time(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv,
+        char *utc_string);
+int decodecert_get_dn(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv,
+        int section_length);
+int decodecert_read_extensions(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv);
+int decodecert_read_keyUsage(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv,
+        int  end_of_object);
+int decodecert_read_subjectAltName(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private   *priv,
+        int  end_of_object);
+int decodecert_read_ns_certtype(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv);
+void decodecert_error(
+        Backend     *be,
+        Connection  *conn,
+        struct getcert_private  *priv,
+        char *debug_msg);
+int decode_certificate(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv);
+int decodecrl_revoked(
+        Backend     *be,
+        Connection  *conn,
+        struct getcert_private  *priv,
+        int  list_length,
+        int  cert_length);
+int decode_crl(
+        Backend  *be,
+        Connection  *conn,
+        struct getcert_private  *priv);
+
+/*
+ * Encode the given binary string as Base64.
+ * Return the size of the resulting Base64 string.
+ */
+/***********************************************************
+        Copyright 1998 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#define XX 127
+
+/* Note that does not support the line break afer 76 characters */
+/*
+ * Tables for encoding/decoding base64
+ */
+static const char basis_64[] =
+   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+static const char index_64[256] = {
+    XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
+    XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
+    XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,62, XX,XX,XX,63,
+    52,53,54,55, 56,57,58,59, 60,61,XX,XX, XX,XX,XX,XX,
+    XX, 0, 1, 2,  3, 4, 5, 6,  7, 8, 9,10, 11,12,13,14,
+    15,16,17,18, 19,20,21,22, 23,24,25,XX, XX,XX,XX,XX,
+    XX,26,27,28, 29,30,31,32, 33,34,35,36, 37,38,39,40,
+    41,42,43,44, 45,46,47,48, 49,50,51,XX, XX,XX,XX,XX,
+    XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
+    XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
+    XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
+    XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
+    XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
+    XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
+    XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
+    XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
+};
+#define CHAR64(c)  (index_64[(unsigned char)(c)])
+
+int
+base64_encode(
+    Backend	*be,
+    Connection  *conn,
+    struct getcert_private   *priv,
+    char	*binStr,
+    unsigned	len,
+    char	*destination,
+    unsigned	maxout
+    )
+{
+    int buflen = 0;
+    int c1, c2, c3;
+
+    struct getcert_data  *getcert_shared;
+    getcert_shared = be->be_private;
+
+    while (len && (buflen < (maxout - 8))) {
+	
+	c1 = (unsigned char)*binStr++;
+	destination[buflen++] = basis_64[c1>>2];
+
+	if (--len == 0) c2 = 0;
+	else c2 = (unsigned char)*binStr++;
+	destination[buflen++] =
+	    basis_64[((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4)];
+
+	if (len == 0) {
+	    destination[buflen++] = '=';
+	    destination[buflen++] = '=';
+	    break;
+	}
+
+	if (--len == 0) c3 = 0;
+	else c3 = (unsigned char)*binStr++;
+
+	destination[buflen++] =
+	    basis_64[((c2 & 0xF) << 2) | ((c3 & 0xC0) >>6)];
+	if (len == 0) {
+	    destination[buflen++] = '=';
+	    break;
+	}
+
+	--len;
+	destination[buflen++] = basis_64[c3 & 0x3F];
+
+    }
+
+    destination[buflen]=0;
+    return(buflen);
+} /* base64_encode */
+
+/*
+ * Convert an eight bit character from an ASCII representation of
+ * a HEX character to the binary representation of the HEX character.
+ * Input: "0" through "9" and "A" through "F" or "a" through "f"
+ * Output 0x00 through 0x09 and 0x0A through 0x0F
+ */
+int
+hextobin(
+    int  digit
+    )
+{
+    /* 0 thru 9 */
+    if ((digit >= 48) && (digit <= 57))
+        digit -= 48;
+    else /* A thru F */
+	if ((digit >= 65) && (digit <= 70))
+        digit -= 55;
+    else /* a thru f */
+	if ((digit >= 97) && (digit <= 102))
+	digit -= 87;
+    else 
+	return(-1);
+    return(digit);
+} /* hextobin */
+
+/*
+ * Convert the certificate in the content_buffer from ASCII representations
+ * of HEX characters to binary representations of the HEX characters (which
+ * should give us DER format) and store the converted certificate in the
+ * certificate array.
+ * Input: Certificate number.
+ * Output: Length of the converted data in certificate array.
+ */
+int
+unhexify(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private   *priv,
+    int         cert_num
+    )
+{
+    int  ch1, ch2, i, length;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+    i = 0;
+    length = 0;
+    while (i < priv->certificates[cert_num]->cert_der_length) {
+        ch1 = hextobin(priv->content_buffer[i++]);
+        ch1 = ch1 << 4;
+        if (i < priv->certificates[cert_num]->cert_der_length) {
+            ch2 = hextobin(priv->content_buffer[i++]);
+            ch1 = ch1 | ch2;
+        }
+        priv->certificates[cert_num]->der_certificate[length++] = ch1;
+    }
+
+    if (getcert_shared->debugging & DEBUG_GEN_LO) {
+        syslog(LOG_DEBUG,
+            "[%lu][debug] Certificate length change after conversion:\n",
+            conn->c_connid);
+        syslog(LOG_DEBUG,
+            "[%lu][debug]    %d to %d bytes.\n",
+            conn->c_connid, priv->certificates[cert_num]->cert_der_length, length);
+    }
+    priv->certificates[cert_num]->cert_der_length = length;
+    if (getcert_shared->debugging & DEBUG_GEN_LO) {
+        syslog(LOG_DEBUG,
+            "[%lu][debug] Certificate converts to: ", conn->c_connid);
+        for (i = 0; i < 6; i++)
+            syslog(LOG_DEBUG,
+                "[%lu][debug]    0x%2.2x  ",
+                conn->c_connid, priv->certificates[cert_num]->der_certificate[i]);
+    }
+    return(length);
+} /* unhexify */
+
+/*
+ * Decide whether to deliver the current certificate or reject it
+ * based on the cert_issuer_accept or cert_issuer_reject options
+ * defined (or not) in the slapd.conf file.
+ * We do a case-insensitive search for each cert_issuer_* option
+ * value in the Issuer DN from the current certificate.  We then
+ * either accept or reject the certificate based on whether the 
+ * option string was defined as "cert_issuer_accept" or
+ * "cert_issuer_reject".
+ * Return:
+ *	reject_cert 
+ *	accept_cert
+ */
+enum ifilter_types
+filter_by_issuer(
+    Backend	   *be,
+    Connection	   *conn,
+    struct getcert_private   *priv
+)
+{
+    int   filternum, i, len;
+    char  issuer_buffer[MAX_DN_LENGTH];
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    /* Has issuer filtering been configured? */
+    if (getcert_shared->issuer_filter_type == none)
+	/* No filtering requested. */
+	return(accept_cert);
+    switch (getcert_shared->issuer_filter_type) {
+	case none:
+	    /* No filtering requested. */
+	    return(accept_cert);
+	    break;
+	case reject_cert:
+	    if (getcert_shared->debugging & DEBUG_GEN_HI)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] %.256s %.256s\n",
+		    conn->c_connid, "Filtering certificate based on",
+		    "cert_issuer_reject configuration options.");
+	    break;
+	case accept_cert:
+	    if (getcert_shared->debugging & DEBUG_GEN_HI)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] %.256s %.256s\n",
+		    conn->c_connid, "Filtering certificate based on",
+		    "cert_issuer_accept configuration options.");
+	    break;
+    }
+
+    /* Convert the current certificate's Issuer DN to lower case. */
+    len = strlen(priv->current_certificate.issuer);
+    for (i = 0; (i < (MAX_DN_LENGTH - 1)) && (i < len); i++)
+	issuer_buffer[i] = tolower(priv->current_certificate.issuer[i]);
+    issuer_buffer[i] = '\0';
+
+    if (getcert_shared->debugging & DEBUG_GEN_HI)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Issuer DN: %.900s\n", conn->c_connid, issuer_buffer);
+
+    /* Search Issuer DN for each option string value. */
+    filternum = 0;
+    while ((getcert_shared->cert_issuer_filters[filternum] != NULL) &&
+	   (filternum < (MAX_ISSUER_FILTERS - 1))) {
+	if (strstr(issuer_buffer, getcert_shared->cert_issuer_filters[filternum]) != NULL) {
+	    /* A match was found. */
+	    if (getcert_shared->debugging & DEBUG_GEN_HI)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] A match is found with: %.800s\n",
+		    conn->c_connid, getcert_shared->cert_issuer_filters[filternum]);
+	    if (getcert_shared->issuer_filter_type == accept_cert)
+		return(accept_cert);
+	    else {
+		if (getcert_shared->debugging > 0)
+		    syslog(LOG_INFO,
+	    	        "[%lu] This certificate rejected due to %.256s\n",
+	    	        conn->c_connid, "match with cert_issuer_reject configuration option.");
+		return(reject_cert);
+	    }
+	}
+	filternum++;
+    } /* next filter string */
+    /* No matches found. */
+    if (getcert_shared->debugging & DEBUG_GEN_HI)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] No matches found with filtering option values.\n", conn->c_connid);
+    if (getcert_shared->issuer_filter_type == accept_cert) {
+	if (getcert_shared->debugging > 0)
+	    syslog(LOG_INFO,
+	        "[%lu] This certificate rejected due to %.256s\n",
+	        conn->c_connid, "match with cert_issuer_accept configuration option.");
+	return(reject_cert);
+    } else
+	return(accept_cert);
+} /* filter_by_issuer */
+
+/*
+ * If any of the enforce_keyusage options were specified in the 
+ * slapd config file, reject any certificates that do not have
+ * one or more of the keyUsage flags set that were defined by
+ * the enforce_keyusage options.
+ * Return codes:
+ *    0 = accept certificate
+ *   -1 = reject certificate
+ */
+int
+filter_by_keyusage(
+    Backend        *be,
+    Connection     *conn,
+    struct getcert_private   *priv
+)
+{
+    int  rc = 0;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    if ((getcert_shared->enforce_digitalSignature == TRUE) &&
+        (priv->current_certificate.key_usage_digitalSignature == FALSE)) {
+        rc = -1;
+	if (getcert_shared->debugging)
+            syslog(LOG_INFO,
+	        "[%lu] Rejecting certificate per %.128s\n",
+	        conn->c_connid, "enforce_digitalSignature config option.");   
+    }
+    if ((getcert_shared->enforce_nonRepudiation == TRUE) &&
+        (priv->current_certificate.key_usage_nonRepudiation == FALSE)) {
+        rc = -1;
+	if (getcert_shared->debugging)
+            syslog(LOG_INFO,
+	        "[%lu] Rejecting certificate per %.128s\n",
+	        conn->c_connid, "enforce_nonRepudiation config option.");   
+    }
+    if ((getcert_shared->enforce_keyEncipherment == TRUE) &&
+        (priv->current_certificate.key_usage_keyEncipherment == FALSE)) {
+        rc = -1;
+	if (getcert_shared->debugging)
+            syslog(LOG_INFO,
+	        "[%lu] Rejecting certificate per %.128s\n",
+	        conn->c_connid, "enforce_keyEncipherment config option.");   
+    }
+    if ((getcert_shared->enforce_dataEncipherment == TRUE) &&
+        (priv->current_certificate.key_usage_dataEncipherment == FALSE)) {
+        rc = -1;
+	if (getcert_shared->debugging)
+            syslog(LOG_INFO,
+	        "[%lu] Rejecting certificate per %.128s\n",
+	        conn->c_connid, "enforce_dataEncipherment config option.");   
+    }
+    if ((getcert_shared->enforce_keyAgreement == TRUE) &&
+        (priv->current_certificate.key_usage_keyAgreement == FALSE)) {
+        rc = -1;
+	if (getcert_shared->debugging)
+            syslog(LOG_INFO,
+	        "[%lu] Rejecting certificate per %.128s\n",
+	        conn->c_connid, "enforce_keyAgreement config option.");   
+    }
+    if ((getcert_shared->enforce_keyCertSign == TRUE) &&
+        (priv->current_certificate.key_usage_keyCertSign == FALSE)) {
+        rc = -1;
+	if (getcert_shared->debugging)
+            syslog(LOG_INFO,
+	        "[%lu] Rejecting certificate per %.128s\n",
+	        conn->c_connid, "enforce_keyCertSign config option.");   
+    }
+    if ((getcert_shared->enforce_cRLSign == TRUE) &&
+        (priv->current_certificate.key_usage_cRLSign == FALSE)) {
+        rc = -1;
+	if (getcert_shared->debugging)
+            syslog(LOG_INFO,
+	        "[%lu] Rejecting certificate per %.128s\n",
+	        conn->c_connid, "enforce_cRLSign config option.");   
+    }
+    if ((getcert_shared->enforce_encipherOnly == TRUE) &&
+        (priv->current_certificate.key_usage_encipherOnly == FALSE)) {
+        rc = -1;
+	if (getcert_shared->debugging)
+            syslog(LOG_INFO,
+	        "[%lu] Rejecting certificate per %.128s\n",
+	        conn->c_connid, "enforce_encipherOnly config option.");   
+    }
+    if ((getcert_shared->enforce_decipherOnly == TRUE) &&
+        (priv->current_certificate.key_usage_decipherOnly == FALSE)) {
+        rc = -1;
+	if (getcert_shared->debugging)
+            syslog(LOG_INFO,
+	        "[%lu] Rejecting certificate per %.128s\n",
+	        conn->c_connid, "enforce_decipherOnly config option.");   
+    }
+
+    return(rc);
+} /* filter_by_keyusage */
+
+#ifdef HAVE_PATHFINDER
+int cert_pathfinder_checking(Backend *be, Connection *conn,
+                             char *certdata, int len)    
+{
+    char *certdata_str = malloc(len*2 + 1);
+    char *cp = certdata;
+    char *certdata_str_i = certdata_str;
+    char *iend = certdata + len;
+    char *hex = "0123456789ABCDEF";
+    struct getcert_data  *getcert_shared = be->be_private;
+
+    while (cp < iend)
+    {
+        unsigned char ch = *cp++;
+        *certdata_str_i++ = hex[(ch >> 4) & 0xf];
+        *certdata_str_i++ = hex[ch & 0xf];
+    }
+    *certdata_str_i = '\0';
+
+    char *policy = getcert_shared->pf_policy;
+    if (!policy || !strcmp(policy, ""))
+        policy = "2.5.29.32.0";   // anyPolicy
+
+    int initial_explicit_policy = strcmp(policy, "2.5.29.32.0") ? 1 : 0;
+
+    char *errmsg;
+    int validated = pathfinder_dbus_verify(certdata_str, policy,
+                                           initial_explicit_policy,
+                                           0, &errmsg);
+
+
+    free(certdata_str);
+
+    if (!validated)
+        syslog(LOG_INFO, "[%lu] Pathfinder rejects cert: %s\n",
+                         conn->c_connid, errmsg);
+
+    free(errmsg);
+
+    return validated ? 0 : -1;
+}
+#endif
+
+/*
+ * Run validity checks on the information
+ * contained in the current certificate. 
+ * Return:
+ *	-1 = Reject certificate
+ *	 0 = All checks successful
+ */
+int
+cert_validity_checking(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private   *priv,
+    int		this_cert,
+    char	*mailaddr
+    )
+{
+    int		  rc;
+    struct tm	  *utcstruct;
+    time_t	  epoch;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    if (getcert_shared->debugging & DEBUG_GEN_HI)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Doing certificate validity checks.\n", conn->c_connid);
+    /* Check the version number of this    */
+    /* certificate to see if it is usable. */
+    if (getcert_shared->certificate_type > 0) {
+	if (getcert_shared->certificate_type != priv->current_certificate.certversion + 1) {
+	    /* We are not interested in this version of certificate. */
+	    if (getcert_shared->debugging) {
+	        syslog(LOG_INFO,
+		    "[%lu] Rejecting this version %d cert.\n",
+		    conn->c_connid, priv->current_certificate.certversion + 1);
+	        syslog(LOG_INFO,
+		    "[%lu] We want only version %d certs.\n",
+		    conn->c_connid, getcert_shared->certificate_type);
+	    }
+	    return(-1);
+	}
+    }
+
+    /* Today's date & time for validity checking. */
+    epoch = slap_get_time();
+    utcstruct = gmtime_r(&epoch, &priv->current_time);
+    if (utcstruct == NULL) {
+	syslog(LOG_INFO,
+	    "[%lu][error] Cannot get current system time.", conn->c_connid);
+    } else {
+	rc = decodecert_check_time(be, conn, priv,
+	    priv->current_certificate.validity_notbefore);
+	if (rc > 0) {
+	    /* Certificate is premature. */
+	    if (getcert_shared->debugging)
+	        syslog(LOG_INFO,
+		    "[%lu] Certificate %d is premature.\n",
+		    conn->c_connid, this_cert + 1);
+	    return(-1);
+	} else {
+	    rc = decodecert_check_time(be, conn, priv,
+		priv->current_certificate.validity_notafter);
+	    if (rc < 0) {
+		/* Certificate has expired. */
+		if (getcert_shared->debugging)
+		    syslog(LOG_INFO,
+		        "[%lu] Certificate %d has expired.\n",
+		        conn->c_connid, this_cert + 1);
+		return(-1);
+	    } else {
+		/* Certificate is within validity window. */
+		if (getcert_shared->debugging & DEBUG_GEN_HI)
+		    syslog(LOG_DEBUG,
+			"[%lu][debug] Certificate %d dates are valid.\n",
+			conn->c_connid, this_cert + 1);
+	    }
+	}
+    }
+
+    /*
+     * Verify the email address.
+     * Reject the cert if email addresses are found in the certificate
+     * but none match the email address from the filter string.
+     */
+    rc = verify_email_addr(be, conn, priv, mailaddr);
+    if (rc < 0) {
+	if (getcert_shared->debugging) {
+	    syslog(LOG_INFO,
+	        "[%lu] %.64s %.64s %d.\n",
+	        conn->c_connid, "Search filter does not match",
+	        "email address(es) in certificate", this_cert + 1);
+	    syslog(LOG_INFO,
+	        "[%lu] Certificate %d is rejected.\n",
+	        conn->c_connid, this_cert + 1);
+	}
+	return(-1);
+    }
+    return(0);
+} /* cert_validity_checking */
+
+/*
+ * Extract certificates from a certificate list.  Check them to the degree
+ * specified by the "certificate_check" configurable option and store them
+ * in the global certificates array in DER (binary) format for eventual
+ * conversion to Base64 format and hand-off to the slapd front-end.
+ * We will also use this process to return userSMIMECertificate entries.
+ * No decoding of userSMIMECertificate values takes place, so no
+ * verification is done.
+ * Return: Number of valid userCertificates/userSMIMECertificates found.
+ */
+int
+get_certificates(
+    Backend	   *be,
+    Connection	   *conn,
+    struct getcert_private    *priv,
+    LDAP	   *ld,
+    LDAPMessage    *entry,
+    char	   *attr,
+    char	   *mailaddr,
+    int		   valid_certs
+    )
+{
+    int   cert_num, i, j, len, rc, size, this_cert, local_valid_certs;
+    char  *charptr;
+    struct certlist  *certlistptr;
+    struct berval  **cert_list;
+    struct berval  cert_data;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+    local_valid_certs = 0;
+
+    if (getcert_shared->debugging & DEBUG_GEN_HI)
+        syslog(LOG_DEBUG,
+	    "[%lu][debug] A certificate attribute found: %.900s\n",
+	    conn->c_connid, attr);
+
+    if ((cert_list = ldap_get_values_len(ld, entry, attr)) == NULL) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Releasing memory allocated %.64s\n",
+		conn->c_connid, "for certificate chain.");
+        ldap_value_free_len(cert_list);
+        return(local_valid_certs);
+    } else {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Allocated memory for certificate chain.\n",
+		conn->c_connid);
+    }
+    if (getcert_shared->debugging & DEBUG_GEN_HI) {
+        syslog(LOG_DEBUG,
+	    "[%lu][debug] A certificate list has been retrieved.\n",
+	    conn->c_connid);
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] %d certificate(s) in list.\n",
+	    conn->c_connid, ldap_count_values_len(cert_list));
+    }
+
+    /*
+     * Examine each certificate in the certificate list.
+     */
+    for (this_cert = 0;
+	 ((cert_list[this_cert] != NULL) && (priv->cert_number < getcert_shared->MAX_CERTIFICATES));
+	 this_cert++) {
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] This is certificate number %d\n",
+		conn->c_connid, this_cert + 1 + valid_certs);
+        cert_data = *cert_list[this_cert];
+	if (getcert_shared->debugging & DEBUG_GEN_LO) {
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Certificate %d length is %d\n",
+		conn->c_connid, this_cert + 1 + valid_certs, (int)cert_data.bv_len);
+	}
+	if (cert_data.bv_len <= 0) {
+	    if (getcert_shared->debugging)
+	        syslog(LOG_INFO,
+	            "[%lu][error] Certificate %d is too small to be valid.\n",
+		    conn->c_connid, this_cert + 1 + valid_certs);
+	    continue;
+	}
+
+	/*
+	 * Allocate space for this certificate in the global certificate array.
+	 */
+        cert_num = priv->cert_number;
+	if (cert_num >= getcert_shared->MAX_CERTIFICATES)
+	    break;
+
+	if (priv->certificates[cert_num] != NULL) {
+	    /* Reuse this certificate structure. */
+	    if (priv->certificates[cert_num]->der_certificate != NULL) {
+		/* Release the space used to buffer the rejected certificate. */
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+		        "[%lu][debug] Releasing memory for rejected certificate.\n",
+			conn->c_connid);
+		free(priv->certificates[cert_num]->der_certificate);
+		priv->certificates[cert_num]->der_certificate = NULL;
+	    }
+	} else {
+	    /* Allocate a new structure. */
+	    size = sizeof(struct certlist);
+	    if (getcert_shared->debugging & DEBUG_MEM)
+               syslog(LOG_DEBUG,
+                    "[%lu][debug] Allocating %d bytes of memory for certificate structure.\n",
+		    conn->c_connid, size);
+	    certlistptr = malloc(size);
+	    if (certlistptr == NULL) {
+                syslog(LOG_INFO,
+                    "[%lu][error] Cannot allocate memory for certificate structure.\n",
+		    conn->c_connid);
+	        local_valid_certs = 0;
+	        break;
+	    }
+	    priv->certificates[cert_num] = certlistptr;
+	    priv->certificates[cert_num]->der_certificate = NULL;
+	}
+
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] Allocating %d bytes of memory for certificate %d.\n",
+		conn->c_connid, cert_data.bv_len, this_cert + 1 + valid_certs);
+	charptr = malloc(cert_data.bv_len);
+	if (charptr == NULL) {
+	    syslog(LOG_INFO,
+                "[%lu][error] Cannot allocate memory for certificate.\n", conn->c_connid);
+	    if (getcert_shared->debugging & DEBUG_MEM)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] Releasing memory for certificate structure.\n", conn->c_connid);
+	    free(priv->certificates[cert_num]);
+	    priv->certificates[cert_num] = NULL;
+	    local_valid_certs = 0;
+	    break;
+	}
+
+	if ((cert_num + 1) < getcert_shared->MAX_CERTIFICATES)
+	    priv->certificates[cert_num + 1] = NULL;
+
+	/* Store a copy of the certificate. */
+	if (getcert_shared->debugging & DEBUG_GEN_LO)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Buffering cert %d in cert array slot %d.\n",
+	        conn->c_connid, this_cert + 1 + valid_certs, cert_num);
+	priv->certificates[cert_num]->der_certificate = charptr;
+        for (i = 0; i < cert_data.bv_len; i++)
+            priv->certificates[cert_num]->der_certificate[i] = cert_data.bv_val[i];
+	priv->certificates[cert_num]->b64_certificate = NULL;
+	priv->certificates[cert_num]->cert_der_length = cert_data.bv_len;
+	priv->certificates[cert_num]->cert_b64_length = 0;
+	priv->certificates[cert_num]->cert_attribute[0] = '\0';
+
+	/*
+	 * If the "search_all_servers" option is set, we may already have fetched
+	 * a copy of this certificate from a previously searched server.
+	 * Since we may not be decoding the certificates (based on the
+	 * "certificate_check" option), the only information about the
+	 * certificates we can compare are the length and binary value.
+	 */
+	for (i = 0; i < cert_num; i++) {
+	    if (cert_data.bv_len == priv->certificates[i]->cert_der_length) {
+	        /* Certificates are the same size. Compare value. */
+	        if (getcert_shared->debugging & DEBUG_GEN_LO)
+		    syslog(LOG_DEBUG,
+		        "[%lu][debug] This certificate has same size as certificate %d.\n",
+		        conn->c_connid, i + 1);
+	        for (j = 0; j < cert_data.bv_len; j++) {
+		    if (cert_data.bv_val[j] != priv->certificates[i]->der_certificate[j]) {
+		        /* Certificates differ. */
+		        break;
+		    }
+	        }
+		if (j >= cert_data.bv_len) {
+	    	    if (getcert_shared->debugging & DEBUG_GEN_HI)
+	            	syslog(LOG_DEBUG,
+		            "[%lu][debug] We already have a copy of this certificate.",
+		            conn->c_connid);
+		    priv->certificates[cert_num]->cert_der_length = 0;
+		    /* Finished cert comparisons */
+		    break;
+	        }
+	    }
+	}
+
+	if (priv->certificates[cert_num]->cert_der_length == 0) {
+	    /* Skip this certificate. */
+	    continue;
+	}
+
+	/*
+	 *  We must attempt to determine what format 
+	 *  the certificate has been stored in. 
+	 */
+	if (getcert_shared->debugging & DEBUG_DATA) {
+	    for (i = 0; i < 6; i++) {
+	        j = 0xFF & (int)(priv->certificates[cert_num]->der_certificate[i]);
+		sprintf(&priv->content_buffer[i * 5], " 0x%2.2x", j);
+	    }
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] Certificate begins with: ", conn->c_connid);
+	    syslog(LOG_DEBUG, 
+		"[%lu][debug]    %.256s\n", conn->c_connid, priv->content_buffer);
+	}
+
+	if ((priv->certificates[cert_num]->der_certificate[0] == 0x30) &&
+	    ((priv->certificates[cert_num]->der_certificate[1] & 0xF0)==0x80)) {
+	    /* Probably ASN.1 binary (DER) format. */
+	    if (getcert_shared->debugging & DEBUG_GEN_HI)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] Certificate %d appears to be stored in DER format.\n",
+		    conn->c_connid, this_cert + 1 + valid_certs);
+	} else 
+	if (strncmp(priv->certificates[cert_num]->der_certificate, "308", 3) == 0) {
+	    /* Probably hexdump format.      */
+	    /* Try to convert to DER format. */
+	    if (priv->certificates[cert_num]->cert_der_length > MAX_CONTENT) {
+		syslog(LOG_INFO,
+                   "[%lu][error] Certificate %d is too large to process.\n",
+		   conn->c_connid, this_cert + 1 + valid_certs);
+		priv->certificates[cert_num]->cert_der_length = 0;
+		/* Next certificate */
+		continue;
+	    } else {
+		/* Move certificate to content_buffer */
+		for (i = 0; i < priv->certificates[cert_num]->cert_der_length; i++)
+		    priv->content_buffer[i] = priv->certificates[cert_num]->der_certificate[i];
+                /* Convert certificate to DER format. */ 
+                len = unhexify(be, conn, priv, cert_num);
+	    } 
+        } else
+        if (strncasecmp(priv->certificates[cert_num]->der_certificate, "{ASN}308", 8) == 0) {
+            /* Probably hexdump format.  Strip the ASN tag  */
+            /* and move certificate to the content_buffer.  */
+            if (priv->certificates[cert_num]->cert_der_length > MAX_CONTENT) {
+                syslog(LOG_INFO,
+                   "[%lu][error] Certificate %d is too large to process.\n",
+                   conn->c_connid, this_cert + 1 + valid_certs);
+                priv->certificates[cert_num]->cert_der_length = 0;
+                /* Next certificate */
+                continue;
+            } else {
+                priv->certificates[cert_num]->cert_der_length -= 5;
+                for (i = 0; i < (priv->certificates[cert_num]->cert_der_length); i++)
+                    priv->content_buffer[i] = priv->certificates[cert_num]->der_certificate[i + 5];
+                /* Convert certificate to DER format. */
+                len = unhexify(be, conn, priv, cert_num);
+            }
+	} else {
+	    if (strcasecmp(attr, "userSMIMECertificate") != 0) {
+	        syslog(LOG_INFO,
+		   "[%lu][error] Cannot determine encoding of certificate %d\n",
+		   conn->c_connid, this_cert + 1 + valid_certs);
+		priv->certificates[cert_num]->cert_der_length = 0;
+		/* Next certificate */
+		continue;
+	    }
+	}
+
+	/*
+	 * Attribute userSMIMECertificate holds the entire cert
+	 * trust chain rather than just a single user certificate.
+	 * So don't try to decode it as a single certificate.
+	 */
+	if ((getcert_shared->certificate_check > 0) &&
+	    (strcasecmp(attr, "userSMIMECertificate") != 0)) {
+	    /*
+	     * Decode this certificate so we can perform
+	     * validity checks and certificate filtering.
+	     */
+	    if (getcert_shared->debugging & DEBUG_GEN_HI)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] Decoding certificate %d.\n",
+		    conn->c_connid, this_cert + 1 + valid_certs);
+	    if (decode_certificate(be, conn, priv) >= 0) {
+		if (getcert_shared->certificate_check > 1) {
+		    rc = cert_validity_checking(be, conn, priv, this_cert + valid_certs, mailaddr);
+		    if (rc < 0) {
+		        /* Certificate failed validity checks. */
+	    	        priv->certificates[cert_num]->cert_der_length = 0;
+		    }
+#ifdef HAVE_PATHFINDER
+                    if (getcert_shared->use_pathfinder == TRUE)
+                    {
+                        rc = cert_pathfinder_checking(be, conn,
+                                priv->certificates[cert_num]->der_certificate,
+                                priv->certificates[cert_num]->cert_der_length);
+                        if (rc < 0) {
+                            /* Certificate pathfinder check failed. */
+                            priv->certificates[cert_num]->cert_der_length = 0;
+                        }
+                    }
+#endif
+		} else {
+		    if (getcert_shared->debugging & DEBUG_GEN_HI)
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] Skipping certificate validity checks.\n",
+			    conn->c_connid);
+		}
+
+		/*
+		 * Filter certificates based on certificate Issuer.
+		 */
+		if ((getcert_shared->issuer_filter_type != none) &&
+		    (priv->certificates[cert_num]->cert_der_length > 0))
+		    if (filter_by_issuer(be, conn, priv) == reject_cert)
+			priv->certificates[cert_num]->cert_der_length = 0;
+
+		/*
+		 * Filter certificates based on keyUsage if
+		 * "enforce_keyusage options were specified
+		 * in the slapd config file.
+		 */
+		if (filter_by_keyusage(be, conn, priv) < 0) 
+		    /* This certificate was rejected. */
+		    priv->certificates[cert_num]->cert_der_length = 0;
+	    } else {
+		/* We can't decode this certificate.  */
+		syslog(LOG_INFO,
+		    "[%lu][error] Cannot read certificate %d\n",
+		    conn->c_connid, this_cert + 1 + valid_certs);
+		priv->certificates[cert_num]->cert_der_length = 0;
+	    }
+	    /* Release any allocated memory   */
+	    /* used for the rfc822Name chain. */
+	    release_rfc822Name_chain(be, conn, priv);
+	} else {
+	    if (getcert_shared->debugging & DEBUG_GEN_HI)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] Skipping certificate decoding.\n", conn->c_connid);
+	}
+
+	if (priv->certificates[cert_num]->cert_der_length > 0) {
+	    /* Save the certificate's LDAP attribute name; */
+	    /* typically userCertificate.		       */
+	    len = strlen(attr);
+	    if (len < MAX_ATTRIBUTE_NAME)
+	        strncpy(priv->certificates[cert_num]->cert_attribute, attr, len + 1);
+	    else
+		strncpy(priv->certificates[cert_num]->cert_attribute, attr, MAX_ATTRIBUTE_NAME);
+	    if (getcert_shared->debugging & DEBUG_GEN_HI)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] Cert has attribute type of %.900s\n",
+		    conn->c_connid, priv->certificates[cert_num]->cert_attribute);
+	    if (priv->certificates[cert_num]->cert_der_length > 0)
+		local_valid_certs++;
+            priv->cert_number++;
+	}
+	priv->certificates[cert_num]->cert_b64_length = 0;
+    } /* next cert */
+
+    /* Free up any unused certificate structure. */
+    if ((priv->certificates[priv->cert_number] != NULL) && 
+	(priv->certificates[priv->cert_number]->cert_der_length == 0)) {
+        if (getcert_shared->debugging & DEBUG_MEM)
+            syslog(LOG_DEBUG,
+	        "[%lu][debug] Releasing memory for certificate %d.\n",
+	        conn->c_connid, this_cert + 1 + valid_certs);
+        free(priv->certificates[priv->cert_number]->der_certificate);
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] Releasing memory for certificate structure.\n",
+	        conn->c_connid);
+	free(priv->certificates[priv->cert_number]);
+	priv->certificates[priv->cert_number] = NULL;
+    }
+
+    /* Free up the certificate chain. */
+    if (getcert_shared->debugging & DEBUG_MEM)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Releasing memory allocated for certificate chain.\n",
+	    conn->c_connid);
+    ldap_value_free_len(cert_list);
+    return(local_valid_certs);
+} /* get_certificates */
+
+/*
+ *  Isolate an email address filter from the full 
+ *  filter string and return it in global "mailfilter".
+ *  Email filter is "(mail=user.name@host.domain)".
+ *  [Other possible (but unused here) attributes besides mail:
+ *	rfc822Mailbox, otherMailbox]
+ */
+int
+get_mail_filter(
+    Backend     *be,
+    Connection  *conn,
+    struct berval  *filterstr,
+    struct getcert_private *priv
+    )
+{
+    int  i, j, len;
+    char full_filter[MAX_FILTER_LEN], *ptr, *nextptr;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    if (filterstr->bv_len < MAX_FILTER_LEN) {
+	strncpy(full_filter, filterstr->bv_val, filterstr->bv_len);
+	full_filter[filterstr->bv_len] = '\0';
+    } else {
+	strncpy(full_filter, filterstr->bv_val, MAX_FILTER_LEN - 1);
+	full_filter[MAX_FILTER_LEN - 1] = '\0';
+    }
+
+    if (getcert_shared->debugging & DEBUG_GEN_HI)
+        syslog(LOG_DEBUG,
+	    "[%lu] Full input filter is: %.512s\n",
+	    conn->c_connid, full_filter);
+
+    /* Any email filter strings at all? */
+    if ((nextptr = strstr(full_filter, "mail=")) == NULL)
+	return(-1);
+
+    /* Find the first fully defined email filter string in full_filter. */
+    priv->mailfilter[0] = '\0';
+
+    while ((nextptr != NULL) && (strncmp(priv->mailfilter, "(mail=", 6) != 0)) {
+	/* email filter string must be enclosed in parens. */
+	if ((ptr = strchr(nextptr, ')')) != NULL) {
+	    len = (int)(ptr - nextptr);
+	    if ((len + 6 + 1) > MAX_FILTER_LEN) {
+		syslog(LOG_INFO,
+		    "[%lu][error] Filter string too long to be an email address.\n",
+		    conn->c_connid);
+	    } else {
+	        strncpy(priv->mailfilter, nextptr, len);
+		priv->mailfilter[len] = '\0';
+	        if (getcert_shared->debugging & DEBUG_GEN_HI)
+		    syslog(LOG_DEBUG,
+			"[%lu][debug] Potential email filter string: %.900s\n",
+			conn->c_connid, priv->mailfilter);
+	            
+                /* Strip out wildcards, angle brackets and double quotes.  */
+		/* Terminate string at the first embedded space character. */
+                for (i = 0; priv->mailfilter[i] != '\0'; i++) {
+		    if (priv->mailfilter[i] == ' ') {
+			priv->mailfilter[i] = '\0';
+			break;
+		    } else
+                    if ((priv->mailfilter[i] == '*') ||
+                        (priv->mailfilter[i] == '<') ||
+                        (priv->mailfilter[i] == '>') ||
+                        (priv->mailfilter[i] == '\"')) {
+                        for (j = i; priv->mailfilter[j] != '\0'; j++)
+                            priv->mailfilter[j] = priv->mailfilter[j+1];
+			priv->mailfilter[j] = '\0';
+		    }
+                }
+
+		/* Strip out enclosing single-quotes. */
+		if (priv->mailfilter[5] == '\'') {
+		    for (j = 5; priv->mailfilter[j] != '\0'; j++)
+			priv->mailfilter[j] = priv->mailfilter[j+1];
+		    priv->mailfilter[j] = '\0';
+		}
+		len = strlen(priv->mailfilter);
+		if (priv->mailfilter[len - 1] == '\'') {
+		    priv->mailfilter[len - 1] = '\0';
+		}
+
+    	        /*
+	         * Do some quick-n-dirty syntax checks.
+	         */
+	    
+	        /* Is the filter long enough to be valid? */
+		len = strlen(priv->mailfilter);
+	        if (len < MIN_FILTER_LEN) {
+		    if (getcert_shared->debugging & DEBUG_GEN_HI) 
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] %.128s\n", conn->c_connid,
+			    "Email filter string too short to be valid.");
+	        } else
+		/* Email address must contain an at sign. */
+	        if (strchr(priv->mailfilter, '@') == NULL) {
+		    if (getcert_shared->debugging & DEBUG_GEN_HI)
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] Email filter contains no @ char.\n",
+			    conn->c_connid);
+	        } else
+		/* Email address must contain at least two mail domains. */
+	        if (strchr(priv->mailfilter, '.') == NULL) {
+		    if (getcert_shared->debugging & DEBUG_GEN_HI)
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] Email filter contains no dots.\n",
+			    conn->c_connid);
+		} else
+		/* Email address must contain a LHS */
+		/* and a RHS around the at sign.    */
+		if (strstr(priv->mailfilter, "=@") != NULL) {
+		    if (getcert_shared->debugging & DEBUG_GEN_HI)
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] Email filter contains no LHS.\n",
+			    conn->c_connid);
+		} else
+		if (priv->mailfilter[len - 1] == '@') {
+		    if (getcert_shared->debugging & DEBUG_GEN_HI)
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] Email filter contains no RHS.\n",
+				conn->c_connid);
+	        } else {
+	            /* Limit valid chars to ASCII 041 thru 0176. */
+		    for (i = 0; i < len; i++)
+		        if ((priv->mailfilter[i] < MIN_ASCII) || 
+			    (priv->mailfilter[i] > MAX_ASCII))
+			    break;
+		    if (i == len) {
+		        /* Looks like a valid email address. */
+		        /* Add parens around filter. */
+		        for (i = len; i >= 0; i--)
+		            priv->mailfilter[i + 1] = priv->mailfilter[i];
+		        priv->mailfilter[0] = '(';
+		        priv->mailfilter[len + 1] = ')';
+		        priv->mailfilter[len + 2] = '\0';
+		    } else
+		    if (getcert_shared->debugging & DEBUG_GEN_HI)
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] %.128s\n", conn->c_connid,
+			    "Invalid characters in email filter string");
+		} /* Syntax checks */
+	    } /* Not too long */
+	} /* No close paren */
+	nextptr = strstr(&nextptr[1], "mail=");
+    } /* Examine next potential string */
+    /* Did we find a fully defined email filter? */
+    if (strncmp(priv->mailfilter, "(mail=", 6) == 0) {
+	if (getcert_shared->debugging)
+	    syslog(LOG_INFO,
+	        "[%lu] Mail filter is %.900s\n", conn->c_connid, priv->mailfilter);
+	return(0);
+    } else {
+	if (getcert_shared->debugging)
+	    syslog(LOG_INFO,
+	        "[%lu] No valid email address found.\n", conn->c_connid);
+        return(1);
+    }
+} /* get_mail_filter */
+
+/*  
+ * Search the LDAP server list array for a server that services this 
+ * email domain.  Start searching at "server_index" and return the 
+ * array index of the next server that matches the specified email domain.
+ *
+ * We parse the email domain from left to right so that we 
+ * will find departmental LDAP servers inside an organization's 
+ * network before we match the top-level organization servers.
+ * For example, if the email address specified is:
+ *	   Joe.User@dept_32.richmond.virginia.planecorp.com
+ * we would want to find the "richmond.virginia.planecorp.com"
+ * server before the "planecorp.com" server.
+ * Each server in the server list is checked against all parsed 
+ * email domains for the specified email address before we move
+ * on to the next server in the list.
+ * Return code:
+ * 	Index to next server in cert_server_list with matching 
+ *	email domain, or negative number if no match found.
+ */
+int
+search_cert_server_list(
+    Backend     *be,
+    Connection  *conn,
+    char *edomain,
+    int  server_index
+    )
+{
+    int  i, slength;
+    char *domainptr;
+
+    struct getcert_data  *getcert_shared;
+    getcert_shared = be->be_private;
+
+    domainptr = edomain;
+    /* Poke thru the server list. */
+    if (getcert_shared->debugging & DEBUG_GEN_HI) 
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Searching server list for %.900s\n",
+	    conn->c_connid, domainptr);
+    for (i = 0; cert_server_list[i] != NULL; i++) {
+	if (server_index <= i) {
+	    slength = strlen(cert_server_list[i]->email_domain);
+	    do {
+	        if (getcert_shared->debugging & DEBUG_GEN_LO)
+		    syslog(LOG_DEBUG,
+			"[%lu][debug] Comparing \"%.450s\" and \"%.450s\"\n",
+		        conn->c_connid, domainptr,
+			cert_server_list[i]->email_domain);
+                /* Compare the next part of the email domain with the        */
+                /* domains defined in the server list.  A wildcard character */
+                /* of "*" in the server list matches any email domain.       */
+	        if ((strcmp("*", cert_server_list[i]->email_domain) == 0) ||
+                   (strcasecmp(domainptr,
+			       cert_server_list[i]->email_domain) == 0)) {
+	            return(i);
+	        }
+                /* We know the domain part has at    */
+                /* least one '.' in it (we checked). */
+	        domainptr = strchr(domainptr, '.');
+	        if (domainptr != NULL) {
+	            domainptr++;
+	            if (getcert_shared->debugging & DEBUG_GEN_LO) 
+		        syslog(LOG_DEBUG,
+			    "[%lu][debug] Length of rhs is now %d\n",
+			    conn->c_connid, strlen(domainptr));
+	        }
+	    } while ((domainptr != NULL) &&
+		     ((int)strlen(domainptr) >= slength));
+	    domainptr = edomain;
+	} /* server_index < i */
+    } /* Next server entry */ 
+    /* No server found for this email domain. */
+    return(-1);
+} /* search_cert_server_list */
+
+/*
+ * Search the LDAP server list array for a server that has a base DN that
+ * matches the specified DN pointed at by "base" and an attribute name that
+ * matches an attribute in the attribute list "attrs".  Start searching at
+ * the server whose array index is "server_index" and return the index of
+ * the next matching server, or -1 if no more servers match.
+ */
+int
+search_ldap_server_list(
+    Backend  *be,
+    Connection  *conn,
+    struct berval  *base,
+    AttributeName  *attrs,
+    int  server_index
+    )
+{
+    int  i, j, len;
+    char attrbuff[MAX_ATTRIBUTE_NAME];
+    char  *tagptr;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    /* Was a BaseDN specified? */
+    if (base->bv_len == 0)
+	return(-1);
+
+    if (getcert_shared->debugging & DEBUG_GEN_HI) {
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Searching LDAP server list for:\n", conn->c_connid);
+	syslog(LOG_DEBUG,
+	    "[%lu][debug]    %.*s\n",
+	    conn->c_connid, base->bv_len, base->bv_val);
+    }
+
+    for (i = 0; ldap_server_list[i] != NULL; i++) {
+	if (server_index <= i) {
+	    /* Both DNs of same length? */
+	    if (strlen(ldap_server_list[i]->ldap_dn) == base->bv_len) {
+		/* Same DN? */
+	        if (strncasecmp(ldap_server_list[i]->ldap_dn,
+				base->bv_val, base->bv_len) == 0) {
+		    if (getcert_shared->debugging & DEBUG_GEN_HI)
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] %.900s %d\n", conn->c_connid,
+			    "Found matching DN in LDAP server list entry", i + 1);
+		    /* Did the query specify desired attributes? */
+		    if (attrs == NULL) {
+			/* No search attributes specified.   */
+			/* Check for "all" attributes entry. */
+			if (strncasecmp(ldap_server_list[i]->ldap_attr, "all", 3) == 0)
+			    return(i);
+		    } else {
+			/* An attribute list was specified.             */
+			/* See if any of the desired attributes are an  */
+			/* attribute listed in the LDAP server list.    */
+		        for (j = 0; attrs[j].an_name.bv_val != NULL; j++) {
+			    if (getcert_shared->debugging & DEBUG_GEN_LO)
+	    			syslog(LOG_DEBUG,
+	        		    "[%lu][debug] %.256s %.*s\n",
+				    	conn->c_connid,
+					"Searching LDAP server list for",
+					attrs[j].an_name.bv_len,
+					attrs[j].an_name.bv_val);
+			    if (strncasecmp(attrs[j].an_name.bv_val,
+					    ldap_server_list[i]->ldap_attr,
+					    attrs[j].an_name.bv_len) == 0) {
+		    		if (getcert_shared->debugging & DEBUG_GEN_HI)
+				    syslog(LOG_DEBUG,
+			    		"[%lu][debug] %.64s %.64s %d\n",
+					conn->c_connid,
+			    		"Found matching attribute",
+					"in LDAP server list entry",
+					i + 1);
+		    	        return(i);
+			    }
+			} /* next attr */
+    /*
+     * If the requested attribute is tagged,
+     * try matching without the tag.
+     */
+    for (j = 0; attrs[j].an_name.bv_val != NULL; j++) {
+	if (attrs[j].an_name.bv_len < MAX_ATTRIBUTE_NAME) {
+	    strncpy(attrbuff, attrs[j].an_name.bv_val, attrs[j].an_name.bv_len);
+	    attrbuff[attrs[j].an_name.bv_len] = '\0';
+	    tagptr = strchr(attrbuff, ';');
+	    if (tagptr != NULL) {
+	        tagptr[0] = '\0';
+		if (getcert_shared->debugging & DEBUG_GEN_LO)
+	    	    syslog(LOG_DEBUG,
+	        	"[%lu][debug] %.256s %.512s\n", conn->c_connid,
+			"Searching LDAP server list for", attrbuff);
+		if (strncasecmp(attrbuff, ldap_server_list[i]->ldap_attr,
+				strlen(attrbuff)) == 0) {
+		    if (getcert_shared->debugging & DEBUG_GEN_HI)
+		        syslog(LOG_DEBUG,
+			    "[%lu][debug] %.256s %d\n", conn->c_connid,
+			    "Found matching attribute in LDAP server list entry",
+			    i + 1);
+		    return(i);
+		}
+	    }
+	}
+    } /* next tagged attr */
+
+		    } /* no attrs */
+		}
+	    }
+	}
+    } /* Next server */
+    /* No server found for this DN. */
+    return(-1);
+} /* search_ldap_server_list */
+
+/*
+ * Compare the email address from the search filter with the email
+ * addresses found in the certificate.  Email addresses should be
+ * listed as "rfc822Name" values in the subjectAltName certificate
+ * extension.  But the old, deprecated emailAddress object is still
+ * often found in the Subject section DN.  So we check it as well.
+ * Return codes:
+ *     -1 = Email addr does not match any eaddrs in the certificate. (reject)
+ *      0 = There are no email addrs defined in the certificate. (pass)
+ *      1 = Email addr matches an addr found in the certificate. (pass)
+ */
+int
+verify_email_addr(
+    Backend	   *be,
+    Connection	   *conn,
+    struct getcert_private    *priv,
+    char	   *mailaddr 
+    )
+{
+    int    len, rc;
+    struct getcert_data  *getcert_shared;
+    struct rfc822name_link  *link_ptr;
+
+    getcert_shared = be->be_private;
+
+    /* First we see if there are any email addresses to verify against. */
+    if ((priv->current_certificate.rfc822Name_chain.email_name[0] == '\0') &&
+	(priv->current_certificate.emailAddress[0] == '\0')) {
+	/* No email addresses in this certificate. */
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] %.64s\n", conn->c_connid,
+		"No email addresses defined in this certificate.\n");
+	return(0);
+    }
+
+    /* Verify against any rfc822Name entries found. */
+    link_ptr = &priv->current_certificate.rfc822Name_chain;
+    if (link_ptr->email_name[0] != '\0') {
+        do {
+            if (link_ptr->email_name[0] != '\0') {
+                len = strlen(link_ptr->email_name);
+                if (len < MAX_EMAIL_LENGTH) {
+	            rc = strncasecmp(link_ptr->email_name, mailaddr, len);
+	            if (rc == 0) {
+	                if (getcert_shared->debugging & DEBUG_GEN_HI)
+		            syslog(LOG_DEBUG,
+		                "[%lu][debug] %.64s %.64s\n", conn->c_connid,
+		                "Search filter matches rfc822Name",
+				"in certificate.");
+			return(1);
+	            }
+                }
+            }
+            link_ptr = link_ptr->next_rfc822Name;
+         } while ((link_ptr != NULL) && (rc != 0));
+    } else {
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] %.64s\n", conn->c_connid,
+		"No rfc822Name values in this certificate.\n");
+    }
+
+    /* Either the email address didn't match against the       */
+    /* rfc822Name entries or there were no rfc822Name entries. */
+    /* Verify against the deprecated emailAddress.             */
+    if (priv->current_certificate.emailAddress[0] != '\0') {
+        len = strlen(priv->current_certificate.emailAddress);
+        if (len < MAX_EMAIL_LENGTH) {
+	    rc = strncasecmp(priv->current_certificate.emailAddress,
+			     mailaddr, len);
+	    if (rc == 0) {
+	        if (getcert_shared->debugging & DEBUG_GEN_HI)
+	            syslog(LOG_DEBUG,
+		        "[%lu][debug] %.64s %.64s\n", conn->c_connid,
+		        "Search filter matches emailAddress",
+			"in this certificate.");
+	        return(1);
+	    } else {
+		if (getcert_shared->debugging) {
+		    syslog(LOG_INFO,
+		        "[%lu] %.64s %.64s\n", conn->c_connid,
+		        "Email address does not match emailAddress",
+		        "found in this certificate");
+		    syslog(LOG_INFO,
+		        "[%lu]     %.450s vs. %.450s\n", conn->c_connid,
+		        priv->current_certificate.emailAddress, mailaddr);
+		}
+		return(-1);
+	    }
+	}
+    }
+
+    /* We didn't find a match with any of the       */
+    /* email addresses defined in this certificate. */
+    return(-1);
+} /* verify_email_addr */
+
+ /*
+  * Release any dynamically allocated memory used to store the 
+  * rfc822Name values.  The first link is preallocated.  Any
+  * other links in the chain are dynamically allocated as needed.
+  */
+void
+release_rfc822Name_chain(
+    Backend	   *be,
+    Connection	   *conn,
+    struct getcert_private    *priv
+    )
+{
+    struct getcert_data  *getcert_shared;
+    struct rfc822name_link  *link_ptr;
+
+    getcert_shared = be->be_private;
+
+    /* Each pass through the loop releases one link */
+    /* from the end of the rfc822name_chain.        */
+    link_ptr = NULL;
+    while ((priv->current_certificate.rfc822Name_chain.next_rfc822Name != NULL) &&
+	   (link_ptr != &priv->current_certificate.rfc822Name_chain)) {
+        link_ptr = &priv->current_certificate.rfc822Name_chain;
+        do {
+	    if (link_ptr->next_rfc822Name != NULL) {
+	        if (link_ptr->next_rfc822Name->next_rfc822Name == NULL) {
+		    if (getcert_shared->debugging & DEBUG_MEM)
+                        syslog(LOG_DEBUG,
+			   "[%lu][debug] %.128s\n", conn->c_connid,
+			   "Releasing memory allocated for rfc822Name name.");
+		    free(link_ptr->next_rfc822Name->email_name);
+		    if (getcert_shared->debugging & DEBUG_MEM)
+                        syslog(LOG_DEBUG,
+			   "[%lu][debug] %.128s\n", conn->c_connid,
+			   "Releasing memory allocated for rfc822Name link.");
+		    free(link_ptr->next_rfc822Name);
+		    link_ptr->next_rfc822Name = NULL;
+	        } else {
+		    link_ptr = link_ptr->next_rfc822Name;
+	        }
+	    }
+        } while (link_ptr->next_rfc822Name != NULL);
+    }
+    return;
+} /* release_rfc822Name_chain */
+
+/*
+ * Release the dynamically allocated memory used to store the
+ * found certificates.
+ */
+void
+release_certificate_buffers(
+    Backend        *be,
+    Connection     *conn,
+    struct getcert_private    *priv
+    )
+{
+    int  i;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    for (i = 0; i < getcert_shared->MAX_CERTIFICATES; i++) {
+	if (priv->certificates[i] != NULL) {
+	    if (priv->certificates[i]->der_certificate != NULL) {
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+			"[%lu][debug] Releasing memory allocated for DER certificate %d.\n",
+			conn->c_connid, i + 1);
+		free(priv->certificates[i]->der_certificate);
+	    }
+	    if (priv->certificates[i]->b64_certificate != NULL) {
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+			"[%lu][debug] Releasing memory allocated for Base64 certificate %d.\n",
+			conn->c_connid, i + 1);
+		free(priv->certificates[i]->b64_certificate);
+	    }
+	    if (getcert_shared->debugging & DEBUG_MEM)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] Releasing memory allocated for certificate %d structure.\n",
+		    conn->c_connid, i + 1);
+	    free(priv->certificates[i]);
+	    priv->certificates[i] = NULL;
+	}
+    }
+    return;
+} /* release_certificate_buffers */
+
+/*
+ * Add information about the current search query we are processing
+ * to the pending_queries table.  The pending_queries table is 
+ * available to all LDAP Proxy threads and contains entries for 
+ * every search query the LDAP Proxy is currently processing.
+ * When a new query comes in, it is checked against all the entries 
+ * in the pending_queries table to see if it came from the same IP 
+ * address and uses the same search criteria as a current query.
+ * If a match is found, the new query will be rejected as a possible 
+ * query loop. 
+ * 
+ * Return:
+ *    1 = Identical query already in table
+ *    0 = Successful add
+ *   -1 = pending_queries table is full
+ */
+int
+add_pending_query(
+    Backend        *be,
+    Connection     *conn,
+    struct berval  *filterstr,
+    struct berval  *base,
+    struct getcert_private   *priv
+    )
+{
+    int  first_empty_row, len, number_of_entries, row;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    /*
+     * Compare the new query with the current queries.
+     * Find the first empty row in the table while we're at it.
+     */
+    first_empty_row = -1;
+    number_of_entries = 0;
+    for (row = 0; row < getcert_shared->MAX_QUERIES; row++) {
+	if (getcert_shared->pending_queries[row].connection_id < 0) {
+	    if (first_empty_row < 0) 
+		first_empty_row = row;
+	} else {
+	    number_of_entries++;
+	    /* Compare the new query with this existing query. */
+	    if (strcmp(getcert_shared->pending_queries[row].client_ip_addr,
+		       priv->client_ip) == 0) {
+		/* Same IP.  Check the filter string. */
+		if (strncmp(getcert_shared->pending_queries[row].query_filter,
+		           filterstr->bv_val, filterstr->bv_len) == 0) {
+		    /* Same filter string.  Check the base DN. */
+		    if (strncmp(getcert_shared->pending_queries[row].base_dn,
+			   base->bv_val, base->bv_len) == 0) {
+		        /* Identical query.  Reject it. */
+		        if (getcert_shared->debugging & DEBUG_GEN_HI) {
+			    syslog(LOG_DEBUG,
+			        "[%lu][debug] New query identical to [%ld]:\n",
+			        conn->c_connid,
+			        getcert_shared->pending_queries[row].connection_id);
+			    syslog(LOG_DEBUG,
+			       "[%lu][debug]     IP = %.64s\n", conn->c_connid, 
+			       getcert_shared->pending_queries[row].client_ip_addr);
+			    syslog(LOG_DEBUG,
+			        "[%lu][debug]     Filter = %.64s\n",
+				conn->c_connid, 
+			        getcert_shared->pending_queries[row].query_filter);
+			    syslog(LOG_DEBUG,
+			        "[%lu][debug]     Base DN = %.64s\n",
+				conn->c_connid, 
+			        getcert_shared->pending_queries[row].base_dn);
+		        }
+		        return(1);
+		    } /* same base DN */
+		} /* same filter */ 
+	    } /* same IP */
+	} /* occupied row */
+    } /* next row */
+
+    if (first_empty_row < 0) {
+	/* The pending_queries table is full. */
+	syslog(LOG_INFO,
+	    "[%lu][error] Table of pending queries is full (%d entries).\n",
+	    conn->c_connid, getcert_shared->MAX_QUERIES);
+        return(-1);
+    }
+
+    if (getcert_shared->debugging & DEBUG_GEN_HI)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] There are %d entries in the %d %.64s\n",
+	    conn->c_connid, number_of_entries, getcert_shared->MAX_QUERIES,
+	    "row pending_queries list.");
+
+    /*
+     * Add the current query info into an empty slot in the table.
+     */
+    getcert_shared->pending_queries[first_empty_row].connection_id = 
+	(long int) conn->c_connid;
+    len = strlen(priv->client_ip);
+    if (len < MAX_IP_LENGTH - 1) {
+        strncpy(getcert_shared->pending_queries[first_empty_row].client_ip_addr,
+	    priv->client_ip, len + 1);
+    } else {
+	strncpy(getcert_shared->pending_queries[first_empty_row].client_ip_addr,
+	    priv->client_ip, MAX_IP_LENGTH);
+	getcert_shared->pending_queries[first_empty_row].client_ip_addr[MAX_IP_LENGTH - 1] = '\0';
+    }
+
+    if (filterstr->bv_len > (MAX_EMAIL_LENGTH - 1)) {
+	strncpy(getcert_shared->pending_queries[first_empty_row].query_filter,
+	    filterstr->bv_val, (MAX_EMAIL_LENGTH - 1));
+	getcert_shared->pending_queries[first_empty_row].query_filter[MAX_EMAIL_LENGTH - 1] = '\0';
+    } else {
+	strncpy(getcert_shared->pending_queries[first_empty_row].query_filter,
+	    filterstr->bv_val, filterstr->bv_len + 1);
+    }
+
+    if (base->bv_len > (MAX_DN_LENGTH - 1)) {
+	strncpy(getcert_shared->pending_queries[first_empty_row].base_dn,
+	    base->bv_val, (MAX_DN_LENGTH - 1));
+	getcert_shared->pending_queries[first_empty_row].query_filter[MAX_DN_LENGTH - 1] = '\0';
+    } else {
+	strncpy(getcert_shared->pending_queries[first_empty_row].base_dn,
+	    base->bv_val, base->bv_len + 1);
+    }
+    if (getcert_shared->debugging & DEBUG_GEN_HI)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Added current query info to pending_queries list.\n",
+	    conn->c_connid);	
+    return(0);
+} /* add_pending_query */
+
+/*
+ * Remove the current query info from the pending_queries table.
+ */
+void
+remove_pending_query(
+    Backend     *be,
+    Connection  *conn
+    )
+{
+    int  row;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    for (row = 0; row < getcert_shared->MAX_QUERIES; row++) {
+	if (getcert_shared->pending_queries[row].connection_id == 
+	        (long int) conn->c_connid) {
+	    getcert_shared->pending_queries[row].client_ip_addr[0] = '\0';
+	    getcert_shared->pending_queries[row].query_filter[0] = '\0';
+	    getcert_shared->pending_queries[row].base_dn[0] = '\0';
+	    getcert_shared->pending_queries[row].connection_id = -1;
+	    if (getcert_shared->debugging & DEBUG_GEN_HI)
+	        syslog(LOG_DEBUG,
+	            "[%lu][debug] Removed query info for [%lu] %.64s %d.\n",
+	            conn->c_connid, conn->c_connid,
+	            "from pending_queries list row", row);
+	    break;
+	}
+    }
+    if (row >= getcert_shared->MAX_QUERIES) {
+	syslog(LOG_INFO,
+	    "[%lu][error] Could not find [%lu] in pending_queries list.\n",
+	    conn->c_connid, conn->c_connid);
+    }
+    return;
+} /* remove_pending_query */
+
+/*
+ * To detect and terminate proxy infinite loops, we maintain a list of
+ * all LDAP queries we are currently processing.  If a query comes in
+ * that is identical (same client IP address, filter string, and baseDN)
+ * to a query we are already processing, reject the new query with an
+ * LDAP_LOOP_DETECT return code.  In rare cases this may reject the
+ * occasional legitimate query, but proxy loops are proxy killers and
+ * must be stopped at all cost.
+ *
+ * Check to see if the current search query request is identical to
+ * a query already being processed.  If not, add this query to the
+ * pending_queries list.  If a match is found, reject the new query
+ * as a possible query loop.
+ * LDAP responses are sent by this routine if the new query is rejected.
+ * Return code:
+ *	 0 = Accept new query (query added to pending_queries list).
+ *	-1 = Reject new query (identical query already being processed
+ *			       or pending_queries list full).
+ */
+int
+check_pending_queries(
+    Backend        *be,
+    Connection     *conn,
+    Operation      *op,
+    struct berval  *filterstr,
+    struct berval  *base,
+    struct getcert_private  *priv,
+    SlapReply      *rs
+    )
+{
+    int  i, rc;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    /* Add this query to the list of pending queries. */
+    rc = add_pending_query(be, conn, filterstr, base, priv);
+
+    if (getcert_shared->debugging & DEBUG_GEN_LO) {
+        syslog(LOG_DEBUG,
+	    "[%lu][debug] pending_query table:\n", conn->c_connid);
+        for (i = 0; i < getcert_shared->MAX_QUERIES; i++)
+	    syslog(LOG_DEBUG, "[%lu][debug] row %d: %ld\n", conn->c_connid, i,
+		getcert_shared->pending_queries[i].connection_id);
+    }
+
+    if (rc > 0) {
+	/* An identical query is already being processed. */
+	/* Reject this one.                               */
+	if (getcert_shared->debugging == DEBUG_NONE) {
+	    i = (MAX_LOG_REC - strlen(priv->log_buffer)) - 1;
+	    strncat(priv->log_buffer, "Rejecting this duplicate query.", i);
+	} else {
+	    syslog(LOG_INFO,
+	        "[%lu] %.128s\n", conn->c_connid,
+	        "This query is identical to a query currently being processed.");
+	    syslog(LOG_INFO,
+	        "[%lu] Current query is rejected (LDAP_LOOP_DETECT).\n", conn->c_connid);
+	}
+	if (getcert_shared->limit_return_codes)
+        {
+            rs->sr_err = LDAP_OPERATIONS_ERROR;
+            rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+	    send_ldap_result(op, rs);
+        }
+        else
+        {
+            rs->sr_err = LDAP_LOOP_DETECT;
+            rs->sr_text = getcert_err_msg[GETCERT_LOOP_DETECT];
+	    send_ldap_result(op, rs);
+        }
+	return(-1);
+    };
+    if (rc < 0) {
+	/* Too many queries in progress to accept any more. */
+	/* Reject this query with an LDAP_BUSY return code. */
+	if (getcert_shared->debugging == DEBUG_NONE) {
+	    i = (MAX_LOG_REC - strlen(priv->log_buffer)) - 1;
+	    strncat(priv->log_buffer,
+		"[error] Server busy.  Maximum queries being processed.", i);
+	} else {
+	    syslog(LOG_INFO,
+	        "[%lu][error] Server busy.  %d queries already being processed.\n",
+	        conn->c_connid, getcert_shared->MAX_QUERIES);
+	}
+	if (getcert_shared->limit_return_codes)
+        {
+            rs->sr_err = LDAP_OPERATIONS_ERROR;
+            rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+	    send_ldap_result(op, rs);
+        }
+	else
+        {
+            rs->sr_err = LDAP_BUSY;
+            rs->sr_text = getcert_err_msg[GETCERT_SERVER_BUSY];
+	    send_ldap_result(op, rs);
+        }
+	return(-1);
+    }
+    return(0);
+} /* check_pending_queries */
+
+/*
+ * An LDAP search failed.  Log the errors and release 
+ * the memory allocated for the search results.
+ */
+void
+search_failed(
+    Backend      *be,
+    Connection   *conn,
+    int		 search_rc,
+    char	 *server_name,
+    LDAPMessage  *result
+    )
+{
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    if (getcert_shared->debugging & DEBUG_GEN_HI)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] ldap_search_st returns %d\n",
+            conn->c_connid, search_rc);
+    switch (search_rc) {
+	case LDAP_SIZELIMIT_EXCEEDED:
+	    /* Too many matches found */
+            syslog(LOG_INFO,
+                "[%lu][error] %.128s\n", conn->c_connid,
+                "Too many matches found. Skipping this server.");
+	    break;
+	case LDAP_NO_SUCH_OBJECT:
+	    if (getcert_shared->debugging & DEBUG_GEN_HI)
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] LDAP search did not find object.\n",
+                    conn->c_connid);
+	    break;
+	case GETCERT_ERR_LDAPINIT|GETCERT_ERR_LDAPBIND:
+            syslog(LOG_INFO,
+                "[%lu][error] LDAP search failed: %.128s  %256s\n",
+                conn->c_connid, ldap_err2string(search_rc), server_name);
+	    /*
+	     * OpenLDAP is crashing when ldap_msgfree is called to release
+	     * memory allocated by ldap_search_st on searches that result
+	     * in errors.  OpenLDAP 2.1 bug?  To avoid proxy crashes, we
+	     * don't try to release the search results after a search error.
+	     */
+	    result = NULL;
+	    break;
+	default:
+	    /* Print error message and try next server. */
+            syslog(LOG_INFO,
+                "[%lu][error] LDAP search failed: %.128s\n",
+                conn->c_connid, ldap_err2string(search_rc));
+	    /*
+	     * OpenLDAP is crashing when ldap_msgfree is called to release
+	     * memory allocated by ldap_search_st on searches that result
+	     * in errors.  OpenLDAP 2.1 bug?  To avoid proxy crashes, we
+	     * don't try to release the search results after a search error.
+	     */
+	    result = NULL;
+    }
+
+    if (result != NULL) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] %.128s\n", conn->c_connid,
+		"Releasing memory allocated for search results.");
+        ldap_msgfree(result);
+        result = NULL;
+    }
+
+    return;
+} /* search_failed */
+
+/*
+ * Convert the search results, which are currently in LDIF format,
+ * to Entry format and send them to the client.
+ * Send an error return code to the client if there are problems.
+ * Return code:
+ *	0 = Successful
+ *     -1 = Error
+ */
+int
+send_search_results(
+    Backend     *be,
+    Connection  *conn,
+    Operation   *op,
+    AttributeName  *attrs,
+    int         attrsonly,
+    char        *ldif_data,
+    char	*returned_ndn,
+    SlapReply   *rs
+    )
+{
+    int    i, ldif_length, len, offset, rc;
+    char   *ldif_copy, ldifbuffer[MAX_LINE];
+    Entry  *e;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+    ldif_copy = NULL;
+
+    ldif_length = strlen(ldif_data);
+    if (getcert_shared->debugging & DEBUG_GEN_LO)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] Search results to be returned are %d %.64s\n",
+            conn->c_connid, ldif_length, "bytes in length.");
+    
+    /*
+     * We have to make a copy of the LDIF data passed to us via 
+     * "ldif_data" because str2entry trashes the contents and we
+     * need to preserve the LDIF data so it can be resent from 
+     * the last_results_cache if necessary.
+     */
+    if (getcert_shared->debugging & DEBUG_MEM)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] Allocating %d bytes of memory %.128s\n",
+                conn->c_connid, ldif_length + 1,
+		"for copy of LDIF structure.");
+    ldif_copy = malloc(ldif_length + 1);
+    if (ldif_copy == NULL) {
+	syslog(LOG_INFO,
+	    "[%lu][error] Cannot allocate memory for LDIF copy.\n", conn->c_connid);
+	return(-1);
+    }
+    strncpy(ldif_copy, ldif_data, ldif_length);
+    ldif_copy[ldif_length] = '\0';
+
+    if (getcert_shared->debugging & DEBUG_DATA) {
+        /*
+         * Debug log the entire LDIF structure.
+         */
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] LDIF input to str2entry:\n", conn->c_connid);
+	offset = 0;
+	while ((ldif_copy[offset] != '\0') && (offset <= ldif_length)) {
+	    i = 0;
+	    do {
+	        ldifbuffer[i++] = ldif_copy[offset++];
+	    } while ((ldifbuffer[i - 1] != '\n') && (ldifbuffer[i - 1] != '\0'));
+	    ldifbuffer[i] = '\0';
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] %.900s", conn->c_connid, ldifbuffer);
+        }
+    } else {
+        /*
+         * Debug log the first part of the LDIF results.
+         */
+        if (getcert_shared->debugging & DEBUG_GEN_LO) {
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] LDIF input to str2entry:\n", conn->c_connid);
+	    offset = 0;
+	    while ((ldif_copy[offset] != '\0') &&
+		    (offset <= ldif_length) &&
+		    (offset < MAX_LINE)) {
+	        i = 0;
+	        do {
+	            ldifbuffer[i++] = ldif_copy[offset++];
+	        } while ((ldifbuffer[i - 1] != '\n') && (ldifbuffer[i - 1] != '\0'));
+	        ldifbuffer[i] = '\0';
+	        syslog(LOG_DEBUG,
+		    "[%lu][debug] %.900s", conn->c_connid, ldifbuffer);
+	    }
+        }
+    }
+
+    /* Convert LDIF to Entry. */
+    /* Note that str2entry modifies the contents of its input. */
+    e = str2entry(ldif_copy);
+    if (e == NULL) {
+        /* Unable to build an Entry structure. */
+        /* Log file will say why.              */
+        syslog(LOG_INFO,
+	    "[%lu][error] Could not process search results (str2entry).\n",
+	    conn->c_connid);
+        if (ldif_copy != NULL) {
+	    if (getcert_shared->debugging & DEBUG_MEM)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] %.128s\n",
+		    conn->c_connid,
+		    "Releasing memory allocated for LDIF copy.");
+            free(ldif_copy);
+            ldif_copy = NULL;
+        }
+	return(-1);
+    } else
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Allocated memory for Entry structure.\n",
+		conn->c_connid);
+        if (getcert_shared->debugging & DEBUG_GEN_HI)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] %.128s\n", conn->c_connid,
+		"LDIF data have been converted to Entry structure.");
+
+    /* Send results to slapd. */
+    rs->sr_entry = e;
+    rs->sr_attrs = op->oq_search.rs_attrs;
+    rs->sr_operational_attrs = NULL;
+    rs->sr_ctrls = NULL;
+    rs->sr_flags = 0;
+    rs->sr_err = LDAP_SUCCESS;
+    rc = send_search_entry(op, rs);
+    if (getcert_shared->debugging & DEBUG_GEN_LO)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] send_search_entry return code %d\n",
+	    conn->c_connid, rc);
+
+    /* Save the normalized DN returned with the search results. */
+    len = strlen(e->e_ndn);
+    if (len < MAX_DN_LENGTH) {
+	strncpy(returned_ndn, e->e_ndn, len + 1);
+	returned_ndn[len] = '\0';
+    } else {
+	strncpy(returned_ndn, e->e_ndn, MAX_DN_LENGTH);
+	returned_ndn[MAX_DN_LENGTH - 1] = '\0';
+    }	
+    if (getcert_shared->debugging & DEBUG_GEN_LO)
+        syslog(LOG_DEBUG,
+	    "[%lu][debug] Normalized DN returned is %.512s\n",
+	    conn->c_connid, returned_ndn);
+
+    /* Free up memory used. */
+    if (e != NULL) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+	       "[%lu][debug] Releasing memory allocated for Entry structure.\n",
+	       conn->c_connid);
+	entry_free(e);
+    }
+    if (ldif_copy != NULL) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Releasing memory allocated for LDIF copy.\n",
+		conn->c_connid);
+        free(ldif_copy);
+        ldif_copy = NULL;
+    }
+    return(0);
+} /* send_search_results */
+
+/*
+ * This routine compares two LDAP attribute names.
+ * One attribute is from the LDAP search command and the other attribute
+ * is from the LDAP server list.  Either of these attribute names can be
+ * tagged, usually ";binary".  If the names don't match, try matching
+ * them without the tags.  The comparison is not case-sensitive.
+ * Return:
+ *	0     = attribute names match
+ *	non 0 = attribute names differ
+ */
+int
+compare_attr_names(
+    Backend         *be,
+    Connection      *conn,
+    AttributeName   *attrs,
+    int		    attr_list_index,
+    int		    ldap_list_index
+    )
+{
+    int  attrlen;
+    char attrlstbuff[MAX_ATTRIBUTE_NAME];
+    char ldaplstbuff[MAX_ATTRIBUTE_NAME];
+    char  *tagptr1, *tagptr2;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    attrlen = strlen(ldap_server_list[ldap_list_index]->ldap_attr);
+    if ((attrs[attr_list_index].an_name.bv_len >= MAX_ATTRIBUTE_NAME) ||
+	(attrlen >= MAX_ATTRIBUTE_NAME))
+	return(-1);
+
+    /*
+     * First, try a straight-up comparison.
+     */
+    if (getcert_shared->debugging & DEBUG_GEN_LO) {
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Comparing attribute names:\n", conn->c_connid);
+	syslog(LOG_DEBUG,
+	    "[%lu][debug]     %.*s and %.*s\n", conn->c_connid,
+	    attrs[attr_list_index].an_name.bv_len,
+	    attrs[attr_list_index].an_name.bv_val,
+	    attrlen,
+	    ldap_server_list[ldap_list_index]->ldap_attr);
+    }
+    if (strncasecmp(attrs[attr_list_index].an_name.bv_val,
+		    ldap_server_list[ldap_list_index]->ldap_attr,
+		    attrs[attr_list_index].an_name.bv_len) == 0) {
+	if (getcert_shared->debugging & DEBUG_GEN_LO)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Attribute names match.\n", conn->c_connid);
+	return(0);
+    }
+
+    /*
+     * If either of the attribute names are tagged,
+     * try matching without the tag.
+     */
+    /* Turn the attr name value into a string. */
+    strncpy(attrlstbuff, attrs[attr_list_index].an_name.bv_val,
+	    attrs[attr_list_index].an_name.bv_len);
+    attrlstbuff[attrs[attr_list_index].an_name.bv_len] = '\0';
+    /* Is either attr name tagged? */
+    tagptr1 = strchr(attrlstbuff, ';');
+    tagptr2 = strchr(ldap_server_list[ldap_list_index]->ldap_attr, ';');
+    if ((tagptr1 == NULL) && (tagptr2 == NULL))
+	/* No tags */
+	return(-1);
+
+    /* At least one of the names is tagged. */
+    if (tagptr1 != NULL)
+	/* Trim off the tag. */
+	tagptr1[0] = '\0';
+    strncpy(ldaplstbuff, ldap_server_list[ldap_list_index]->ldap_attr, attrlen);
+    ldaplstbuff[attrlen] = '\0';
+    tagptr2 = strchr(ldaplstbuff, ';');
+    if (tagptr2 != NULL)
+	/* Trim off the tag. */
+        tagptr2[0] = '\0';
+    if (getcert_shared->debugging & DEBUG_GEN_LO) {
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Comparing untagged attribute names:\n",
+	    conn->c_connid);
+	syslog(LOG_DEBUG,
+	    "[%lu][debug]     %.512s and %.512s\n", conn->c_connid,
+	    attrlstbuff, ldaplstbuff);
+    }
+    return(strcasecmp(attrlstbuff, ldaplstbuff));
+} /* compare_attr_names */
+
+/* 
+ * We are searching for user certificates (and maybe userSMIMECertificate)
+ * using the email address in the search filter as the search criteria.
+ */
+void
+find_certificate(
+    Backend        *be,
+    Connection     *conn,
+    Operation      *op,
+    struct berval  *base,
+    struct berval  *nbase,
+    struct berval  *filterstr,
+    AttributeName  *attrs,
+    int            attrsonly,
+    struct getcert_private  *priv,
+    SlapReply      *rs
+    )
+{ 
+    LDAP	*ld;
+    LDAPMessage *result, *entry;
+    BerElement  *ber;
+    char	*attr;
+    char	**vals;
+    int	   i, j, k, certlength, ldiflines, ldifsize, len, len1, len2, memlen,
+	   offset, old_count, person_count, rc, search_rc, server_number, valid_certs;
+    char   attrbuff[MAX_ATTRIBUTE_NAME], *certptr, commonname[MAX_STRING],
+	   mailaddr[MAX_EMAIL_LENGTH], mailrhs[MAX_EMAIL_LENGTH],
+	   *memptr, *ptr, *ptr2, searchdn[MAX_STRING], tempbuff[MAX_STRING];
+    struct timeval  search_maxwait = {0, 0};
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+    struct certlist  *crtlstptrs[getcert_shared->MAX_CERTIFICATES];
+
+    /*
+     * Initialize
+     */
+    commonname[0] = '\0';
+    result = NULL;
+    searchdn[0] = '\0';
+    server_number = 0;
+    valid_certs = 0;
+    priv->total_octets = 0;
+    priv->cert_number = 0;
+    priv->certificates = crtlstptrs;
+    for (i = 0; i < getcert_shared->MAX_CERTIFICATES; i++)
+	priv->certificates[i] = NULL;
+    for (i = 0; i < MAX_CONTENT; i++)
+	priv->certbuffer[i] = '\0';
+    priv->attr_vals = NULL;
+    priv->current_crl.crl_number = -1;
+
+    /*
+     * Isolate the email address.
+     */
+    len = strlen(priv->mailfilter);
+    if ((len - 6) >= MAX_EMAIL_LENGTH) {
+	/* Email address is too long to be believable. */
+	if (getcert_shared->debugging == DEBUG_NONE) {
+	    len2 = (MAX_LOG_REC - strlen(priv->log_buffer)) - 1;
+	    strncat(priv->log_buffer, "Email address too long.", len2);
+	} else {
+	    syslog(LOG_INFO,
+	        "[%lu] Email address too long.\n", conn->c_connid);
+	}
+	if (getcert_shared->limit_return_codes)
+        {
+            rs->sr_err = LDAP_OPERATIONS_ERROR;
+            rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+	    send_ldap_result(op, rs);
+        }
+	else
+        {
+            rs->sr_err = LDAP_FILTER_ERROR;
+            rs->sr_text = getcert_err_msg[GETCERT_ERR_BAD_EMAILADDR];
+	    send_ldap_result(op, rs);
+        }
+	return;
+    } else {
+	/* Are there quotes around the email address?  Strip them off. */
+	if (((priv->mailfilter[6] == '\x22') && (priv->mailfilter[len - 2] == '\x22')) ||
+	    ((priv->mailfilter[6] == '\x27') && (priv->mailfilter[len - 2] == '\x27'))) {
+	    /* Length of email address part of filter */
+	    len = ((len - 6) - 2) - 1;
+	    strncpy(mailaddr, &priv->mailfilter[7], len);
+	} else {
+	    /* Length of email address part of filter */
+	    len = (len - 6) - 1;
+            strncpy(mailaddr, &priv->mailfilter[6], len);
+	    mailaddr[len] = '\0'; 
+	}
+        if (getcert_shared->debugging & DEBUG_GEN_LO) {
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Input filter is %.900s\n",
+		conn->c_connid, filterstr->bv_val);
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Email filter is %.900s\n",
+		conn->c_connid, priv->mailfilter);
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Email address is %.900s\n",
+		conn->c_connid, mailaddr);
+        }
+    }
+
+    /*
+     * Isolate the email domain (the stuff to the right of the '@'). 
+     */
+    ptr = strchr(mailaddr, '@');
+    len = strlen(&ptr[1]);
+    if (len >= (int)sizeof(mailrhs)) {
+	/* Email domain too long to be believable. */
+	if (getcert_shared->debugging == DEBUG_NONE) {
+	    len2 = (MAX_LOG_REC - strlen(priv->log_buffer)) - 1;
+	    strncat(priv->log_buffer, "Email domain part too long.", len2);
+	} else {
+	    syslog(LOG_INFO,
+	        "[%lu] Email domain part too long.\n", conn->c_connid);
+	}
+	if (getcert_shared->limit_return_codes)
+        {
+            rs->sr_err = LDAP_OPERATIONS_ERROR;
+            rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+	    send_ldap_result(op, rs);
+        }
+	else
+        {
+            rs->sr_err = LDAP_FILTER_ERROR;
+            rs->sr_text = getcert_err_msg[GETCERT_ERR_BAD_EMAILADDR];
+	    send_ldap_result(op, rs);
+        }
+	return;
+    } else {
+        strncpy(mailrhs, &ptr[1], len + 1);
+        ptr = strchr(mailrhs, ')');
+        if (ptr != NULL) {
+	    if (getcert_shared->debugging & DEBUG_GEN_HI)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] mailrhs ends with %c at position %d\n",
+		     conn->c_connid, ptr[0], (int)(ptr - mailrhs));
+	    ptr[0] = '\0';
+	}
+    }
+
+    /*
+     * Search through the certificate server list querying each server that
+     * holds certificates for the desired email domain.  By default, we will
+     * return the certificates we find from the first server in the server list
+     * that has certificates for the specified email address.  However, if the
+     * "search_all_servers" configuration option is set to "TRUE", we continue
+     * searching LDAP servers for more certificates associated with the email
+     * address.  If a server has no valid certificates for this email address,
+     * move on to the next server.  This way we can have multiple servers in the
+     * server list that service the same email domain, giving us a redundancy
+     * capability.
+     */
+    while ((server_number >= 0) &&
+	   ((valid_certs < 1) || (getcert_shared->search_all_servers == TRUE))) {
+        /* 
+         * Search the server list for the next certificate server that
+         * serves the users in one of the email sub-domains defined
+         * by the email address we were given.  
+         */
+        server_number = search_cert_server_list(be, conn, mailrhs, server_number);
+        if (server_number < 0)
+	    /* We've reached the end of the certificate server list. */
+	    break;
+        
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+	    syslog(LOG_DEBUG,
+	        "[%lu] Next certificate server to query is: %.256s\n",
+	        conn->c_connid, cert_server_list[server_number]->server_name);
+    
+        /*
+         * This certificate server may require a different email filter 
+	 * attribute than the standard "mail".  If so, it is specified 
+	 * in the certificate server list. 
+         */
+    	len = strlen(cert_server_list[server_number]->mail_attr);
+    	if (len >= ((int)sizeof(priv->mailfilter) - 12)) {
+    	    /* Email attribute name too long to be believable. */
+	    if (getcert_shared->limit_return_codes)
+            {
+                rs->sr_err = LDAP_OPERATIONS_ERROR;
+                rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+                send_ldap_result(op, rs);
+            }
+	    else
+            {
+                rs->sr_err = LDAP_INVALID_SYNTAX;
+                rs->sr_text = getcert_err_msg[GETCERT_ERR_SERVERLIST_SYNTAX];
+                send_ldap_result(op, rs);
+            }
+    	    return;
+    	}
+	/* mailfilter is MAX_FILTER_LEN in size. */
+        len2 = strlen(mailaddr);
+        if ((len + len2 + 4) < MAX_FILTER_LEN) {
+    	    strncpy(&priv->mailfilter[1], cert_server_list[server_number]->mail_attr, len + 1);
+    	    strncat(priv->mailfilter, "=", 1);
+    	    strncat(priv->mailfilter, mailaddr, len2);
+    	    strncat(priv->mailfilter, ")", 1);
+    	}
+	priv->mailfilter[MAX_FILTER_LEN - 1] = '\0';
+    
+        /*
+         * Get a handle to an LDAP connection.
+         */
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+            syslog(LOG_DEBUG,
+    	        "[%lu][debug] Initializing LDAP structures\n", conn->c_connid);
+
+        if ((ld = ldap_init(cert_server_list[server_number]->server_name,
+    	                    cert_server_list[server_number]->port)) == NULL) {
+    	    syslog(LOG_INFO,
+    	        "[%lu][error] Unable to initialize LDAP structures.\n", conn->c_connid);
+    	    /* Move on to the next possible server in the server list. */
+	    server_number++;
+    	    continue;
+        }
+	ldap_set_option(ld, LDAP_OPT_TIMELIMIT,	&getcert_shared->search_timeout);
+	if (getcert_shared->debugging & DEBUG_GEN_LO) {
+	    ldap_get_option(ld, LDAP_OPT_TIMELIMIT, &rc);
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] LDAP_OPT_TIMELIMIT is %d seconds\n", conn->c_connid, rc);
+	}
+    
+        /*
+         * Bind to the certificate server if it requires authentication.
+	 * Otherwise skip the BIND step so that we don't have to sit through
+	 * a four minute timeout period if the server is unreachable.  There
+	 * is no timeout override on the BIND routine as there is with the
+	 * search routine later on.
+         *
+         * A bind is required in LDAP version 2 but optional in LDAP version 3.
+	 * Unfortunately, OpenLDAP servers are configured by default to reject
+         * queries from LDAP version 2 clients, and our bind makes us look
+	 * like an LDAP version 2 client.  So if our bind fails with an
+	 * LDAP_PROTOCOL_ERROR, we just continue on with our query.
+	 * Adding "allow bind_v2" to the slapd.conf file on the OpenLDAP
+	 * server disables the rejection of clients requesting binds.
+         */
+        if (cert_server_list[server_number]->bind_dn[0] == '\0') {
+	    /* Server does not require authentication.  Skip the BIND. */
+	    if (getcert_shared->debugging & DEBUG_GEN_HI)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] Skipping BIND to %.450s\n",
+		    conn->c_connid, cert_server_list[server_number]->server_name);
+	} else {
+	    if (getcert_shared->debugging)
+    	        syslog(LOG_INFO,
+    	            "[%lu] Establishing LDAP connection to %.900s port %d\n",
+	            conn->c_connid, cert_server_list[server_number]->server_name,
+	            cert_server_list[server_number]->port);
+	    rc = ldap_simple_bind_s(ld, cert_server_list[server_number]->bind_dn,
+				    cert_server_list[server_number]->bind_password);
+            if (rc == LDAP_PROTOCOL_ERROR) {
+                if (getcert_shared->debugging & DEBUG_GEN_HI) {
+                    syslog(LOG_DEBUG,
+                        "[%lu][debug] %s\n", conn->c_connid,
+		        "LDAP server trying to reject us as an LDAP V2 client.");
+                    syslog(LOG_DEBUG,
+                        "[%lu][debug] %s\n", conn->c_connid,
+		        "We are an LDAP V3 client, so we will continue.");
+	        }
+            } else {
+                if (rc != LDAP_SUCCESS) {
+    	            syslog(LOG_INFO, "[%lu] Bind failed to %.450s: %.450s\n", conn->c_connid,
+			    cert_server_list[server_number]->server_name, ldap_err2string(rc));
+    	            /* Move on to the next possible server in the server list. */
+	            server_number++;
+                    continue;
+                }
+	    }
+	}
+
+        if (getcert_shared->debugging & DEBUG_GEN_HI) {
+	    if (cert_server_list[server_number]->base_dn[0] == '\0') {
+    	        syslog(LOG_DEBUG,
+    	            "[%lu][debug] Search DN is NULL\n", conn->c_connid);
+	    } else {
+    	        syslog(LOG_DEBUG,
+    	            "[%lu][debug] Search DN is %.900s\n",
+		    conn->c_connid, cert_server_list[server_number]->base_dn);
+	    }
+    	    syslog(LOG_DEBUG,
+		"[%lu][debug] Search filter is %.900s\n", conn->c_connid, priv->mailfilter);
+    	    syslog(LOG_DEBUG,
+		"[%lu][debug] Beginning ldap search...\n", conn->c_connid);
+        }
+    
+        /* 
+         * Perform the search using our mail filter and the search
+	 * timeout value specified in the slapd configuration file.
+         */
+	search_maxwait.tv_sec = getcert_shared->search_timeout;
+
+	/*
+	 * Search through all attributes for the entry instead of just
+	 * the attributes we want.  Helpful during the development stages
+	 * and solves the problem of attribute case sensitivity we run in
+	 * to with some LDAP servers when we specify the attributes we
+	 * want the server to return.
+	 */
+        search_rc = ldap_search_st(ld,
+  	    cert_server_list[server_number]->base_dn, LDAP_SCOPE_SUBTREE,
+	    priv->mailfilter, NULL, 0, &search_maxwait, &result);
+
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Allocated memory for search results.\n", conn->c_connid);
+
+	if (search_rc != LDAP_SUCCESS) {
+     	    /*
+    	     * The LDAP search failed. 
+             * Log the errors and release the
+             * dynamically allocated memory.
+             */
+            search_failed(be, conn, search_rc,
+		cert_server_list[server_number]->server_name, result);
+	    if (ld != NULL) {
+                ldap_unbind(ld);
+                ld = NULL;
+            }
+	    server_number++;
+    	    continue;
+        } 
+    
+        if (getcert_shared->debugging & DEBUG_GEN_HI)
+    	    syslog(LOG_DEBUG,
+	        "[%lu][debug] Processing search results...\n", conn->c_connid);
+    
+        /*
+         *  Check to see if anyone in this server's LDAP
+	 *  directory matches the email filter. 
+         */
+        person_count = ldap_count_entries(ld, result);
+	if (getcert_shared->debugging & DEBUG_GEN_HI) {
+	    if (person_count == 1)
+	        syslog(LOG_DEBUG,
+		   "[%lu][debug] %.900s\n", conn->c_connid, 
+		    "One entry on this server matches the email address.");
+	    else
+	        syslog(LOG_DEBUG,
+		    "[%lu][debug] %d %.900s\n", conn->c_connid, person_count,
+		    "entries on this server match the email address.");
+	}
+        if (person_count < 1) {
+            /* No persons found that match the email filter. */
+	    if (getcert_shared->debugging & DEBUG_GEN_HI)
+    	        syslog(LOG_DEBUG,
+	          "[%lu] No matches found on this server for %.*s.\n",
+	          conn->c_connid, MAX_EMAIL_LENGTH, mailaddr);
+	    if (result != NULL) {
+		if (getcert_shared->debugging & DEBUG_MEM)
+                    syslog(LOG_DEBUG,
+			"[%lu][debug] %.900s\n", conn->c_connid,
+			"Releasing memory allocated for search results.");
+                ldap_msgfree(result);
+                result = NULL;
+            }
+	    server_number++;
+	    /* Move on to the next LDAP server. */
+            ldap_unbind(ld);
+	    ld = NULL;
+	    continue;
+        }
+
+        /*
+         * Check the attributes of each person returned by the search.
+         * If more than one person can match the specified email
+	 * address, we collect certificates from all of them.
+         */
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Allocating memory for BerElement structure.\n", conn->c_connid);
+	for (entry = ldap_first_entry(ld, result); 
+	     entry != NULL;
+	     entry = ldap_next_entry(ld, entry)) {
+	    /* Search through the attributes for this entry. */
+            for (attr = ldap_first_attribute(ld, entry, &ber);
+                 attr != NULL;
+                 attr = ldap_next_attribute(ld, entry, ber)) {
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+			"[%lu][debug] %.900s\n", conn->c_connid,
+			"Allocated memory for attribute structure.");
+    	        if (getcert_shared->debugging & DEBUG_GEN_LO)
+    	            syslog(LOG_DEBUG,
+		        "[%lu][debug] Next attr is %.900s\n", conn->c_connid, attr);
+    	        /* Check for certificates first. */
+		len = strlen(cert_server_list[server_number]->cert_attr);
+		if (len < MAX_ATTRIBUTE_NAME - 7) {
+		   strncpy(attrbuff, cert_server_list[server_number]->cert_attr, len + 1);
+		   attrbuff[len] = '\0';
+		} else {
+		    attrbuff[0] = '\0';
+		}
+		if (strcasecmp(attr, attrbuff) == 0)
+    	            valid_certs +=
+			get_certificates(be, conn, priv, ld, entry, attr, mailaddr, valid_certs);
+		else if (strcasecmp(attr, strncat(attrbuff, ";binary", 7)) == 0)
+			valid_certs +=
+			get_certificates(be, conn, priv, ld, entry, attr, mailaddr, valid_certs);
+    	        else {
+    	            /* 
+		     * Check the rest of the attributes for
+		     * the person's name and search DN.
+		     */
+                    if ((vals = ldap_get_values(ld, entry, attr)) != NULL) {
+		        if (getcert_shared->debugging & DEBUG_MEM)
+                            syslog(LOG_DEBUG,
+				"[%lu][debug] %.900s\n", conn->c_connid,
+				"Allocated memory for attribute values.");
+                        for (i = 0; vals[i] != NULL; i++) {
+    		            if (strcasecmp(attr, cert_server_list[server_number]->personname_attr)
+				    == 0) {
+    		                if (isalpha((int) *vals[i])) 
+    		                    strncpy(commonname, vals[i], (int)sizeof(commonname) - 1);
+				if (getcert_shared->debugging)
+    			            syslog(LOG_INFO,
+    			                "[%lu] Person name is %.900s\n",
+					conn->c_connid, commonname);
+			    } else 
+			    /*
+			     * "cn" may have been overridden by personname_attr,
+			     * but if the new attr is not found we may be able 
+			     * to use this cn instead to build the unique dn.
+			     */
+			    if (strcasecmp(attr, "cn") == 0) {
+			        if ((commonname[0] == '\0') && (isalpha((int) *vals[i]))) {
+				    strncpy(commonname, vals[i], (int)sizeof(commonname) - 1);
+				}
+			    } else
+    		            if (strcasecmp(attr, "dn") == 0) {
+    		                strncpy(searchdn, vals[i], (int)sizeof(searchdn) - 1);
+				if (getcert_shared->debugging)
+    				    syslog(LOG_INFO,
+    				        "[%lu] Search result DN is %.900s\n",
+				        conn->c_connid, searchdn);
+    		            }
+        	        } /* next vals */
+			if (getcert_shared->debugging & DEBUG_MEM)
+			    syslog(LOG_DEBUG,
+				"[%lu][debug] %.128s\n", conn->c_connid,
+				"Releasing memory allocated for attribute values.");
+    		        ldap_value_free( vals );
+                    } /* end of vals for this attr */
+    	        } /* not a certificate attribute */
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+		        "[%lu][debug] %.900s\n", conn->c_connid,
+			"Releasing memory allocated for attribute structure.");
+    	        ldap_memfree( attr );
+            } /* ldap_next_attribute */
+	    if (attr == NULL) {
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+		       "[%lu][debug] %.900s\n", conn->c_connid, 
+		       "Memory allocated for BerElement structure was released.");
+        	if (ber != NULL)
+		    ber = NULL;
+	    }
+	} /* ldap_next_entry */
+    
+    	/* We're finished talking with this server. */
+        if (ber != NULL) {
+            if (getcert_shared->debugging & DEBUG_MEM)
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] %.900s\n", conn->c_connid,
+                    "Releasing memory allocated for BerElement structure.");
+            ber_free(ber, 0);
+        }
+	if (result != NULL) {
+	    if (getcert_shared->debugging & DEBUG_MEM)
+	        syslog(LOG_DEBUG,
+		    "[%lu][debug] %.900s\n", conn->c_connid,
+		    "Releasing memory allocated for search results.");
+            ldap_msgfree(result);
+	    result = NULL;
+	}
+        ldap_unbind(ld);
+	ld = NULL;
+
+	if ((valid_certs < 1) || (getcert_shared->search_all_servers == TRUE))
+	    server_number++; 
+	if (valid_certs >= getcert_shared->MAX_CERTIFICATES) {
+            syslog(LOG_INFO,
+                "[%lu][error] Found %d certificates.  No space available for more.\n",
+                conn->c_connid, valid_certs);
+            syslog(LOG_INFO,
+                "[%lu][error] %.64s the \"max_certificates\" config option.\n",
+                conn->c_connid, "Perhaps you should increase");
+            break;
+        }
+    } /* Next certificate server */
+
+    /*
+     * Did we find any valid certificates for this email address?
+     */
+    if (valid_certs < 1) {
+	/* No valid certificates to return. */
+	/* Did we even find the person?     */
+	if (commonname[0] != '\0') {
+	    /* We found the person, not that this helps us. */
+	    if (getcert_shared->debugging == DEBUG_NONE) {
+		len2 = (MAX_LOG_REC - strlen(priv->log_buffer)) - 1;
+		ptr = priv->log_buffer + strlen(priv->log_buffer);
+		snprintf(ptr, len2, "No valid certificates found for %s\n", mailaddr);
+	    } else {
+	        syslog(LOG_INFO,
+		    "[%lu] %.64s %.800s %.64s\n", conn->c_connid, 
+		    "No valid certificates found for", mailaddr, "in any LDAP directory.");
+	    }
+	    if (getcert_shared->limit_return_codes)
+            {
+                rs->sr_err = LDAP_SUCCESS;
+                rs->sr_text = getcert_err_msg[GETCERT_SUCCESS];
+                send_ldap_result(op, rs);
+            }
+	    else
+            {
+                rs->sr_err = LDAP_NO_SUCH_ATTRIBUTE;
+                rs->sr_text = getcert_err_msg[GETCERT_NO_VALID_CERTS];
+                send_ldap_result(op, rs);
+            }
+	} else {
+	    /* Did not find person in any LDAP server. */
+	    if (getcert_shared->debugging == DEBUG_NONE) {
+                len2 = (MAX_LOG_REC - strlen(priv->log_buffer)) - 1;
+		ptr = priv->log_buffer + strlen(priv->log_buffer);
+                snprintf(ptr, len2, "No certificate found for %s", mailaddr);
+	    } else {
+	        syslog(LOG_INFO,
+		    "[%lu] Did not find %.900s in any LDAP directory.\n",
+		    conn->c_connid, mailaddr);
+	    }
+	    if (getcert_shared->limit_return_codes)
+            {
+                rs->sr_err = LDAP_SUCCESS;
+                rs->sr_text = getcert_err_msg[GETCERT_SUCCESS];
+                send_ldap_result(op, rs);
+            }
+	    else
+            {
+                rs->sr_err = LDAP_NO_SUCH_OBJECT;
+                rs->sr_text = getcert_err_msg[GETCERT_NO_SUCH_PERSON];
+                send_ldap_result(op, rs);
+            }
+	}
+    } else {
+        /*
+	 *  Valid certificate(s) have been found.
+	 */
+	if (getcert_shared->debugging & DEBUG_GEN_HI) {
+	    if (getcert_shared->certificate_check > 1) {
+	        syslog(LOG_DEBUG, 
+	            "[%lu] %d valid certificate(s) found for %.900s\n",
+	            conn->c_connid, valid_certs, mailaddr);
+	    } else {
+	        syslog(LOG_DEBUG, 
+	            "[%lu] %d certificate(s) found for %.900s\n",
+	            conn->c_connid, valid_certs, mailaddr);
+	    }
+	}
+
+	/*
+	 * We need a CN value to build the unique DN 
+	 * that we return with the certificate(s).
+	 */
+	if (commonname[0] == '\0') {
+	    if (getcert_shared->debugging & DEBUG_GEN_HI)
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] %.900s\n", conn->c_connid,
+		    "No CN value found. Using email address for CN.");
+	    len = strlen(mailaddr) + 1;
+	    if (len < MAX_STRING) {
+		strncpy(commonname, mailaddr, len);
+		commonname[len] = '\0';
+	    } else {
+		strncpy(commonname, mailaddr, MAX_STRING - 1);
+		commonname[MAX_STRING - 1] = '\0';
+	    }
+	} else {
+	    /*
+	     * The CN (CommonName) value returned with the certificates
+	     * may be in the form "Last, First".  Since this value will
+	     * become part of the DN value returned to the LDAP client,
+	     * OpenLDAP will have the comma replaced by "\2C" so that it 
+	     * is not mistaken for a comma delimiter in the DN string.
+	     * However, some LDAP clients aren't smart enough to 
+	     * understand what "\2C" means.  So we give the proxy admin
+	     * the choice of having the CN rewritten to remove the comma.
+	     * That should catch "Last, First" names and rewrite them 
+	     * as "First Last".  If there is more than one comma in the
+	     * CN, we don't know what it is and don't try to rewrite it.
+	     */
+	    if (getcert_shared->normalize_common_name) {
+		ptr = strchr(commonname, ',');
+		if (ptr != NULL) {
+		    ptr2 = strrchr(commonname, ',');
+		    if (ptr2 == ptr) {
+			/*
+			 * Only one comma, so swap the text
+			 * on either side of the comma. 
+			 */
+			len = strlen(commonname);
+			/* Length of left side. */
+			len1 = ptr - commonname;
+			/* Length of right side. */
+			len2 = strlen(commonname) - (len1 + 1);
+			strncpy(tempbuff, ptr + 1, len2);
+			tempbuff[len2] = '\x20';
+			strncpy(tempbuff + len2 + 1, commonname, len1);
+			tempbuff[len] = '\0';
+			/* Skip over any space chars following the comma. */
+			ptr = tempbuff;
+			ptr2 = tempbuff + len;
+			while ((ptr[0] == '\x20') && (ptr < ptr2)) {
+			    ptr++;
+			    len--;
+			}
+	    		if (getcert_shared->debugging & DEBUG_GEN_HI) {
+                	    syslog(LOG_DEBUG,
+                    		"[%lu][debug] CommonName of: %.900s\n",
+				conn->c_connid, commonname);
+                	    syslog(LOG_DEBUG,
+                    		"[%lu][debug]  Rewritten as: %.900s\n",
+				conn->c_connid, ptr);
+			}
+			strncpy(commonname, ptr, len);
+			commonname[len] = '\0';
+		    } /* More than one comma. */
+		} /* No commas */
+	    } /* normalize_common_name not enabled */
+	}
+
+	/*
+	 * Convert the valid certificates to Base64 format 
+	 * so they can be inserted into the LDIF structure.
+	 */
+	for (i = 0; i < priv->cert_number; i++) {
+            if (priv->certificates[i]->cert_der_length > 0) {
+                /* Convert binary certificate to Base64 */
+                priv->certificates[i]->cert_b64_length =
+		    base64_encode(be, conn, priv, priv->certificates[i]->der_certificate,
+                                  priv->certificates[i]->cert_der_length, priv->certbuffer,
+                                  MAX_CERTIFICATE_SIZE);
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+			"[%lu][debug] Allocating %d bytes of memory for Base64 certificate %d.\n",
+			conn->c_connid, priv->certificates[i]->cert_b64_length, i + 1);
+		priv->certificates[i]->b64_certificate =
+			malloc(priv->certificates[i]->cert_b64_length);
+		if (priv->certificates[i]->b64_certificate == NULL) {
+		    syslog(LOG_INFO,
+			"[%lu][error] Unable to allocate %d memory bytes for Base64 certificate.\n",
+			conn->c_connid, priv->certificates[i]->cert_b64_length);
+		    priv->certificates[i]->cert_b64_length = 0;
+		} else {
+                    strncpy(priv->certificates[i]->b64_certificate,
+			    priv->certbuffer, priv->certificates[i]->cert_b64_length);
+                    if (getcert_shared->debugging & DEBUG_DATA)
+                        syslog(LOG_DEBUG,
+                            "[%lu][debug] Certificate %d base64 length is %d\n",
+                            conn->c_connid, i + 1, priv->certificates[i]->cert_b64_length);
+	        }
+	    }
+	}
+
+	/*
+         *  Output format of LDIF converts to an Entry type so slapd 
+         *  can read the search results.  We allocate memory to hold 
+         *  the LDIF string.  Figure out how long the LDIF structure 
+	 *  will be so we know how much memory to allocate.
+         */
+	for (i = 0, len = 0; i < priv->cert_number; i++) {
+	    /* attribute name, binary tag, base64 cert length */
+	    j = strlen(priv->certificates[i]->cert_attribute) + 10 +
+		       priv->certificates[i]->cert_b64_length;
+            /* Add LDIF line continuation chars "<nl><sp>" */
+            len += j + (((j / 75) + 1) * 2);
+        }
+	/*
+	 * A unique DN will be built from CN + baseDN.
+	 * If the baseDN was defined as "null" in the servers
+	 * list, use the searchDN returned with the certificate.
+	 */
+        /*  dn: cn="Last\2C First",dc=org,dc=company,dc=com\n  */
+        len += strlen(commonname) + 12;
+        /*  base dn or "c=us"  */
+	if (getcert_shared->search_all_servers == TRUE) {
+	    len += 4 + 1;
+	} else {
+            if (cert_server_list[server_number]->base_dn[0] == '\0') {
+	        if (searchdn[0] == '\0')
+		    len += 4 + 1;
+	        else
+		    len += strlen(searchdn) + 4 + 1;
+	    } else
+	        len += strlen(cert_server_list[server_number]->base_dn) + 4 + 1;
+	}
+
+	/*  common name  */
+	len += strlen(commonname) + 4 + 1;
+	/*  email address */
+	len += strlen(mailaddr) + 6 + 1;
+        if (getcert_shared->debugging & DEBUG_GEN_HI)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] %.900s %d bytes long.\n",
+                conn->c_connid, "LDIF data estimated to be less than", len);
+	/* objectClass: pkiUser */
+	len += 20 + 1;
+	/* Plus a fudge factor. */
+	len += 512;
+
+	/* Allocate memory to hold LDIF string. */
+	/* It will be released by the send_search_results routine */
+	/* unless we run into problems before we call it.         */
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] Allocating %d bytes of memory %.128s\n",
+		conn->c_connid, len, "for LDIF structure.");
+	memptr = malloc(len + 32);
+	if (memptr == NULL) {
+	    if (getcert_shared->limit_return_codes)
+            {
+                rs->sr_err = LDAP_OPERATIONS_ERROR;
+                rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+                send_ldap_result(op, rs);
+            }
+	    else
+            {
+                rs->sr_err = LDAP_RESULTS_TOO_LARGE;
+                rs->sr_text = getcert_err_msg[GETCERT_ERR_TOO_LARGE];
+                send_ldap_result(op, rs);
+            }
+   	    /* Release the certificate structures. */
+	    release_certificate_buffers(be, conn, priv);
+            return;
+	} else {
+	    memlen = len + 32;
+	}
+
+	/*
+	 * Copy desired attributes to a buffer in LDIF format for input to
+	 * str2entry.  Must use standard attributes names of cn & mail rather 
+	 * than attribute names defined in LDAP server list or they will be 
+	 * rejected by str2entry.
+	 */
+
+	ldiflines = 0;
+	if (getcert_shared->search_all_servers == TRUE) {
+	    /* Certs could be from multiple BaseDN's. */
+	    rc = snprintf(memptr, memlen, "dn: cn=\"%s\", c=us\n", commonname);
+	} else {
+	    if (cert_server_list[server_number]->base_dn[0] == '\0') {
+	        /* Base DN is NULL in server list so use the */
+	        /* search DN returned with the certificate.  */
+	        if (searchdn[0] == '\0') {
+		    /* We found a certificate but did not get a search DN */
+                    /* returned.  We'll have to make one up (c=us).       */
+		    rc = snprintf(memptr, memlen, "dn: cn=\"%s\", c=us\n", commonname);
+		    if (getcert_shared->debugging & DEBUG_GEN_HI)
+		        syslog(LOG_DEBUG,
+			    "[%lu][debug] %.900s\n", conn->c_connid,
+			    "Base DN is null & no search DN received.");
+	        } else {
+		    /* The base DN in the server list was null, so we'll */
+		    /* use the search DN returned with the certificate.  */
+	            /* Quote the commonname RDN in case there are embedded commas. */
+		    rc = snprintf(memptr, memlen, "dn: cn=\"%s\", %s\n", commonname, searchdn);
+		    if (getcert_shared->debugging & DEBUG_GEN_HI)
+		        syslog(LOG_DEBUG,
+		            "[%lu][debug] %.80s %.900s.\n", conn->c_connid,
+			    "Base DN is null but received search DN of", searchdn);
+	        }
+	    } else {
+	        rc = snprintf(memptr, memlen, "dn: cn=\"%s\",%s\n",
+		    commonname, cert_server_list[server_number]->base_dn);
+	    }
+	}
+	len2 = strlen(memptr);
+	if (len2 < MAX_DN_LENGTH) {
+	    strncpy(priv->unique_ndn, memptr, len2 + 1);
+	    priv->unique_ndn[len2] = '\0';
+	} else {
+	    strncpy(priv->unique_ndn, memptr, MAX_DN_LENGTH);
+	    priv->unique_ndn[MAX_DN_LENGTH - 1] = '\0';
+	}	
+
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Returning a unique DN of %.900s\n",
+		conn->c_connid, priv->unique_ndn);
+	len = rc;
+	ldiflines++;
+
+	rc = snprintf(&memptr[len], memlen - len, "objectClass: pkiUser\n");
+	len += rc;
+	ldiflines++;
+
+	rc = snprintf(&memptr[len], memlen - len, "cn: %s\n", commonname);
+	if (getcert_shared->debugging & DEBUG_GEN_HI) 
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Common name is %.900s\n", conn->c_connid, commonname);
+	len += rc;
+	ldiflines++;
+
+	rc = snprintf(&memptr[len], memlen - len, "mail: %s\n", mailaddr);
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Email address is %.900s\n", conn->c_connid,  mailaddr);
+	len += rc;
+	ldiflines++;
+
+	for (i = 0; i < priv->cert_number; i++) {
+	    if (getcert_shared->debugging & DEBUG_GEN_LO)
+	        syslog(LOG_DEBUG,
+		    "[%lu][debug] Length of base64 certificate %d is %d\n",
+		    conn->c_connid, i + 1, priv->certificates[i]->cert_b64_length);
+	    if (priv->certificates[i]->cert_b64_length > 0) {
+	        /* Will this cert fit in our LDIF buffer? */
+		j = strlen(priv->certificates[i]->cert_attribute) + 10 +
+			   priv->certificates[i]->cert_b64_length;
+                if (len + j + (((j / 75) + 1) * 2) >= memlen) {
+                    syslog(LOG_INFO,
+                        "[%lu][error] %.64s %d certificates.\n",
+                        conn->c_connid, "Not enough buffer space allocated to hold",
+                        priv->cert_number - 1);
+                    syslog(LOG_INFO,
+                        "[%lu][error] Returning only %d certificates.\n", conn->c_connid, i);
+                    break;
+                }
+		/*
+		 * Return all base64 encoded userCertificate tagged with ";binary".
+		 * Do not return base64 encoded userSMIMECertificate with ";binary".
+		 * OpenLDAP will insist on this.
+		 */
+		k = strlen(priv->certificates[i]->cert_attribute);
+		strncpy(&memptr[len], priv->certificates[i]->cert_attribute, k);
+		len += k;
+		if (strcasecmp(priv->certificates[i]->cert_attribute,
+			       "userSMIMECertificate") != 0) {
+		    if (strstr(priv->certificates[i]->cert_attribute, ";binary") == NULL) {
+		        strncpy(&memptr[len], ";binary", 7);
+		        len += 7;
+		        k += 7;
+		    }
+		}
+		strncpy(&memptr[len], ":: ", 3);
+		len += 3;
+		k += 3;
+		ldiflines++;
+		certptr = &priv->certificates[i]->b64_certificate[0];
+		certlength = priv->certificates[i]->cert_b64_length;
+		if (priv->certificates[i]->cert_b64_length < (76 - k)) {
+		    rc = snprintf(&memptr[len], memlen - len, "%s\n", certptr);
+		    len += rc;
+		    ldiflines++;
+		} else {
+		    /* First line of cert output. */
+		    for (j = 0; j < (78 - k); j++) 
+			memptr[len++] = certptr[j];
+		    memptr[len++] = '\n';
+		    ldiflines++;
+		    memptr[len++] = ' ';
+		    certptr += j;
+		    certlength -= j;
+		    /* Intermediate lines of cert output. */
+		    while ((certlength) > 77) {
+		        for (j = 0; j < 77; j++)
+			    memptr[len++] = certptr[j];
+		        memptr[len++] = '\n';
+			ldiflines++;
+		        memptr[len++] = ' ';
+			certptr += 77;
+			certlength -= 77;
+		    }
+		    /* Last line of cert output. */
+		    for (j = 0; certlength > 0; certlength--)
+		        memptr[len++] = certptr[j++];
+		    memptr[len++] = '\n';
+		    ldiflines++;
+		    memptr[len] = '\n';
+		    ldiflines++;
+		    memptr[len + 1] = '\0';
+		}
+	        if (getcert_shared->debugging & DEBUG_GEN_HI)
+		    syslog(LOG_DEBUG,
+		        "[%lu][debug] Wrote certificate %d to ldif buffer.\n",
+		        conn->c_connid, i + 1);
+	    }
+	} /* next cert */
+
+        /* Are we still within our buffer bounds? */
+        ldifsize = strlen(memptr);
+        if (ldifsize >= memlen) {
+            syslog(LOG_INFO,
+                "[%lu][error] %.900s\n", conn->c_connid,
+		"Not enough buffer space to convert search results.");
+            rs->sr_err = LDAP_OPERATIONS_ERROR;
+            rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+            send_ldap_result(op, rs);
+            if (memptr != NULL) {
+		if (getcert_shared->debugging & DEBUG_MEM)
+	    	    syslog(LOG_DEBUG,
+	        	"[%lu][debug] Releasing memory allocated for LDIF structure.\n",
+			conn->c_connid);
+                free(memptr);
+                memptr = NULL;
+            }
+   	    /* Release the certificate structures. */
+	    release_certificate_buffers(be, conn, priv);
+            return;
+        }
+
+	/* Return the search results to the client. */
+	rc = send_search_results(be, conn, op, attrs, attrsonly, memptr, priv->unique_ndn, rs);
+	if (rc < 0) {
+	    /* Couldn't return results. */
+            rs->sr_err = LDAP_OPERATIONS_ERROR;
+            rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+            send_ldap_result(op, rs);
+	    if (memptr != NULL) {
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+			"[%lu][debug] %.900s\n", conn->c_connid,
+			"Releasing memory allocated for LDIF structure.");
+		free(memptr);
+		memptr = NULL;
+	    }
+   	    /* Release the certificate structures. */
+	    release_certificate_buffers(be, conn, priv);
+    	    return;
+	}
+
+	/*
+	 * Save the LDIF data in case we need to resend it to a 
+	 * client that sends multiple LDAP queries for each search.
+	 */
+	for (i = 0; i < getcert_shared->MAX_RESULTS_CACHE; i++) {
+	    if (getcert_shared->last_search_results[i].ldif_ptr == NULL) {
+	        len = strlen(priv->client_ip);
+	        len2 = strlen(priv->unique_ndn);
+	        if ((len < MAX_IP_LENGTH) && (len2 < MAX_DN_LENGTH)) {
+		    /* client IP */
+		    strncpy(getcert_shared->last_search_results[i].client_ip_addr,
+			    priv->client_ip, len);
+		    getcert_shared->last_search_results[i].client_ip_addr[len] = '\0';
+		    /* normalized DN */
+		    strncpy(getcert_shared->last_search_results[i].unique_ndn,
+			    priv->unique_ndn, len2);
+		    getcert_shared->last_search_results[i].unique_ndn[len2] = '\0';
+		    /* search filter */
+		    if (filterstr->bv_len < MAX_FILTER_LEN)
+			len = filterstr->bv_len;
+		    else 
+			len = MAX_FILTER_LEN;
+		    strncpy(getcert_shared->last_search_results[i].filterstr,
+			    filterstr->bv_val, len);
+		    getcert_shared->last_search_results[i].filterstr[len] = '\0';
+		    /* search attributes */
+		    if (attrs == NULL) {
+			getcert_shared->last_search_results[i].search_attrs[0] = NULL;
+		    } else {
+			for (j = 0; attrs[j].an_name.bv_val != NULL ; j++) {
+    			    if (j >= (MAX_ATTRIBUTES - 1)) {
+				getcert_shared->last_search_results[i].search_attrs[j] = NULL;
+				if (getcert_shared->debugging & DEBUG_GEN_HI)
+	    			    syslog(LOG_DEBUG,
+					"[%lu][debug] Could only cache %d %.64s\n",
+					conn->c_connid, j + 1, "search attribute names.");
+				break;
+    			    }
+			    if (getcert_shared->debugging & DEBUG_MEM)
+        		        syslog(LOG_DEBUG,
+	    			    "[%lu][debug] Allocating %d %.96s\n",
+	    			    conn->c_connid, attrs[j].an_name.bv_len + 1,
+	    			    "bytes of memory for use in results cache.");
+			    getcert_shared->last_search_results[i].search_attrs[j] =
+				    malloc(attrs[j].an_name.bv_len + 1);
+    			    if (getcert_shared->last_search_results[i].search_attrs[j] == NULL) {
+        		        syslog(LOG_INFO,
+	    			    "[%lu][error] Unable to allocate %d %.96s\n",
+	    			    conn->c_connid, attrs[j].an_name.bv_len + 1, 
+	    			    "bytes of memory for for use in results cache."); 
+        		        /* Don't cache this result. */
+			        if (memptr != NULL) {
+	    			    if (getcert_shared->debugging & DEBUG_MEM)
+				        syslog(LOG_DEBUG,
+		    			    "[%lu][debug] %.900s\n", conn->c_connid,
+		    			    "Releasing memory allocated for LDIF copy.");
+	    			    free(memptr);
+	    			    memptr = NULL;
+			        }
+			        break;
+    			    } else {
+			        strncpy(getcert_shared->last_search_results[i].search_attrs[j], 
+				        attrs[j].an_name.bv_val, attrs[j].an_name.bv_len);
+			        getcert_shared->last_search_results[i].search_attrs[j][attrs[j].an_name.bv_len] = '\0';
+    			    }
+    			    /* Current end of search attribute list. */
+    			    getcert_shared->last_search_results[i].search_attrs[j + 1] = NULL;
+		        }
+			if (getcert_shared->debugging & DEBUG_GEN_LO)
+    			    syslog(LOG_DEBUG,
+				"[%lu][debug] cached %d search attribute names.\n",
+				conn->c_connid, j);
+		    }
+		    /* Current time */
+		    getcert_shared->last_search_results[i].timestamp = slap_get_time();
+		    /* Search results in LDIF format */
+		    if (memptr != NULL) {
+		        getcert_shared->last_search_results[i].ldif_ptr = memptr;
+		        if (getcert_shared->debugging & DEBUG_GEN_HI)
+			    syslog(LOG_DEBUG,
+			        "[%lu][debug] %.96s (%d bytes) in row %d.\n",
+			        conn->c_connid, "Saved last results", strlen(memptr), i);
+		    }
+		    /* Debug checking */
+		    if (getcert_shared->debugging & DEBUG_GEN_LO) {
+			syslog(LOG_DEBUG,
+			    "[%lu][debug]     Client IP: %.64s\n",
+			    conn->c_connid, getcert_shared->last_search_results[i].client_ip_addr);
+			syslog(LOG_DEBUG,
+                            "[%lu][debug]     DN: %.256s\n",
+			    conn->c_connid, getcert_shared->last_search_results[i].unique_ndn);
+			syslog(LOG_DEBUG,
+                            "[%lu][debug]     Filter: %.256s\n",
+			    conn->c_connid, getcert_shared->last_search_results[i].filterstr);
+			syslog(LOG_DEBUG,
+                            "[%lu][debug]     Timestamp: %lu\n",
+			    conn->c_connid, getcert_shared->last_search_results[i].timestamp);
+			syslog(LOG_DEBUG,
+			    "[%lu][debug]     Search attributes:\n", conn->c_connid);
+			for (j = 0; 
+			     getcert_shared->last_search_results[i].search_attrs[j] != NULL;
+			     j++) {
+			    syslog(LOG_DEBUG,
+				"[%lu][debug]         %.128s\n", conn->c_connid,
+				getcert_shared->last_search_results[i].search_attrs[j]);
+			}
+		    }
+		} else {
+		    syslog(LOG_INFO,
+			"[%lu][error] Cannot save these search results.\n", conn->c_connid);
+	    	    if (memptr != NULL) {
+			if (getcert_shared->debugging & DEBUG_MEM)
+		    	    syslog(LOG_DEBUG,
+				"[%lu][debug] %.900s\n", conn->c_connid,
+				"Releasing memory allocated for LDIF copy.");
+			free(memptr);
+			memptr = NULL;
+	    	    }
+		}
+	        break;
+	    }
+	} /* Next table entry */
+	if ((i >= getcert_shared->MAX_RESULTS_CACHE) && (memptr != NULL)) {
+	    syslog(LOG_INFO,
+		"[%lu][error] %.80s (%d search results) for more entries.\n",
+		conn->c_connid, "last_search_results cache too full", i);
+	    if (memptr != NULL) {
+		if (getcert_shared->debugging & DEBUG_MEM)
+	    	    syslog(LOG_DEBUG,
+			"[%lu][debug] %.900s\n", conn->c_connid,
+			"Releasing memory allocated for LDIF structure.");
+		free(memptr);
+		memptr = NULL;
+	    }
+	}
+
+        /* Send an LDAP result code back to the client. */
+	if (valid_certs == 1) {
+	    if (getcert_shared->debugging == DEBUG_NONE) {
+		len2 = (MAX_LOG_REC - strlen(priv->log_buffer)) - 1;
+		ptr = priv->log_buffer + strlen(priv->log_buffer);
+		snprintf(ptr, len2, "Returned one certificate for %s", mailaddr);
+	    } else {
+	        syslog(LOG_INFO,
+		    "[%lu] Returned one certificate for %s\n", conn->c_connid, mailaddr);
+	    }
+	} else {
+	    if (getcert_shared->debugging == DEBUG_NONE) {
+		len2 = (MAX_LOG_REC - strlen(priv->log_buffer)) - 1;
+		ptr = priv->log_buffer + strlen(priv->log_buffer);
+		snprintf(ptr, len2, "Returned %d certificates for %s\n", valid_certs, mailaddr);
+	    } else {
+	        syslog(LOG_INFO,
+		    "[%lu] Returned %d certificates for %s\n",
+		    conn->c_connid, valid_certs, mailaddr);
+	    }
+	}
+        rs->sr_err = LDAP_SUCCESS;
+        rs->sr_text = NULL;
+        send_ldap_result(op, rs);
+    } /* Usable certificates found. */
+
+    /* Release the certificate structures. */
+    release_certificate_buffers(be, conn, priv);
+
+    return;
+} /* find_certificate */
+
+/*
+ * Find and return an object whose attribute name and baseDN were specified in
+ * the search request.  Note that there can be multiple objects in an LDAP entry
+ * with the same attribute name; a multi-value attribute in other words.
+ * Search the LDAP server list for servers that list the DN & attribute name
+ * until the object(s) are found or we run out of servers in the list.
+ * We complete all communications with the front-end process before we return
+ * from this routine so that all the calling routine needs to do is terminate.
+ */
+void
+find_object(
+    Backend        *be,
+    Connection     *conn,
+    Operation      *op,
+    struct berval  *base,
+    struct berval  *nbase,
+    struct berval  *filterstr,
+    AttributeName  *attrs,
+    int		   attrsonly,
+    struct getcert_private  *priv,
+    SlapReply      *rs
+    )
+{
+    int  i, j, k, attrlen, b64_obj_length, b64buff_size, bufferlen, entry_count,
+	 len, len2, longest, ldiflines, ldifsize, object, objlength, objremaining,
+	 rc, search_rc, server_number, total_obj_count, valid_objects;
+    char  *attr, *b64buff_ptr, *ldif_ptr, *objptr, *ptr, *scptr;
+    char  *ldap_attributes[] = { NULL, NULL };
+    LDAP  *ld;
+    LDAPMessage  *result, *entry;
+    BerElement  *ber;
+    struct getcert_data  *getcert_shared;
+    struct timeval  search_maxwait = {0, 0};
+
+    getcert_shared = be->be_private;
+
+    /*
+     * The base DN from the search request is used
+     * as a search string into the LDAP server list.
+     */
+    if (base->bv_len == 0) {
+	syslog(LOG_INFO,
+	    "[%lu] No search base DN specified in the search request.\n",
+	    conn->c_connid);
+	if (getcert_shared->limit_return_codes)
+        {
+            rs->sr_err = LDAP_OPERATIONS_ERROR;
+            rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+            send_ldap_result(op, rs);
+        }
+	else
+        {
+            rs->sr_err = LDAP_OPERATIONS_ERROR;
+            rs->sr_text = getcert_err_msg[GETCERT_NO_BASEDN];
+            send_ldap_result(op, rs);
+        }
+	return;
+    }
+
+    b64buff_ptr = NULL;
+    ldif_ptr = NULL;
+    total_obj_count = 0;
+    priv->attr_vals = NULL;
+    priv->object_lengths = NULL;
+
+    /*
+     * Start searching the LDAP server list for servers that contain
+     * the specified baseDN.
+     */
+    server_number = 0;
+    while ((priv->attr_vals == NULL) && (server_number >= 0) && (base->bv_len > 0)) {
+        server_number = search_ldap_server_list(be, conn, base, attrs, server_number);
+	if (server_number < 0)
+            /* We've reached the end of the LDAP server list. */
+            break;
+
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Next LDAP server to query for %.128s is: %.256s\n",
+	        conn->c_connid, ldap_server_list[server_number]->ldap_attr,
+	        ldap_server_list[server_number]->server_name);
+
+	/*
+         * Get a handle to an LDAP connection.
+         */
+        if (getcert_shared->debugging & DEBUG_GEN_HI)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] Initializing LDAP structures\n", conn->c_connid);
+
+        if ((ld = ldap_init(ldap_server_list[server_number]->server_name,
+                            ldap_server_list[server_number]->port)) == NULL ) {
+            syslog(LOG_INFO,
+                "[%lu][error] Unable to initialize LDAP structures.\n", conn->c_connid);
+            /* Move on to the next possible server in the LDAP server list. */
+            server_number++;
+            continue;
+        }
+
+	/*
+         * Bind to the LDAP server.  Do an anonymous bind
+         * if no bind DN is specified for this server.
+	 *
+	 * A bind is required in LDAP version 2 but optional in 
+	 * LDAP version 3.  We always bind so that we can determine
+	 * if the LDAP server is available before we send it a query,
+	 * which would have to wait through a timeout period before
+	 * returning if the server is unavailable.  Unfortunately,
+	 * OpenLDAP servers are configured by default to reject
+	 * queries from LDAP version 2 clients, and our bind makes
+	 * us look like an LDAP version 2 client.  So if our bind
+	 * fails with an LDAP_PROTOCOL_ERROR, we just continue on
+	 * with our query.  Adding "allow bind_v2" to the slapd.conf
+	 * file on the OpenLDAP server disables the rejection of 
+	 * clients requesting binds.
+         */
+	if (getcert_shared->debugging)
+            syslog(LOG_INFO,
+                "[%lu] Establishing LDAP connection to %.900s port %d\n",
+                conn->c_connid, ldap_server_list[server_number]->server_name,
+                ldap_server_list[server_number]->port);
+        if (ldap_server_list[server_number]->bind_dn[0] != '\0') {
+            rc = ldap_simple_bind_s(ld, ldap_server_list[server_number]->bind_dn,
+                        ldap_server_list[server_number]->bind_password);
+        } else {
+            /*  Anonymous bind  */
+            rc = ldap_simple_bind_s(ld, NULL, NULL);
+        }
+	if (rc == LDAP_PROTOCOL_ERROR) {
+	    if (getcert_shared->debugging & DEBUG_GEN_HI) {
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] %s\n", conn->c_connid,
+		    "LDAP server trying to reject us as an LDAP V2 client.");
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] %s\n", conn->c_connid,
+		    "We are an LDAP V3 client, so we will continue.");
+	    }
+	} else
+        if (rc != LDAP_SUCCESS) {
+            syslog(LOG_INFO, "[%lu] Bind failed to %.450s: %.450s\n",
+                conn->c_connid, ldap_server_list[server_number]->server_name,
+                ldap_err2string(rc));
+            /* Move on to the next possible server in the server list. */
+            server_number++;
+            continue;
+        }
+
+	/*
+	 * Perform the search using a generic search filter and
+	 * an attribute list containing the desired attribute name.
+	 */
+	search_maxwait.tv_sec = getcert_shared->search_timeout;
+        ldap_attributes[0] = ldap_server_list[server_number]->ldap_attr;
+
+	if (getcert_shared->debugging & DEBUG_GEN_LO) {
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] ldap_search parameters:\n", conn->c_connid);
+	    syslog(LOG_DEBUG,
+		"[%lu][debug]     Base DN: %s\n",
+		conn->c_connid, ldap_server_list[server_number]->ldap_dn);
+	    syslog(LOG_DEBUG,
+		"[%lu][debug]     Scope: LDAP_SCOPE_BASE\n", conn->c_connid);
+	    syslog(LOG_DEBUG,
+		"[%lu][debug]     Filter: %s\n",
+		conn->c_connid, generic_filter);
+	    for (i = 0; ldap_attributes[i] != NULL; i++)
+	        syslog(LOG_DEBUG,
+		    "[%lu][debug]     Attribute: %s\n",
+		    conn->c_connid, ldap_attributes[i]);
+	    syslog(LOG_DEBUG,
+		"[%lu][debug]     Max Wait: %d seconds\n",
+		conn->c_connid, search_maxwait.tv_sec);
+	}
+
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Beginning ldap search...\n", conn->c_connid);
+
+	/*
+	 * We are asking for just a single object to be returned.
+         */
+        search_rc = ldap_search_st(ld,
+            ldap_server_list[server_number]->ldap_dn, LDAP_SCOPE_BASE,
+            generic_filter, ldap_attributes, 0, &search_maxwait, &result);
+
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Allocated memory for search results.\n",
+		conn->c_connid);
+
+	if (search_rc != LDAP_SUCCESS) {
+	    /*
+             * The LDAP search failed.
+	     * Log the errors and release the
+	     * dynamically allocated memory.
+	     */
+	    search_failed(be, conn, search_rc,
+		ldap_server_list[server_number]->server_name, result);
+	    if (ld != NULL) {
+                ldap_unbind(ld);
+                ld = NULL;
+            }
+            server_number++;
+            continue;
+        }
+
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] Processing search results...\n", conn->c_connid);
+
+	/* Did we find any LDAP objects? */
+	entry_count = ldap_count_entries(ld, result);
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+            syslog(LOG_DEBUG,
+              "[%lu][debug] %d entries on this server match our LDAP search.\n",
+              conn->c_connid, entry_count);
+        if (entry_count < 1) {
+            /* No objects found that match our search criteria. */
+	    if (getcert_shared->debugging)
+                syslog(LOG_INFO,
+                    "[%lu] No matches for %s found on this LDAP server %.80s\n",
+                    conn->c_connid, ldap_attributes[0], "at the specified search DN.");
+            server_number++;
+            /* Move on to the next LDAP server. */
+            ldap_unbind(ld);
+	    ld = NULL;
+            continue;
+        }
+
+        /*
+         * Check the attributes of each entry returned by the search.
+         * If more than one entry matches our search criteria, we 
+	 * find the first entry that contains values for our specified
+	 * attribute and return those.
+         */
+        for (entry = ldap_first_entry(ld, result);
+             (entry != NULL) && (priv->attr_vals == NULL);
+             entry = ldap_next_entry(ld, entry)) {
+            /* Search through the attributes for this entry. */
+            for (attr = ldap_first_attribute(ld, entry, &ber);
+                 attr != NULL;
+                 attr = ldap_next_attribute(ld, entry, ber)) {
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+			"[%lu][debug] %.128s\n", conn->c_connid,
+			"Allocated memory for attribute structure.");
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+			"[%lu][debug] %.128s\n", conn->c_connid,
+			"Allocated memory for BerElement structure.");
+                if (getcert_shared->debugging & DEBUG_GEN_HI)
+                    syslog(LOG_DEBUG,
+                        "[%lu][debug] Next attr is %.900s\n",
+			conn->c_connid, attr);
+                /* We're only interested in one attribute. */
+		if (strcasecmp(attr, ldap_attributes[0]) != 0) {
+		    /* Make sure we aren't being fooled by attribute tags. */
+		    scptr = strchr(attr, ';');
+		    if (scptr == NULL)
+			len = strlen(attr);
+		    else
+			len = (int)(scptr - attr);
+		    scptr = strchr(ldap_attributes[0], ';');
+		    if (scptr == NULL)
+			attrlen = strlen(ldap_attributes[0]);
+		    else
+			attrlen = (int)(scptr - ldap_attributes[0]);
+		    if (len == attrlen) {
+			/* Compare the attribute names without the tags. */
+			if (strncasecmp(attr, ldap_attributes[0], len) != 0) {
+		    	    /* Not our attribute */
+		    	    if (getcert_shared->debugging & DEBUG_MEM)
+		        	syslog(LOG_DEBUG,
+		            	    "[%lu][debug] %.128s %.128s\n", conn->c_connid, 
+			    	    "Releasing memory allocated",
+			    	    "for attribute structure.");
+    	            	    ldap_memfree( attr );
+		    	    continue;
+			}
+		    }
+		}
+
+		/*
+		 * Get the attribute value(s).  We keep the values in the
+		 * the original LDAP memory locations.  The memory allocated
+		 * by this call will need to be freed later. 
+		 */
+		priv->attr_vals = ldap_get_values_len(ld, entry, attr);
+		if (priv->attr_vals == NULL) {
+		    syslog(LOG_INFO,
+		        "[%lu][error] Attribute %.128s contains no data.\n",
+			conn->c_connid, attr);
+		    if (getcert_shared->debugging & DEBUG_MEM)
+		        syslog(LOG_DEBUG,
+		            "[%lu][debug] %.128s\n", conn->c_connid,
+			    "Releasing memory allocated for attribute structure.");
+    	            ldap_memfree( attr );
+		    /* Move on to next attribute. */
+		    continue;
+		} else {
+		    if (getcert_shared->debugging & DEBUG_MEM)
+                        syslog(LOG_DEBUG,
+			    "[%lu][debug] Allocated memory for object list.\n",
+			    conn->c_connid);
+		    if (getcert_shared->debugging & DEBUG_GEN_LO)
+		        syslog(LOG_DEBUG,
+		            "[%lu][debug] Attribute value(s) have been retrieved.\n",
+			    conn->c_connid);
+		}
+		total_obj_count = ldap_count_values_len(priv->attr_vals);
+		if (total_obj_count < 1) {
+		    syslog(LOG_INFO,
+		        "[%lu][error] %s\n", conn->c_connid,
+			"Attribute value list is empty.  That\'s strange!");
+		    if (priv->attr_vals != NULL) {
+		        if (getcert_shared->debugging & DEBUG_MEM)
+		            syslog(LOG_DEBUG,
+		                "[%lu][debug] %.128s\n", conn->c_connid,
+			        "Releasing memory allocated for attribute values.");
+		        ldap_value_free_len(priv->attr_vals);
+                        priv->attr_vals = NULL;
+		    }
+                    /* Move on to next attribute. */
+		    if (getcert_shared->debugging & DEBUG_MEM)
+		        syslog(LOG_DEBUG,
+		            "[%lu][debug] %.128s %.128s\n", conn->c_connid,
+			    "Releasing memory allocated" "for attribute structure.");
+    	            ldap_memfree( attr );
+                    continue;
+		}
+
+		if (getcert_shared->debugging & DEBUG_GEN_LO) {
+		    for (i = 0; priv->attr_vals[i] != NULL; i++) {
+		        syslog(LOG_DEBUG,
+			    "[%lu][debug] %.64s %d is %d %.64s\n",
+			    conn->c_connid, "Object number", i + 1,
+			    (int)priv->attr_vals[i]->bv_len,
+			    "bytes in length and begins with:");
+			for (j = 0; j < 6; j++) {
+			    k = 0xFF & (int)(priv->attr_vals[i]->bv_val[j]);
+			    sprintf(&priv->content_buffer[j * 5], " 0x%2.2x", k);
+			}
+			syslog(LOG_DEBUG,
+			    "[%lu][debug]    %.256s\n",
+			    conn->c_connid, priv->content_buffer);
+		    }
+		}
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+		        "[%lu][debug] %.128s\n", conn->c_connid,
+			"Releasing memory allocated for attribute structure.");
+    	        ldap_memfree( attr );
+		/* We have data, skip the rest of the attributes. */
+		break;
+	    } /* ldap_next_attribute */
+	    if (attr == NULL) {
+		if (getcert_shared->debugging & DEBUG_MEM)
+		    syslog(LOG_DEBUG,
+		       "[%lu][debug] %.900s\n", conn->c_connid, 
+		       "Memory allocated for BerElement structure was released.");
+        	if (ber != NULL)
+		    ber = NULL;
+	    }
+        } /* ldap_next_entry */
+
+	/* We're finished talking with this server. */
+	if (ber != NULL) {
+	    if (getcert_shared->debugging & DEBUG_MEM)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] Releasing memory allocated for %.64s\n",
+		    conn->c_connid, "BerElement structure.");
+            ber_free(ber, 0);
+	}
+	if (result != NULL) {
+	    if (getcert_shared->debugging & DEBUG_MEM)
+	        syslog(LOG_DEBUG,
+	            "[%lu][debug] %.128s\n", conn->c_connid,
+		    "Releasing memory allocated for search results.");
+	    ldap_msgfree(result);
+	    result = NULL;
+	}
+	ldap_unbind(ld);
+	ld = NULL;
+	if (priv->attr_vals == NULL)
+	    server_number++;
+    } /* Next LDAP server */
+
+    /*
+     * Did we find any data with this baseDN?
+     */
+    if ((priv->attr_vals == NULL) || (total_obj_count < 1)) {
+        /* No data to return. */
+	if (getcert_shared->debugging == DEBUG_NONE) {
+	    len2 = (MAX_LOG_REC - strlen(priv->log_buffer)) - 1;
+	    strncat(priv->log_buffer, "No LDAP data found.", len2);
+	} else {
+	    syslog(LOG_INFO,
+	        "[%lu] Did not find any data in any LDAP server.\n", conn->c_connid);
+	}
+	if (getcert_shared->limit_return_codes)
+        {
+            rs->sr_err = LDAP_SUCCESS;
+            rs->sr_text = getcert_err_msg[GETCERT_SUCCESS];
+            send_ldap_result(op, rs);
+        }
+        else
+        {
+            rs->sr_err = LDAP_NO_SUCH_OBJECT;
+            rs->sr_text = getcert_err_msg[GETCERT_NO_CRL_FOUND];
+            send_ldap_result(op, rs);
+        }
+
+        return;
+    }
+
+    /* Data found on the last LDAP server searched. */
+    if (getcert_shared->debugging) {
+	if (total_obj_count == 1) {
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] One object found at: %.900s\n", conn->c_connid,
+	        ldap_server_list[server_number]->server_name);
+	} else {
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] %d objects found at: %.900s\n", conn->c_connid,
+	        total_obj_count, ldap_server_list[server_number]->server_name);
+	}
+    }
+
+    /*
+     * Assume, for the purposes of buffer sizing, that the data is binary
+     * and needs to be converted to base64 format.  How much memory will we
+     * need to build the base64 buffer and the final LDIF structure?
+     * Base64 encoding increases the data size by about 33%, so we will
+     * allocate enough memory for a 50% increase in size to be on the safe side.
+     */
+    longest = 0;	/* Length of longest value */
+    bufferlen = 4 + base->bv_len + 1;	/* DN data */
+    for (i = 0; priv->attr_vals[i] != NULL; i++) {
+        if (priv->attr_vals[i]->bv_len > longest)
+	    longest = priv->attr_vals[i]->bv_len;
+	bufferlen += strlen(ldap_attributes[0]) + strlen(":: ");
+	/* Allocate enough memory for 50% data size increase. */
+	len = (int)(priv->attr_vals[i]->bv_len * 1.5);
+	/* line continuation & <nl> */
+	bufferlen += ((len / 76) + 2) * 2;
+	bufferlen += len;
+    }
+
+    /* Do we have enough free memory available for this? */
+    if (getcert_shared->debugging & DEBUG_MEM)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Allocating %d bytes %.128s\n",
+	    conn->c_connid, bufferlen, "of memory for LDIF structure.");
+    ldif_ptr = malloc(bufferlen);
+    if (ldif_ptr == NULL) {
+        if (getcert_shared->limit_return_codes)
+        {
+            rs->sr_err = LDAP_OPERATIONS_ERROR;
+            rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+            send_ldap_result(op, rs);
+        }
+        else
+        {
+            rs->sr_err = LDAP_RESULTS_TOO_LARGE;
+            rs->sr_text = getcert_err_msg[GETCERT_ERR_TOO_LARGE];
+            send_ldap_result(op, rs);
+        }
+	if (priv->attr_vals != NULL) {
+	    if (getcert_shared->debugging & DEBUG_MEM)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] %.128s\n", conn->c_connid,
+		    "Releasing memory allocated for attribute values.");
+	    ldap_value_free_len(priv->attr_vals);
+	    priv->attr_vals = NULL;
+	}
+        return;
+    }
+
+    /* The only attributes we are returning with  */
+    /* the data are "DN" and the attribute name.  */
+    ldiflines = 0;
+    rc = snprintf(ldif_ptr, base->bv_len + 6, "dn: %s\n", base->bv_val);
+    ldiflines++;
+    ldif_ptr[base->bv_len + 6] = '\0';
+    len = strlen(ldif_ptr);
+    if (getcert_shared->debugging & DEBUG_GEN_LO) {
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Wrote DN to LDIF buffer:\n", conn->c_connid);
+	syslog(LOG_DEBUG,
+	    "[%lu][debug]    %s", conn->c_connid, ldif_ptr);
+    }
+    /*
+     * If the verify_type option is set in the ldap_server_list,
+     * this will be the number of objects that passed our tests.
+     */
+    valid_objects = 0;
+
+    /*
+     * We keep track of which objects passed the verification checks by
+     * keeping an array of object lengths.  If the length is greater than
+     * zero, the object passed the checks .  Otherwise, it is rejected 
+     * (ignored) by setting the object length to zero.
+     */
+    if (getcert_shared->debugging & DEBUG_MEM)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Allocating %d bytes of memory for object length list.\n",
+	    conn->c_connid, total_obj_count);
+    priv->object_lengths = malloc(total_obj_count);
+    if (priv->object_lengths == NULL) {
+	syslog(LOG_INFO,
+	    "[%lu][error] Cannot allocate %d bytes of memory. %.64s\n",
+	    conn->c_connid, total_obj_count, "Aborting object checks.");
+        for (object = 0; object < total_obj_count; object++)
+	    priv->object_lengths[object] = priv->attr_vals[object]->bv_len;
+	valid_objects = total_obj_count;
+    } else {
+        for (object = 0;
+	     (priv->attr_vals[object] != NULL) && (object < total_obj_count);
+	     object++) {
+	    /*
+	     * If the verification type is listed in the optional fifth
+	     * line of the LDAP server list entry, we run some simple
+	     * verification checks against the object.
+	     */
+	    if (ldap_server_list[server_number]->verification == CRL) {
+	        /*
+	         * Run some CRL checks.
+	         */
+	        priv->current_crl.crl_number = object;
+	        priv->current_crl.crl_length = priv->attr_vals[object]->bv_len;
+
+	        if (getcert_shared->debugging & DEBUG_GEN_HI)
+		    syslog(LOG_DEBUG,
+		        "[%lu][debug] Decoding & checking CRL %d.\n",
+		        conn->c_connid, object + 1);
+	        rc = decode_crl(be, conn, priv);
+	        if (rc < 0) {
+		    syslog(LOG_INFO,
+		        "[%lu][error] CRL %d failed check. Rejecting it.\n",
+		        conn->c_connid, object + 1);
+		    /* Skip this CRL. */
+		    priv->object_lengths[object] = 0;
+	        } else {
+		    priv->object_lengths[object] = priv->attr_vals[object]->bv_len;
+		    valid_objects++;
+	        }
+	    } else
+
+	    if (ldap_server_list[server_number]->verification == CERT) {
+	        /*
+	         * Run some certificate checks.
+	         */
+	        if (getcert_shared->debugging & DEBUG_GEN_LO)
+		    syslog(LOG_DEBUG,
+    		        "[%lu][debug] Decoding & checking certificate %d.\n",
+    		        conn->c_connid, object + 1);
+		
+	        	/*
+			 * [UNIMPLEMENTED]
+ 	         	 * Figure out how to set things up
+	         	 * to run decode_certificate().
+ 	         	 * Then call cert_validity_checking().
+ 	         	 */
+			priv->object_lengths[object] = priv->attr_vals[object]->bv_len;
+			valid_objects++;
+
+	    } else {
+		/* No verification type or unknown verification type. */
+		priv->object_lengths[object] = priv->attr_vals[object]->bv_len;
+	        valid_objects++;
+	    }
+	} /* Next object */
+    } /* Finished with object checks. */
+
+    /* Did any objects pass the verification checks? */
+    if ((ldap_server_list[server_number]->verification != NONE) && (valid_objects < 1)) {
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] No valid objects to return of type %.128s.\n",
+		conn->c_connid, ldap_attributes[0]);
+	if (getcert_shared->limit_return_codes)
+        {
+            rs->sr_err = LDAP_SUCCESS;
+            rs->sr_text = getcert_err_msg[GETCERT_SUCCESS];
+            send_ldap_result(op, rs);
+        }
+	else
+        {
+            rs->sr_err = LDAP_NO_SUCH_ATTRIBUTE;
+            rs->sr_text = getcert_err_msg[GETCERT_NO_VALID_DATA];
+            send_ldap_result(op, rs);
+        }
+        if (priv->object_lengths != NULL) {
+	    if (getcert_shared->debugging & DEBUG_MEM)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] Releasing memory allocated for object_lengths.\n",
+		    conn->c_connid);
+	    free(priv->object_lengths);
+	    priv->object_lengths = NULL;
+	}
+	if (priv->attr_vals != NULL) {
+	    if (getcert_shared->debugging & DEBUG_MEM)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] %.128s\n", conn->c_connid,
+		    "Releasing memory allocated for attribute values.");
+	    ldap_value_free_len(priv->attr_vals);
+	    priv->attr_vals = NULL;
+	}
+        return;
+    } else {
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] %d objects to be returned to requestor.\n",
+		conn->c_connid, valid_objects);
+    }
+
+    /*
+     * Binary data gets converted to base64 format.
+     */
+    for (object = 0; object < total_obj_count; object++) {
+	if (((priv->attr_vals[object]->bv_val[0] == 0x30) &&
+            ((priv->attr_vals[object]->bv_val[1] & 0xF0) == 0x80)) ||
+            (strncmp(priv->attr_vals[object]->bv_val, "-----BEGIN", 10) == 0)) {
+
+    	    /* Allocate a buffer to hold the base64 converted   */
+    	    /* data as they are being converted to LDIF format. */
+    	    b64buff_size = (int)(longest * 1.5);
+    	    if (getcert_shared->debugging & DEBUG_MEM)
+        	    syslog(LOG_DEBUG,
+	    	    "[%lu][debug] Allocating %d bytes of memory %.128s\n",
+	    	    conn->c_connid, b64buff_size, "for base64 buffer.");
+    	    b64buff_ptr = malloc(b64buff_size);
+    	    if (b64buff_ptr == NULL) {
+        	    if (getcert_shared->limit_return_codes)
+                    {
+                        rs->sr_err = LDAP_OPERATIONS_ERROR;
+                        rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+                        send_ldap_result(op, rs);
+                    }
+        	    else
+                    {
+                        rs->sr_err = LDAP_RESULTS_TOO_LARGE;
+                        rs->sr_text = getcert_err_msg[GETCERT_ERR_TOO_LARGE];
+                        send_ldap_result(op, rs);
+                    }
+		    if (priv->attr_vals != NULL) {
+	    	        if (getcert_shared->debugging & DEBUG_MEM)
+			    syslog(LOG_DEBUG,
+		    	        "[%lu][debug] %.128s\n", conn->c_connid,
+		    	        "Releasing memory allocated for attribute values.");
+	    	        ldap_value_free_len(priv->attr_vals);
+	    	        priv->attr_vals = NULL;
+		    }
+        	    if (priv->object_lengths != NULL) {
+	    	        if (getcert_shared->debugging & DEBUG_MEM)
+			    syslog(LOG_DEBUG,
+		    		"[%lu][debug] Releasing memory allocated for object_lengths.\n",
+		    		conn->c_connid);
+			free(priv->object_lengths);
+	    		priv->object_lengths = NULL;
+		    }
+	            if (ldif_ptr != NULL) {
+	                if (getcert_shared->debugging & DEBUG_MEM)
+		            syslog(LOG_DEBUG,
+			        "[%lu][debug] %.128s\n", conn->c_connid, 
+			        "Releasing memory allocated for LDIF structure.");
+		        free(ldif_ptr);
+		        ldif_ptr = NULL;
+	            }
+        	    return;
+    	    }
+
+	    b64_obj_length = base64_encode(be, conn, priv,
+				priv->attr_vals[object]->bv_val,
+				priv->attr_vals[object]->bv_len,
+				b64buff_ptr, b64buff_size);
+	    if (getcert_shared->debugging & DEBUG_GEN_LO)
+	        syslog(LOG_DEBUG,
+		    "[%lu][debug] Object number %d base64 length is %d bytes.\n",
+		    conn->c_connid, object + 1, b64_obj_length);
+	    /* Make sure this object will fit in our LDIF buffer. */
+	    /*
+	     * Object data at 76 chars per line + attribute name +
+	     * continuation char + <nl> + string termination char.
+	     */
+	    len2 = b64_obj_length + ((((b64_obj_length + 36) / 76) + 2) * 2);
+	    if ((len + len2 + 1) >= bufferlen) {
+	        /* Won't fit. */
+	        syslog(LOG_INFO,
+		    "[%lu][error] %.64s (%d bytes) %.64s %d\n", conn->c_connid,
+		    "Not enough buffer space allocated", bufferlen,
+		    "to hold object number", object + 1);
+	        if (priv->attr_vals != NULL) {
+	            if (getcert_shared->debugging & DEBUG_MEM)
+		        syslog(LOG_DEBUG,
+			    "[%lu][debug] %.128s\n", conn->c_connid,
+			    "Releasing memory allocated for attribute values.");
+		    ldap_value_free_len(priv->attr_vals);
+		    priv->attr_vals = NULL;
+	        }
+        	if (priv->object_lengths != NULL) {
+	    	    if (getcert_shared->debugging & DEBUG_MEM)
+		        syslog(LOG_DEBUG,
+		    	    "[%lu][debug] Releasing memory allocated for object_lengths.\n",
+		    	    conn->c_connid);
+		    free(priv->object_lengths);
+	    	    priv->object_lengths = NULL;
+		}
+	        if (b64buff_ptr != NULL) {
+	            if (getcert_shared->debugging & DEBUG_MEM)
+	       	        syslog(LOG_DEBUG,
+		    	    "[%lu] %.128s\n", conn->c_connid, 
+			    "Releasing memory allocated for base64 buffer.");
+		    free(b64buff_ptr);
+		    b64buff_ptr = NULL;
+	        }
+	        if (ldif_ptr != NULL) {
+	            if (getcert_shared->debugging & DEBUG_MEM)
+		        syslog(LOG_DEBUG,
+			    "[%lu][debug] %.128s\n", conn->c_connid, 
+			    "Releasing memory allocated for LDIF structure.");
+		    free(ldif_ptr);
+		    ldif_ptr = NULL;
+	        }
+	        return;
+	    }
+	    objptr = b64buff_ptr;
+	    objlength = b64_obj_length;
+	} else {
+	    /* Not binary data. */
+	    b64buff_ptr = NULL;
+	    objptr = priv->attr_vals[object]->bv_val;
+	    objlength = priv->attr_vals[object]->bv_len;
+	}
+	/* Add the object's attribute tag to the response. */
+	attrlen = strlen(ldap_attributes[0]);
+	strncpy(&ldif_ptr[len], ldap_attributes[0], attrlen);
+	len += attrlen;
+	/* If this is base64 data, make sure the ;binary tag is on */
+	/* theattribute name.  The OpenLDAP front-end requires it. */
+	if (b64buff_ptr != NULL) {
+	    scptr = strchr(ldap_attributes[0], ';');
+	    if (scptr == NULL) {
+	        strncpy(&ldif_ptr[len], ";binary:: ", 10);
+		attrlen += 10;
+	        len += 10;
+	    } else {
+	        strncpy(&ldif_ptr[len], ":: ", 3);
+		attrlen += 3;
+	        len += 3;
+	    }
+	} else {
+	    strncpy(&ldif_ptr[len], ": ", 2);
+	    attrlen += 2;
+	    len += 2;
+	}
+	ldiflines++;
+
+	if ((objlength + attrlen) < 77) {
+	    strncpy(&ldif_ptr[len], objptr, objlength);
+	    len += objlength;
+	    objptr += objlength;
+	} else {
+	    objremaining = objlength;
+	    /* First line of object output. */
+	    for (j = 0; j < (78 - attrlen); j++)
+	        ldif_ptr[len++] = objptr[j];
+	    ldif_ptr[len++] = '\n';
+	    ldiflines++;
+	    ldif_ptr[len++] = ' ';
+	    objptr += j;
+	    objremaining -= j;
+	    /* Intermediate lines of object data output. */
+	    while (objremaining > 77) {
+	        for (j = 0; j < 77; j++)
+	            ldif_ptr[len++] = objptr[j];
+	        ldif_ptr[len++] = '\n';
+	        ldiflines++;
+	        ldif_ptr[len++] = ' ';
+	        objptr += 77;
+	        objremaining -= 77;
+	    }
+	    /* Last line of output for this data. */
+	    for (j = 0; objremaining > 0; objremaining--)
+	        ldif_ptr[len++] = objptr[j++];
+	}
+	ldif_ptr[len++] = '\n';
+	ldiflines++;
+	/* This blank line (LDIF termination) will    */
+	/* be overwritten if there are more objects.  */
+	ldif_ptr[len] = '\n';
+	ldiflines++;
+	ldif_ptr[len + 1] = '\0';
+
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] Wrote %d bytes of object number %d to ldif buffer.\n",
+		conn->c_connid, objlength, object + 1);
+    } /* Next object */
+
+    /* Finished with the objects and base64 conversion buffer. */
+    if (priv->attr_vals != NULL) {
+        if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Releasing memory allocated for attribute values.\n",
+		conn->c_connid);
+	ldap_value_free_len(priv->attr_vals);
+	priv->attr_vals = NULL;
+    }
+    if (priv->object_lengths != NULL) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Releasing memory allocated for object_lengths.\n",
+		conn->c_connid);
+	free(priv->object_lengths);
+	priv->object_lengths = NULL;
+    }
+    if (b64buff_ptr != NULL) {
+        if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] %.128s\n", conn->c_connid,
+		"Releasing memory allocated for base64 buffer.");
+        free(b64buff_ptr);
+        b64buff_ptr = NULL;
+    }
+
+    /* Are we still within our buffer bounds? */
+    ldifsize = strlen(ldif_ptr);
+    if (ldifsize >= bufferlen) {
+	syslog(LOG_INFO,
+	    "[%lu][error] Not enough buffer space to convert object format.\n",
+	    conn->c_connid);
+        rs->sr_err = LDAP_OPERATIONS_ERROR;
+        rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+        send_ldap_result(op, rs);
+	if (ldif_ptr != NULL) {
+	    if (getcert_shared->debugging & DEBUG_MEM)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] %.128s\n", conn->c_connid, 
+		    "Releasing memory allocated for LDIF structure.");
+	    free(ldif_ptr);
+	    ldif_ptr = NULL;
+	}
+	return;
+    }
+
+    /*
+     * Return the search results to the client. 
+     */
+    rc = send_search_results(be, conn, op, attrs, attrsonly,
+				 ldif_ptr, priv->unique_ndn, rs);
+    if (ldif_ptr != NULL) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] %.128s\n", conn->c_connid, 
+		"Releasing memory allocated for LDIF structure.");
+	free(ldif_ptr);
+	ldif_ptr = NULL;
+    }
+    if (rc < 0) {
+	/* Couldn't return results. */
+        rs->sr_err = LDAP_OPERATIONS_ERROR;
+        rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+        send_ldap_result(op, rs);
+	return;
+    }
+    if (total_obj_count == 1) {
+	if (getcert_shared->debugging == DEBUG_NONE) {
+	    len2 = (MAX_LOG_REC - strlen(priv->log_buffer)) - 1;
+	    ptr = priv->log_buffer + strlen(priv->log_buffer);
+	    snprintf(ptr, len2, "Returned one object of type %s\n", ldap_attributes[0]);
+	} else {
+            syslog(LOG_INFO,
+	        "[%lu] Returned one object of type %.128s.\n",
+	        conn->c_connid, ldap_attributes[0]);
+	}
+    } else {
+	if (getcert_shared->debugging == DEBUG_NONE) {
+	    len2 = (MAX_LOG_REC - strlen(priv->log_buffer)) - 1;
+	    ptr = priv->log_buffer + strlen(priv->log_buffer);
+	    snprintf(ptr, len2, "Returned %d objects of type %.128s.\n",
+		total_obj_count, ldap_attributes[0]);
+	} else {
+	    syslog(LOG_INFO,
+	        "[%lu] Returned %d objects of type %.128s.\n",
+	        conn->c_connid, total_obj_count, ldap_attributes[0]);
+	}
+    }
+    rs->sr_err = LDAP_SUCCESS;
+    rs->sr_text = NULL;
+    send_ldap_result(op, rs);
+    return;
+} /* find_object */
+
+/*
+ * Find and return all attribute values in an LDAP entry.
+ * The specified BaseDN points to the entry we want, and
+ * we will try to match that DN against the DNs listed in
+ * the ldap_server_list file.
+ */
+void
+find_all(
+    Backend        *be,
+    Connection     *conn,
+    Operation      *op,
+    struct berval  *base,
+    struct berval  *nbase,
+    struct berval  *filterstr,
+    AttributeName  *attrs,
+    int		   attrsonly,
+    struct getcert_private  *priv,
+    SlapReply      *rs
+    )
+{
+    int i, j, k, m, attr_name_len, attr_val_len, base64_length, entry_count,
+	ldif_lines, ldif_buffer_size, len, offset, rc, obj_count, search_rc,
+	server_number, taglen, total_obj_count, obj_length, valnum;
+    char  basedn[MAX_DN_LENGTH];
+    char  *attr, *attr_val_ptr, *base64_buffer, *base64_ptr,
+	  *ldif_end_ptr, *ldif_buffer, *ptr;
+    static char  *all_ldap_attributes[] = { NULL, NULL };
+    LDAP  *ld;
+    LDAPMessage  *result, *entry;
+    BerElement  *ber;
+    struct getcert_data  *getcert_shared;
+    struct timeval  search_maxwait = {0, 0};
+    
+    getcert_shared = be->be_private;
+
+    /*
+     * The base DN from the search request is used
+     * as a search string into the LDAP server list.
+     */
+    if (base->bv_len == 0) {
+	if (getcert_shared->debugging == 0) {
+            len = (MAX_LOG_REC - strlen(priv->log_buffer)) - 1;
+	    strncat(priv->log_buffer, "No search baseDN specified.", len);
+        } else {
+            syslog(LOG_INFO,
+                "[%lu] No search base DN specified in the search request.\n",
+                conn->c_connid);
+	}
+        if (getcert_shared->limit_return_codes)
+        {
+            rs->sr_err = LDAP_OPERATIONS_ERROR;
+            rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+            send_ldap_result(op, rs);
+        }
+        else
+        {
+            rs->sr_err = LDAP_OPERATIONS_ERROR;
+            rs->sr_text = getcert_err_msg[GETCERT_NO_BASEDN];
+            send_ldap_result(op, rs);
+        }
+        return;
+    }
+    if (base->bv_len < MAX_DN_LENGTH) {
+	strncpy(basedn, base->bv_val, base->bv_len);
+	basedn[base->bv_len] = '\0';
+    } else {
+	strncpy(basedn, base->bv_val, MAX_DN_LENGTH - 1);
+	basedn[MAX_DN_LENGTH] = '\0';
+    }
+    if (getcert_shared->debugging) {
+        syslog(LOG_INFO,
+	    "[%lu] Search query is requesting all entries from BaseDN:\n",
+	    conn->c_connid);
+        syslog(LOG_INFO,
+	    "[%lu]     %.512s\n", conn->c_connid, basedn);
+    }
+
+    /* Initialize */
+    attr = NULL;
+    priv->attr_vals = NULL;
+    base64_buffer = NULL;
+    ldif_buffer_size = 0;
+    ld = NULL;
+    ldif_buffer = NULL;
+    result = NULL;
+    server_number = 0;
+    total_obj_count = 0;
+
+    /*
+     * Start searching the LDAP server list for servers that contain
+     * the specified baseDN.
+     */
+    while ((server_number >= 0) && (total_obj_count == 0) && 
+	   (ldif_buffer == NULL) && (base->bv_len > 0)) {
+        server_number = search_ldap_server_list(be, conn, base, attrs, server_number);
+        if (server_number < 0)
+            /* We've reached the end of the LDAP server list. */
+            break;
+
+        if (getcert_shared->debugging & DEBUG_GEN_HI)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] Next LDAP server to query is: %.256s\n",
+                conn->c_connid, ldap_server_list[server_number]->server_name);
+
+	/* 
+         * Get a handle to an LDAP connection.
+         */
+        if (getcert_shared->debugging & DEBUG_GEN_HI)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] Initializing LDAP structures\n", conn->c_connid);
+
+        if ((ld = ldap_init(ldap_server_list[server_number]->server_name,
+                            ldap_server_list[server_number]->port)) == NULL ) {
+            syslog(LOG_INFO,
+                "[%lu][error] Unable to initialize LDAP structures.\n",
+                conn->c_connid);
+            /* Move on to the next possible server in the LDAP server list. */
+            server_number++;
+            continue;
+        }
+
+        /*
+         * Bind to the LDAP server.  Do an anonymous bind
+         * if no bind DN is specified for this server.
+         *
+         * A bind is required in LDAP version 2 but optional in
+         * LDAP version 3.  We always bind so that we can determine
+         * if the LDAP server is available before we send it a query,
+         * which would have to wait through a timeout period before
+         * returning if the server is unavailable.  Unfortunately,
+         * OpenLDAP servers are configured by default to reject
+         * queries from LDAP version 2 clients, and our bind makes
+         * us look like an LDAP version 2 client.  So if our bind
+         * fails with an LDAP_PROTOCOL_ERROR, we just continue on
+         * with our query.  Adding "allow bind_v2" to the slapd.conf
+         * file on the OpenLDAP server disables the rejection of
+         * clients requesting binds.
+         */
+	if (getcert_shared->debugging)
+            syslog(LOG_INFO,
+                "[%lu] Establishing LDAP connection to %.900s port %d\n",
+                conn->c_connid, ldap_server_list[server_number]->server_name,
+                ldap_server_list[server_number]->port);
+        if (ldap_server_list[server_number]->bind_dn[0] != '\0') {
+            rc = ldap_simple_bind_s(ld, ldap_server_list[server_number]->bind_dn,
+                        ldap_server_list[server_number]->bind_password);
+        } else {
+            /*  Anonymous bind  */
+            rc = ldap_simple_bind_s(ld, NULL, NULL);
+        }
+        if (rc == LDAP_PROTOCOL_ERROR) {
+            if (getcert_shared->debugging & DEBUG_GEN_HI) {
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] %s\n", conn->c_connid,
+                    "LDAP server trying to reject us as an LDAP V2 client.");
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] %s\n", conn->c_connid,
+                    "We are an LDAP V3 client, so we will continue.");
+            }
+        } else
+        if (rc != LDAP_SUCCESS) {
+            syslog(LOG_INFO, "[%lu] Bind failed to %.450s: %.450s\n",
+                conn->c_connid, ldap_server_list[server_number]->server_name,
+                ldap_err2string(rc));
+            /* Move on to the next possible server in the server list. */
+            server_number++;
+            continue;
+        }
+
+	/*
+	 * Perform the search using the specified BaseDN and a generic search filter.
+	 */
+	search_maxwait.tv_sec = getcert_shared->search_timeout;
+
+        if (getcert_shared->debugging & DEBUG_GEN_LO) {
+            syslog(LOG_DEBUG,
+                "[%lu][debug] ldap_search parameters:\n", conn->c_connid);
+            syslog(LOG_DEBUG,
+                "[%lu][debug]     Base DN: %s\n",
+                conn->c_connid, ldap_server_list[server_number]->ldap_dn);
+            syslog(LOG_DEBUG,
+                "[%lu][debug]     Scope: LDAP_SCOPE_BASE\n", conn->c_connid);
+            syslog(LOG_DEBUG,
+                "[%lu][debug]     Filter: %s\n", conn->c_connid, generic_filter);
+            syslog(LOG_DEBUG,
+                "[%lu][debug]     Attributes: [NONE]\n", conn->c_connid);
+            syslog(LOG_DEBUG,
+                "[%lu][debug]     Max Wait: %d seconds\n",
+		conn->c_connid, search_maxwait.tv_sec);
+        }
+
+        if (getcert_shared->debugging & DEBUG_GEN_HI)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] Beginning ldap search...\n", conn->c_connid);
+
+        /*
+         * We are asking for all attribute values in this entry to be returned.
+         */
+        search_rc = ldap_search_st(ld,
+            ldap_server_list[server_number]->ldap_dn, LDAP_SCOPE_BASE,
+            generic_filter, all_ldap_attributes, 0, &search_maxwait, &result);
+
+        if (getcert_shared->debugging & DEBUG_MEM)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] Allocated memory for search results.\n", conn->c_connid);
+
+        if (search_rc != LDAP_SUCCESS) {
+            /*
+             * The LDAP search failed.
+             * Log the errors and release the
+             * dynamically allocated memory.
+             */
+            search_failed(be, conn, search_rc,
+		ldap_server_list[server_number]->server_name, result);
+	    if (ld != NULL) {
+                ldap_unbind(ld);
+                ld = NULL;
+	    }
+            server_number++;
+            continue;
+        }
+
+	if (getcert_shared->debugging & DEBUG_GEN_HI)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] Processing search results...\n", conn->c_connid);
+
+        /* Did we find the entry? */
+        entry_count = ldap_count_entries(ld, result);
+        if (getcert_shared->debugging & DEBUG_GEN_HI)
+            syslog(LOG_DEBUG,
+              "[%lu][debug] %d entries on this server match our LDAP search.\n",
+              conn->c_connid, entry_count);
+        if (entry_count != 1) {
+	    /* We are expecting only a single entry at this BaseDN. */
+            syslog(LOG_INFO,
+                "[%lu] Found %d LDAP entries at this BaseDN.  Expecting one.\n",
+                conn->c_connid, entry_count);
+            server_number++;
+    	    if (result != NULL) {
+                if (getcert_shared->debugging & DEBUG_MEM)
+            	    syslog(LOG_DEBUG,
+                	"[%lu][debug] %.128s\n", conn->c_connid,
+                	"Releasing memory allocated for search results.");
+        	ldap_msgfree(result);
+        	result = NULL;
+    	    }
+
+            /* Move on to the next LDAP server. */
+	    if (ld == NULL) {
+                ldap_unbind(ld);
+                ld = NULL;
+	    }
+            continue;
+        }
+
+	/*
+	 * Create an LDIF buffer to put the search results into.
+	 */
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+                "[%lu][debug] Allocating %d bytes of memory for LDIF structure.",
+                conn->c_connid, BUFF_BLOCK_SIZE);
+	ldif_buffer = malloc(BUFF_BLOCK_SIZE);
+	if (ldif_buffer == NULL) {
+            if (getcert_shared->limit_return_codes)
+            {
+                rs->sr_err = LDAP_OPERATIONS_ERROR;
+                rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+                send_ldap_result(op, rs);
+            }
+            else
+            {
+                rs->sr_err = LDAP_RESULTS_TOO_LARGE;
+                rs->sr_text = getcert_err_msg[GETCERT_ERR_TOO_LARGE];
+                send_ldap_result(op, rs);
+            }
+            if (result != NULL) { 
+                if (getcert_shared->debugging & DEBUG_MEM)
+                    syslog(LOG_DEBUG,
+                        "[%lu][debug] Releasing memory allocated for search results.\n",
+                        conn->c_connid);
+                ldap_msgfree(result);
+                result = NULL;
+            }
+            if (ld == NULL) {
+                ldap_unbind(ld);
+                ld = NULL;
+            }
+            return;
+        } else
+	    ldif_buffer_size = BUFF_BLOCK_SIZE;
+
+	/*
+	 * Start filling the LDIF structure.
+	 */
+	ldif_lines = 0;
+	ldif_end_ptr = ldif_buffer;
+	/* DN */
+	strncpy(ldif_buffer, "dn: ", 4);
+	ldif_end_ptr += 4;
+	strncpy(ldif_end_ptr, base->bv_val, base->bv_len);
+	ldif_end_ptr[base->bv_len] = '\n';
+	ldif_lines++;
+	ldif_end_ptr += base->bv_len + 1;
+	ldif_end_ptr[0] = '\0';
+
+	/*
+	 * Step through the entry saving each attribute value in LDIF format.
+	 */
+	attr = NULL;
+	entry = ldap_first_entry(ld, result);
+	for (attr = ldap_first_attribute(ld, entry, &ber);
+	     attr != NULL;
+	     attr = ldap_next_attribute(ld, entry, ber)) {
+	    if (getcert_shared->debugging & DEBUG_MEM) {
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] %.128s\n", conn->c_connid,
+                    "Allocated memory for attribute structure.");
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] %.128s\n", conn->c_connid,
+                    "Allocated memory for BerElement structure.");
+	    }
+            if (getcert_shared->debugging & DEBUG_GEN_HI)
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] Next attribute is %.256s\n", conn->c_connid, attr);
+
+	    /* Get the attribute value(s). The memory allocated */
+            /* by this call will need to be freed later.        */
+            priv->attr_vals = ldap_get_values_len(ld, entry, attr);
+            if (priv->attr_vals == NULL) {
+                syslog(LOG_INFO,
+                    "[%lu][error] Attribute %.256s contains no data.\n", conn->c_connid, attr);
+                if (getcert_shared->debugging & DEBUG_MEM)
+                    syslog(LOG_DEBUG,
+                        "[%lu][debug] %.128s\n", conn->c_connid,
+                        "Releasing memory allocated for attribute structure.");
+                ldap_memfree(attr);
+		attr = NULL;
+                /* Move on to next attribute. */
+                continue;
+            } else {
+                if (getcert_shared->debugging & DEBUG_MEM)
+                    syslog(LOG_DEBUG,
+			"[%lu][debug] Allocated memory for object list.\n", conn->c_connid);
+		if (getcert_shared->debugging & DEBUG_GEN_LO)
+                    syslog(LOG_DEBUG,
+                        "[%lu][debug] Attribute value(s) for %.256s have been retrieved.\n",
+		        conn->c_connid, attr);
+            }
+            obj_count = ldap_count_values_len(priv->attr_vals);
+	    if (getcert_shared->debugging & DEBUG_GEN_LO)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] There are %d attribute values for %.256s.\n",
+		    conn->c_connid, obj_count, attr);
+	    if (obj_count < 1) {
+                syslog(LOG_INFO,
+                    "[%lu][error] %s\n", conn->c_connid,
+                    "Attribute value list is empty.  That\'s strange!");
+		if (priv->attr_vals != NULL) {
+                    if (getcert_shared->debugging & DEBUG_MEM)
+                        syslog(LOG_DEBUG,
+                            "[%lu][debug] %.128s\n", conn->c_connid,
+                            "Releasing memory allocated for attribute values.");
+                    ldap_value_free_len(priv->attr_vals);
+                    priv->attr_vals = NULL;
+		}
+                /* Move on to next attribute. */
+                if (getcert_shared->debugging & DEBUG_MEM)
+                    syslog(LOG_DEBUG,
+                        "[%lu][debug] %.128s\n", conn->c_connid,
+			"Releasing memory allocated for attribute structure.");
+                ldap_memfree(attr);
+		attr = NULL;
+                continue;
+            }
+	    attr_name_len = strlen(attr);
+            for (valnum = 0; priv->attr_vals[valnum] != NULL; valnum++) {
+		/* 
+		 * If there is no data for this attribute,
+		 * just list the attribute name in the LDIF structure.
+		 */
+		if (priv->attr_vals[valnum]->bv_len == 0) {
+		    strncpy(ldif_end_ptr, attr, attr_name_len);
+		    ldif_end_ptr += attr_name_len;
+		    strncpy(ldif_end_ptr, ":\n", 2);
+		    ldif_end_ptr += 2;
+		    ldif_end_ptr[0] = '\0';
+		    ldif_lines++;
+		    continue;
+		}
+		if (getcert_shared->debugging & DEBUG_GEN_LO) {
+                    syslog(LOG_DEBUG,
+                        "[%lu][debug] Object number %d is %d bytes in length and begins with:\n",
+                        conn->c_connid, valnum + 1, (int)priv->attr_vals[valnum]->bv_len);
+		    if (priv->attr_vals[valnum]->bv_len < 7) 
+			m = priv->attr_vals[valnum]->bv_len;
+		    else
+			m = 6;
+		    for (j = 0; j < m; j++) {
+                        k = 0xFF & (int)(priv->attr_vals[valnum]->bv_val[j]);
+                        sprintf(&priv->content_buffer[j * 5], " 0x%2.2x", k);
+		    }
+                    syslog(LOG_DEBUG,
+                        "[%lu][debug]    %.256s\n", conn->c_connid, priv->content_buffer);
+		}
+		/*
+                 * Will this value fit in our LDIF buffer?
+                 */
+                j = attr_name_len + 10 + (int)(priv->attr_vals[valnum]->bv_len * 1.5);
+                obj_length = j + ((j / 76) * 2);
+		while ((ldif_end_ptr + obj_length) >= (ldif_buffer + ldif_buffer_size)) {
+		    /* Increase the size of the LDIF structure */
+		    /* to hold this attribute value.           */
+		    if (getcert_shared->debugging & DEBUG_MEM)
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] Adding %d bytes of memory to the LDIF buffer.\n",
+			    conn->c_connid, BUFF_BLOCK_SIZE);
+
+		    /* The LDIF buffer will probably be relocated during the resize. */
+		    offset = ldif_end_ptr - ldif_buffer;
+		    ptr = realloc(ldif_buffer, ldif_buffer_size + BUFF_BLOCK_SIZE);
+		    if (ptr == NULL) {
+                        syslog(LOG_INFO,
+                            "[%lu][error] Search results too large for LDIF structure.\n",
+                            conn->c_connid);
+			if (ldif_buffer != NULL) {
+			    free(ldif_buffer);
+			    ldif_buffer = NULL;
+			}
+			if (priv->attr_vals != NULL) {
+                            if (getcert_shared->debugging & DEBUG_MEM)
+                                syslog(LOG_DEBUG,
+                                    "[%lu][debug] %.128s\n", conn->c_connid,
+                                    "Releasing memory allocated for attribute values.");
+                            ldap_value_free_len(priv->attr_vals);
+                            priv->attr_vals = NULL;
+			}
+	    		if (getcert_shared->debugging & DEBUG_MEM)
+                	    syslog(LOG_DEBUG,
+                    	       "[%lu][debug] Releasing memory allocated for attribute structure.\n",
+		    	       conn->c_connid);
+            		ldap_memfree(attr);
+			attr = NULL;
+        		if (ber != NULL) {
+            		    if (getcert_shared->debugging & DEBUG_MEM)
+                		syslog(LOG_DEBUG,
+                    		    "[%lu][debug] %.256s\n", conn->c_connid,
+				    "Releasing memory allocated for BerElement structure");
+            		    ber_free(ber, 0);
+        		}
+            		if (result != NULL) {
+                	    if (getcert_shared->debugging & DEBUG_MEM)
+                    		syslog(LOG_DEBUG,
+                        	    "[%lu][debug] Releasing memory allocated for search results.\n",
+                        	    conn->c_connid);
+                	    ldap_msgfree(result);
+                	    result = NULL;
+            		}
+	    		if (ld == NULL) {
+                	    ldap_unbind(ld);
+                	    ld = NULL;
+	    		}
+        		if (getcert_shared->limit_return_codes)
+                        {
+                            rs->sr_err = LDAP_OPERATIONS_ERROR;
+                            rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+                            send_ldap_result(op, rs);
+                        }
+			else
+                        {
+                            rs->sr_err = LDAP_RESULTS_TOO_LARGE;
+                            rs->sr_text = getcert_err_msg[GETCERT_ERR_TOO_LARGE];
+                            send_ldap_result(op, rs);
+                        }
+        		return;
+                    } else {
+			ldif_buffer = ptr;
+			ldif_end_ptr = ldif_buffer + offset;
+			ldif_buffer_size += BUFF_BLOCK_SIZE;
+		    }
+		} /* resize LDIF buffer */
+                /*
+                 * Determine if this value is binary data.
+                 *
+                 * At this stage of development, we are only interested in differentiating
+                 * between ASN.1 encoded binary data, and non-ASN.1 encoded data.
+                 */
+                if (((priv->attr_vals[valnum]->bv_val[0] == 0x30) &&
+                    ((priv->attr_vals[valnum]->bv_val[1] & 0xF0) == 0x80)) ||
+		    (strncmp(priv->attr_vals[valnum]->bv_val, "-----BEGIN", 10) == 0)) {
+		    /*
+		     * This is DER or PEM format data.  Convert it to Base64.
+		     */
+                    len = (int)(obj_length * 1.5);
+                    if (getcert_shared->debugging & DEBUG_MEM)
+                        syslog(LOG_DEBUG,
+                            "[%lu][debug] Allocating %d bytes of memory for base64 buffer.\n",
+                            conn->c_connid, len);
+                    base64_buffer = malloc(len);
+                    if (base64_buffer == NULL) {
+                        syslog(LOG_INFO,
+                            "[%lu][error] Cannot allocate %d bytes of memory for base64 buffer.\n",
+                            conn->c_connid, len);
+			if (priv->attr_vals != NULL) {
+                            if (getcert_shared->debugging & DEBUG_MEM)
+                                syslog(LOG_DEBUG,
+                                    "[%lu][debug] %.128s\n", conn->c_connid,
+                                    "Releasing memory allocated for attribute values.");
+                            ldap_value_free_len(priv->attr_vals);
+                            priv->attr_vals = NULL;
+			}
+                        if (getcert_shared->debugging & DEBUG_MEM)
+                            syslog(LOG_DEBUG,
+                               "[%lu][debug] Releasing memory allocated for attribute structure.\n",
+                               conn->c_connid);
+                        ldap_memfree(attr);
+			attr = NULL;
+                        if (ber != NULL) {
+                            if (getcert_shared->debugging & DEBUG_MEM)
+                                syslog(LOG_DEBUG,
+                                    "[%lu][debug] %.256s\n", conn->c_connid,
+                                    "Releasing memory allocated for BerElement structure");
+                            ber_free(ber, 0);
+                        }
+                        if (result != NULL) {
+                            if (getcert_shared->debugging & DEBUG_MEM)
+                                syslog(LOG_DEBUG,
+                                    "[%lu][debug] Releasing memory allocated for search results.\n",
+                                    conn->c_connid);
+                            ldap_msgfree(result);
+                            result = NULL;
+                        }
+                        if (ld == NULL) {
+                            ldap_unbind(ld);
+                            ld = NULL;
+                        }
+                        if (getcert_shared->limit_return_codes)
+                        {
+                            rs->sr_err = LDAP_OPERATIONS_ERROR;
+                            rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+                            send_ldap_result(op, rs);
+                        }
+                        else
+                        {
+                            rs->sr_err = LDAP_RESULTS_TOO_LARGE;
+                            rs->sr_text = getcert_err_msg[GETCERT_ERR_TOO_LARGE];
+                            send_ldap_result(op, rs);
+                        }
+		        return;
+		    }
+		    base64_length = base64_encode(be, conn, priv, priv->attr_vals[valnum]->bv_val,
+			    priv->attr_vals[valnum]->bv_len, base64_buffer, len);
+		    if (getcert_shared->debugging & DEBUG_GEN_LO)
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] Base64 length is %d bytes.\n",
+			    conn->c_connid, base64_length);
+		    if (base64_length > 0) {
+		        /* Add the Base64 encoded value to the LDIF structure. */
+                        base64_ptr = base64_buffer;
+		        if (getcert_shared->debugging & DEBUG_DATA)
+			    syslog(LOG_DEBUG,
+			        "[%lu][debug] Starting entry for %.256s at LDIF buffer offset %d\n",
+			        conn->c_connid, attr, (int)(ldif_end_ptr - ldif_buffer)); 
+                        strncpy(ldif_end_ptr, attr, attr_name_len);
+                        ldif_end_ptr += attr_name_len;
+			/* Check whether the attribute name already includes the binary tag. */
+			if ((attr_name_len > 7) && (strstr(attr, ";binary") != NULL)) {
+			    taglen = 3;
+                            strncpy(ldif_end_ptr, ":: ", taglen);
+			} else {
+			    taglen = 10;
+			    strncpy(ldif_end_ptr, ";binary:: ", taglen);
+			}
+                        ldif_end_ptr += taglen;
+                        ldif_end_ptr[0] = '\0';
+			if (getcert_shared->debugging & DEBUG_GEN_LO)
+			    syslog(LOG_DEBUG,
+				"[%lu][debug] Writing %.256s to LDIF buffer.\n",
+				conn->c_connid, attr);
+                        if (base64_length <= (76 - (attr_name_len + taglen))) {
+                            strncpy(ldif_end_ptr, base64_ptr, base64_length);
+                            ldif_end_ptr[base64_length] = '\n';
+                            ldif_lines++;
+                            ldif_end_ptr += base64_length + 1;
+                            ldif_end_ptr[0] = '\0';
+                        } else {
+                            /* First line of Base64 data. */
+                            for (j = 0; j < (76 - (attr_name_len + taglen)); j++)
+                                ldif_end_ptr[j] = base64_ptr[j];
+			    ldif_end_ptr[j] = '\n';
+                            ldif_lines++;
+                            ldif_end_ptr += j + 1;
+                            base64_ptr += j;
+                            /* Intermediate lines of Base64 data. */
+                            while ((base64_length - (base64_ptr - base64_buffer)) > 75) {
+                                ldif_end_ptr[0] = ' ';
+                                ldif_end_ptr++;
+                                for (j = 0; j < 75; j++)
+                                    ldif_end_ptr[j] = base64_ptr[j];
+                                ldif_end_ptr[j] = '\n';
+                                ldif_lines++;
+                                ldif_end_ptr += j + 1;
+                                base64_ptr += j;
+                            }
+                            /* Last line of Base64 data. */
+                            ldif_end_ptr[0] = ' ';
+			    ldif_end_ptr++;
+                            for (j = 0;
+				(base64_length - ((base64_ptr + j) - base64_buffer)) > 0;
+				j++)
+                                ldif_end_ptr[j] = base64_ptr[j];
+                            ldif_end_ptr[j] = '\n';
+                            ldif_lines++;
+			    ldif_end_ptr += j + 1;
+			    /* Blank line (LDIF termination) gets overwritten if more objects. */
+			    ldif_end_ptr[0] = '\n';
+                            ldif_end_ptr[1] = '\0';
+                        }
+                        if (getcert_shared->debugging & DEBUG_GEN_LO)
+                            syslog(LOG_DEBUG,
+                                "[%lu][debug] Wrote %d Base64 bytes of %.256s to ldif buffer.\n",
+                                conn->c_connid, base64_length, attr);
+                        if (getcert_shared->debugging & DEBUG_MEM) {
+                            syslog(LOG_DEBUG,
+				"[%lu][debug] LDIF end now at offset %d with %d lines written.\n",
+				conn->c_connid, (int)(ldif_end_ptr - ldif_buffer), ldif_lines);
+			    if ((int)(ldif_end_ptr - ldif_buffer) > 6) {
+			        for (j = -6; j < -1; j++)
+				    priv->content_buffer[6+j] = ldif_end_ptr[j];
+				priv->content_buffer[5] = '\0';
+			        syslog(LOG_DEBUG,
+				    "[%lu][debug] last five data bytes written: %.32s\n",
+				    conn->c_connid, priv->content_buffer);
+			    }
+			}
+		    } else {
+			syslog(LOG_INFO,
+                            "[%lu][error] Could not convert %d bytes of %.256s to Base64.\n",
+                            conn->c_connid, priv->attr_vals[valnum]->bv_len, attr);
+		    }
+		    if (base64_buffer != NULL) {
+                        if (getcert_shared->debugging & DEBUG_MEM)
+                            syslog(LOG_DEBUG,
+                                "[%lu][debug] Releasing memory allocated for Base64 buffer.\n",
+                                conn->c_connid);
+                        free(base64_buffer);
+                        base64_buffer = NULL;
+                    }
+		} else {
+		    /* Not binary data. */
+                    attr_val_len = priv->attr_vals[valnum]->bv_len;
+                    attr_val_ptr = priv->attr_vals[valnum]->bv_val;
+
+		    if (getcert_shared->debugging & DEBUG_DATA)
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] Starting entry for %.256s at LDIF buffer offset %d\n",
+			    conn->c_connid, attr, (int)(ldif_end_ptr - ldif_buffer)); 
+                    strncpy(ldif_end_ptr, attr, attr_name_len);
+		    ldif_end_ptr += attr_name_len;
+		    strncpy(ldif_end_ptr, ": ", 2);
+                    ldif_end_ptr += 2;
+                    ldif_end_ptr[0] = '\0';
+                    if (attr_val_len <= (76 - (attr_name_len + 2))) {
+                        strncpy(ldif_end_ptr, priv->attr_vals[valnum]->bv_val, attr_val_len);
+                        ldif_end_ptr[attr_val_len] = '\n';
+                        ldif_lines++;
+                        ldif_end_ptr += attr_val_len + 1;
+                        ldif_end_ptr[0] = '\0';
+                    } else {
+                        /* First line of data. */
+                        for (j = 0; j < (76 - (attr_name_len + 2)); j++)
+                            ldif_end_ptr[j] = attr_val_ptr[j];
+                        ldif_end_ptr[j + 1] = '\n';
+                        ldif_lines++;
+                        ldif_end_ptr += j + 1;
+                        attr_val_ptr += j;
+                        /* Intermediate lines of data. */
+                        while ((attr_val_len - 
+				(attr_val_ptr - priv->attr_vals[valnum]->bv_val)) > 75) {
+                            ldif_end_ptr[0] = ' ';
+                            ldif_end_ptr++;
+                            for (j = 0; j < 75; j++)
+                                ldif_end_ptr[j] = attr_val_ptr[j];
+                            ldif_end_ptr[j] = '\n';
+                            ldif_lines++;
+                            ldif_end_ptr += j + 1;
+                            attr_val_ptr += j;
+                        }
+                        /* Last line of data. */
+                        ldif_end_ptr[0] = ' ';
+                        ldif_end_ptr++;
+                        for (j = 0;
+			     (attr_val_len - ((attr_val_ptr + j) - priv->attr_vals[valnum]->bv_val)) > 0;
+                             j++)
+                            ldif_end_ptr[j] = attr_val_ptr[j];
+                        ldif_end_ptr[j] = '\n';
+                        ldif_lines++;
+                        ldif_end_ptr += j + 1;
+			/* Blank line (LDIF termination) gets overwritten if more objects. */
+			ldif_end_ptr[0] = '\n';
+                        ldif_end_ptr[1] = '\0';
+                    }
+		    if (getcert_shared->debugging & DEBUG_GEN_LO)
+                        syslog(LOG_DEBUG,
+                            "[%lu][debug] Wrote %d bytes of %.256s to ldif buffer.\n",
+                            conn->c_connid, priv->attr_vals[valnum]->bv_len, attr);
+		}
+	    } /* Next attr value */
+
+	    total_obj_count += obj_count;
+	    if (priv->attr_vals != NULL) {
+                if (getcert_shared->debugging & DEBUG_MEM)
+                    syslog(LOG_DEBUG,
+                        "[%lu][debug] Releasing memory allocated for attribute values.\n",
+		        conn->c_connid);
+                ldap_value_free_len(priv->attr_vals);
+                priv->attr_vals = NULL;
+	    }
+	    if (getcert_shared->debugging & DEBUG_MEM)
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] Releasing memory allocated for attribute structure.\n",
+		    conn->c_connid);
+            ldap_memfree(attr);
+	} /* ldap_next_attribute */
+	if (attr == NULL) {
+	    if (getcert_shared->debugging & DEBUG_MEM)
+	        syslog(LOG_DEBUG,
+	           "[%lu][debug] %.900s\n", conn->c_connid, 
+		   "Memory allocated for BerElement structure was released.");
+            if (ber != NULL)
+		ber = NULL;
+	}
+
+	/* If we found any data, we are finished with our search. */
+	if (total_obj_count == 0)
+            server_number++;
+        if (ber != NULL) {
+            if (getcert_shared->debugging & DEBUG_MEM)
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] Releasing memory allocated for BerElement structure.\n",
+                    conn->c_connid);
+            ber_free(ber, 0);
+        }
+        if (result != NULL) {
+            if (getcert_shared->debugging & DEBUG_MEM)
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] Releasing memory allocated for search results.\n",
+                    conn->c_connid);
+            ldap_msgfree(result);
+            result = NULL;
+        }
+	if (ld != NULL) {
+            ldap_unbind(ld);
+            ld = NULL;
+	}
+    } /* Next LDAP server */
+
+    /*
+     * Double check that we have released
+     * all the resources we allocated.
+     */
+    if (base64_buffer != NULL) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[%lu][error] Memory for Base64 buffer not released.\n",
+		conn->c_connid);
+	free(base64_buffer);
+	base64_buffer = NULL;
+    }
+    if (priv->attr_vals != NULL) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[%lu][error] Memory for attribute values array not released.\n",
+		conn->c_connid);
+	ldap_value_free_len(priv->attr_vals);
+	priv->attr_vals = NULL;
+    }
+    if (attr != NULL) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+	    syslog(LOG_DEBUG,
+		"[%lu][error] Memory for attribute structure not released.\n",
+		conn->c_connid);
+        ldap_memfree(attr);
+	attr = NULL;
+    }
+    if (result != NULL) {
+        if (getcert_shared->debugging & DEBUG_MEM)
+            syslog(LOG_DEBUG,
+                "[%lu][error] Memory for search results not released.\n",
+                conn->c_connid);
+        ldap_msgfree(result);
+        result = NULL;
+    }
+    if (ld != NULL) {
+	if (getcert_shared->debugging & DEBUG_MEM)
+            syslog(LOG_DEBUG,
+                "[%lu][error] LDPA structures wee not released.\n", conn->c_connid);
+        ldap_unbind(ld);
+        ld = NULL;
+    }
+
+    /*
+     * Did we find any data with this baseDN?
+     */
+    if ((total_obj_count == 0) || (ldif_buffer == NULL)) {
+        /* No data to return. */
+	if (getcert_shared->debugging == DEBUG_NONE) {
+            len = (MAX_LOG_REC - strlen(priv->log_buffer)) - 1;
+	    strncat(priv->log_buffer, "No data found at specified BaseDN.", len);
+	} else {
+            syslog(LOG_INFO,
+                "[%lu] Did not find any data at this BaseDN in any LDAP server.\n",
+	        conn->c_connid);
+	}
+        if (getcert_shared->limit_return_codes)
+        {
+            rs->sr_err = LDAP_SUCCESS;
+            rs->sr_text = getcert_err_msg[GETCERT_SUCCESS];
+            send_ldap_result(op, rs);
+        }
+        else
+        {
+            rs->sr_err = LDAP_NO_SUCH_OBJECT;
+            rs->sr_text = getcert_err_msg[GETCERT_NO_CRL_FOUND];
+            send_ldap_result(op, rs);
+        }
+        return;
+    }
+
+    /*
+     * Data found on the last LDAP server searched.
+     */
+    if (getcert_shared->debugging & DEBUG_GEN_HI)
+	syslog(LOG_DEBUG, 
+            "[%lu] %d attribute values found at: %.900s\n", conn->c_connid,
+            total_obj_count, ldap_server_list[server_number]->server_name);
+
+    /* Return the search results to the client. */
+    if (getcert_shared->debugging & DEBUG_GEN_LO)
+	syslog(LOG_DEBUG,
+	    "[%lu] Completed LDIF structure is %d bytes (%d lines) long.\n",
+	    conn->c_connid, strlen(ldif_buffer), ldif_lines);
+    rc = send_search_results(be, conn, op, attrs, attrsonly, ldif_buffer, basedn, rs);
+    if (rc < 0)
+    {
+        /* Couldn't return results. */
+        rs->sr_err = LDAP_OPERATIONS_ERROR;
+        rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+        send_ldap_result(op, rs);
+    }
+    else
+    {
+        rs->sr_err = LDAP_SUCCESS;
+        rs->sr_text = NULL;
+        send_ldap_result(op, rs);
+    }
+
+    if (getcert_shared->debugging == DEBUG_NONE) {
+        len = (MAX_LOG_REC - strlen(priv->log_buffer)) - 1;
+        ptr = priv->log_buffer + strlen(priv->log_buffer);
+        snprintf(ptr, len, "Returned data found at %s.\n",
+	    ldap_server_list[server_number]->server_name);
+    } else {
+        syslog(LOG_INFO,
+            "[%lu] Returned data found at %.900s\n",
+	    conn->c_connid, ldap_server_list[server_number]->server_name);
+    }
+
+    if (ldif_buffer != NULL) {
+        if (getcert_shared->debugging & DEBUG_MEM)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] Releasing memory allocated for LDIF structure.\n",
+		conn->c_connid);
+        free(ldif_buffer);
+        ldif_buffer = NULL;
+    }
+    return;
+} /* find_all */
+
+/********************************************
+ ** The following decodecert_* subroutines **
+ ** are used by the decode_certificate()   **
+ ** and decode_crl() routines.             **
+ ********************************************/
+
+/*
+ *  Get the next octet from the current certificate or current CRL.
+ *  Each LDAP search command processes either certificates or CRLs,
+ *  but not both.  So we find out which one we have and read from it.
+ *  Return octet as an integer or -1 on error.
+ */
+int
+decodecert_get_octet(
+    Backend     *be,
+    Connection  *conn, 
+    struct getcert_private   *priv 
+    )
+{
+    int  octet;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    if ((priv->certificates != NULL) && (priv->certificates[priv->cert_number] != NULL)) {
+        if (priv->certificates[priv->cert_number]->cert_der_length > 0) {
+	    /* Read from the current certificate. */
+            if (priv->total_octets >= MAX_CERTIFICATE_SIZE) {
+	        syslog(LOG_INFO,
+	            "[%lu][error] Certificate is too big to be believable at %d bytes.\n",
+	            conn->c_connid, priv->total_octets);
+	        return(-1);
+            }
+            if (priv->total_octets > priv->certificates[priv->cert_number]->cert_der_length) {
+                syslog(LOG_INFO,
+                    "[%lu][error] Certificate is too long at %d bytes\n",
+                    conn->c_connid, priv->total_octets);
+                syslog(LOG_INFO,
+                    "[%lu][error]     Should be %d bytes long.\n",
+                    conn->c_connid, priv->certificates[priv->cert_number]->cert_der_length);
+                return(-1);
+            }
+
+            octet =
+		priv->certificates[priv->cert_number]->der_certificate[priv->total_octets++] & 0xFF;
+            return(octet);
+	}
+    } else
+    if (priv->current_crl.crl_number >= 0) {
+	/* Read from the current CRL. */
+	if ((priv->current_crl.crl_length > 0) &&
+	    (priv->total_octets > priv->current_crl.crl_length)) {
+	    syslog(LOG_INFO,
+		"[%lu][error] CRL is too long at %d bytes\n",
+		conn->c_connid, priv->total_octets);
+	    syslog(LOG_INFO,
+		"[%lu][error]     Should be %d bytes long.\n",
+		conn->c_connid, priv->current_crl.crl_length);
+	    return(-1);
+	}
+
+	octet = priv->attr_vals[priv->current_crl.crl_number]->bv_val[priv->total_octets++] & 0xFF;
+        return(octet);
+    } else {
+	syslog(LOG_INFO,
+	    "[%lu][error] No certificate or CRL to process.\n",
+	    conn->c_connid);
+	return(-1);
+    }
+} /* decodecert_get_octet */
+
+/*
+ *  Read in and decode the identifier octet(s).
+ *  Returns:
+ *	tag_number
+ *	tag_class
+ *	tag_pc
+ *  Return Code: 0 = got an id 
+ * 		-1 = error
+ */
+int
+decodecert_get_identifier(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private   *priv
+    ) 
+{
+    int idtag;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    idtag = decodecert_get_octet(be, conn, priv);
+    if (idtag < 0)
+	return(-1);
+    idtag &= 0xFF;
+    priv->tag_class = (idtag >> 6) & 0x03;
+    priv->tag_pc = (idtag >> 5) & 0x01;
+    priv->tag_number = idtag & 0x1F;
+    if (priv->tag_number >= 31) {
+        /* This is a multi-octet identifier. */
+	priv->tag_number = 0;
+	while ((idtag = decodecert_get_octet(be, conn, priv)) >= 0) {
+	    priv->tag_number += (idtag & 0x7F);
+	    if ((idtag & 0x80) == 0) break;
+	}
+	if (idtag < 0) {
+	    syslog(LOG_INFO,
+		"[%lu][error] Certificate read error at %d.\n",
+		conn->c_connid, priv->total_octets);
+	    return(-1);
+        }
+    }
+
+    if (getcert_shared->debugging & DEBUG_DATA) {
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Tag number = %5d", conn->c_connid, priv->tag_number);
+	switch (priv->tag_class) {
+	    case Universal:
+		syslog(LOG_DEBUG,
+		    "[%lu][debug]    class = universal       ", conn->c_connid);
+	        break;
+	    case Application:
+		syslog(LOG_DEBUG,
+		    "[%lu][debug]    class = application     ", conn->c_connid);
+	        break;
+	    case Context_specific:
+		syslog(LOG_DEBUG,
+		    "[%lu][debug]    class = context-specific", conn->c_connid);
+	        break;
+	    case Private:
+		syslog(LOG_DEBUG,
+		    "[%lu][debug]    class = private         ", conn->c_connid);
+	        break;
+	    default:
+		syslog(LOG_DEBUG,
+		    "[%lu][debug]    class = unknown{%d}     ",
+		    conn->c_connid, priv->tag_class);
+	        break;
+	    }
+	if (priv->tag_pc == Primitive)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug]    P/C = primitive\n", conn->c_connid);
+	else
+	    syslog(LOG_DEBUG, "[%lu][debug]    P/C = constructed\n",
+		conn->c_connid);
+    }
+    return(0);
+} /* decodecert_get_identifier */
+
+/*
+ *  Get the content length from one or more bytes defined
+ *  by either "definite" or "indefinite" length encoding.
+ *  Return:
+ *	number if definite
+ *	0      if indefinite
+ *     -1      on error
+ */
+unsigned
+decodecert_get_length(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private   *priv
+    )
+{
+    int  i, octet;
+    unsigned int  total_length, length_octet_num;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    if ((octet = decodecert_get_octet(be, conn, priv)) < 0) {
+	syslog(LOG_INFO,
+	    "[%lu][error] Certificate read error at %d.\n",
+	    conn->c_connid, priv->total_octets);
+	return(-1);
+    }
+
+    if (getcert_shared->debugging & DEBUG_DATA)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] First length octet is 0x%x\n", conn->c_connid, octet);
+
+    /* Determine length encoding. */
+    if ((priv->tag_pc == Constructed) &&
+	((octet & 0x80) != 1) &&
+	((octet & 0x7F) == 0)) {
+	/*
+	 * Sender using "indefinite" form of length encoding.
+	 */
+	total_length = 0;
+	if (getcert_shared->debugging & DEBUG_DATA)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Sender using indefinite length encoding.\n",
+		 conn->c_connid);
+    } else {
+	/*
+         * Sender must use "definite" form of length encoding.
+	 */
+/*
+ *      if (getcert_shared->debugging & DEBUG_DATA)
+ *          syslog(LOG_DEBUG,
+ *              "[%lu][debug] Sender using definite length encoding.\n",
+ *               conn->c_connid);
+ */
+        if ((octet & 0x80) == 0) {
+            /* Single byte length */
+            total_length = octet;
+        } else {
+            /* Multibyte length */
+	    if (getcert_shared->debugging & DEBUG_DATA)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] Sender using multibyte length.\n",
+		    conn->c_connid);
+            total_length = 0;
+            length_octet_num = octet & 0x7F;
+	    if (getcert_shared->debugging & DEBUG_DATA)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] Number of length bytes is %d\n",
+		    conn->c_connid, length_octet_num);
+	    if (length_octet_num > 4) {
+		syslog(LOG_INFO,
+		    "[%lu][error] %.128s %d bytes.\n", conn->c_connid,
+		    "Certificate content length too long at", priv->total_octets);
+		return(-1);
+	    } 
+
+	    /* length octets will fit in an int. */
+	    total_length = 0;	
+            for (i = 0; i < (int)length_octet_num; i++) {
+                octet = decodecert_get_octet(be, conn, priv);
+                if (octet < 0) {
+		    syslog(LOG_INFO,
+		        "[%lu][error] Certificate read error at %d.\n",
+			conn->c_connid, priv->total_octets);
+		    return(-1);
+		}
+		total_length = (total_length << 8) | octet;
+            }
+        }
+    }
+    if (getcert_shared->debugging & DEBUG_DATA)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] length is %d octets\n",
+	    conn->c_connid, total_length);
+    return(total_length);
+} /* decodecert_get_length */
+
+/*
+ *  Read in the content field.
+ *  If length is zero, input content is terminated by two zero bytes.
+ *  Otherwise, input content length is in "length". 
+ *  Return:
+ *	filled content_buffer and length of content copied to buffer.
+ *  Return code: 0 = successful
+ *              -1 = error
+ */
+int
+decodecert_get_content(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private   *priv,
+    unsigned  length
+    )
+{
+    char  previous_octet;
+    int   ch, i, offset;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    if (length > MAX_CONTENT) {
+	syslog(LOG_INFO,
+	    "[%lu][error] Content field too big at offset %d (0x%x).\n",
+	    conn->c_connid, priv->total_octets, priv->total_octets);
+	syslog(LOG_INFO,
+	    "[%lu][error]     content size = %d  buffer size = %d.\n",
+	    conn->c_connid, length, MAX_CONTENT);
+	return(-1);
+    }
+    if (length == 0)
+	return(0);
+    if (length == 0x80) {
+        /* Read the content until the end-of-content octets   */
+        /*     are found (two zero bytes).                    */
+        previous_octet = 1;
+	offset = 0;
+        while ((ch = decodecert_get_octet(be,conn,priv)) >= 0) {
+	    priv->content_buffer[offset++] = ch;
+	    if (ch == 0) {
+	        if (previous_octet == 0)
+		    /* That's the end of the content for this field. */
+		    break;
+	        else
+		    previous_octet = ch;
+	    }
+        }
+        if (ch < 0) {
+	    syslog(LOG_INFO,
+	        "[%lu][error] Error reading content field at %d (0x%x).\n",
+	        conn->c_connid, priv->total_octets, priv->total_octets);
+	    return(-1);
+        } else {
+	    if (getcert_shared->debugging & DEBUG_DATA) 
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] Indefinite content length = %d\n", 
+		    conn->c_connid, offset - 2);
+            return(offset - 2);
+	}
+    }
+    if (length > 0) {
+	/* Read in content of known length. */
+	for (i = 0; i < length; i++) {
+	    ch = decodecert_get_octet(be, conn, priv);
+	    if (ch < 0) {
+		syslog(LOG_INFO,
+		    "[%lu][error] %.128s %d.\n",
+		    conn->c_connid, "Premature end of content field at offset", 
+		    priv->total_octets);
+		return(-1);	
+	    } else
+	        priv->content_buffer[i] = ch;
+	}
+	if (getcert_shared->debugging & DEBUG_DATA)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Definite content length = %d\n",
+		conn->c_connid, i);
+	return(i);
+    } else {
+	/* Length is negative. */
+	syslog(LOG_INFO,
+	    "[%lu][error] ERROR: Length of content field is negative\n",
+	    conn->c_connid);
+	syslog(LOG_INFO,
+	    "[%lu][error]        at offset %d.\n",
+	    conn->c_connid, priv->total_octets);
+	return(-1);
+    }
+} /* decodecert_get_content */
+
+/*
+ * Read in an integer.
+ * Return integer as an int.
+ * We can't use an integer return code here,
+ *   so if error, set the integer_error flag to TRUE.
+*/
+int
+decodecert_get_integer(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private   *priv,
+    int  length
+    )
+{
+    int  i, integer_sum, octet;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    if (length >= MAX_CONTENT) {
+	syslog(LOG_INFO,
+	    "[%lu][error] ERROR: Encoded integer length too big:\n",
+	    conn->c_connid);
+        syslog(LOG_INFO,
+	    "[%lu][error] ERROR:     content size = %d  buffer size = %d\n",
+            length, MAX_CONTENT);
+	priv->integer_error = TRUE;
+        return(-1);
+    }
+
+    integer_sum = 0;
+    for (i = 0; i < length; i++) {
+	octet = decodecert_get_octet(be, conn, priv);
+	if (octet < 0) {
+	    syslog(LOG_INFO,
+		"[%lu][error] ERROR: Cannot read integer at offset %d\n",
+		conn->c_connid, priv->total_octets);
+	    priv->integer_error = TRUE;
+	    return(-1);
+	} else
+	    integer_sum += octet;
+    }
+
+    if (getcert_shared->debugging & DEBUG_DATA)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] integer is %d\n", conn->c_connid, integer_sum);
+
+    return(integer_sum);
+} /* decodecert_get_integer */
+
+/*
+ * Decode an Object Identifier (OID), but not the object itself. 
+ * Return the index into the oid arrays of the matched OID:
+ *   The static oid_name array holds the oid's name.
+ *   The static oid_type array holds the oid's encoded octet sequence.
+ *   The oid_string char string holds the oid's printable numeric sequence.
+ */
+int
+decodecert_get_oid(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private   *priv,
+    int  oidlength
+    )
+{
+    int    i, offset, rc, strlength; 
+    char   temp_buffer[MAX_STRING];
+    long   subid;
+    div_t  divresult;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    /* If the OID is longer than any we might want, */
+    /* mark it as unknown and skip over it.         */
+    if (oidlength > MAXOIDLEN) {
+	for (offset = 0; offset < oidlength; offset++)
+	    rc = decodecert_get_octet(be, conn, priv);
+        strncpy(priv->oid_string, "...", 4);
+    	if (getcert_shared->debugging & DEBUG_DATA)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] A long, unknown OID (%d bytes) found.\n",
+		conn->c_connid, oidlength);
+	return(0);
+    }
+
+    /* Read in the encoded OID. */
+    for (offset = 0; offset < oidlength; offset++)
+	priv->oid_encoded[offset] = decodecert_get_octet(be, conn, priv);
+    for (i = offset; i < MAXOIDLEN; i++)
+	priv->oid_encoded[i] = 0;
+
+    /*
+     * Decode the OID into decimal numbers.
+     */
+    /* The first octet encodes the first two subidentifiers. */
+    offset = 0;
+    if (priv->oid_encoded[offset] < 40) {
+	priv->oid_decimal[0] = 0;
+	priv->oid_decimal[1] = priv->oid_encoded[offset];
+    } else {
+	divresult = div(priv->oid_encoded[offset], 40);
+	priv->oid_decimal[0] = divresult.quot;
+	priv->oid_decimal[1] = divresult.rem;
+    }
+    priv->oidsubnumber = 2;
+    while (++offset < oidlength) {
+	subid = 0;
+	while ((priv->oid_encoded[offset] & 0x80) > 0) {
+	    subid <<= 7;
+	    subid |= (priv->oid_encoded[offset++] & 0x7F);
+	}
+	subid <<= 7;
+	subid |= (priv->oid_encoded[offset] & 0x7F);
+        priv->oid_decimal[priv->oidsubnumber++] = subid;
+    }
+
+    /*
+     * Build a printable character string of the OID numeric sequence.
+     */
+    strlength = 0;
+    priv->oid_string[0] = '\0';
+    for (i = 0; (i < priv->oidsubnumber) && (strlength < MAX_STRING); i++) {
+	rc = sprintf(temp_buffer, "%ld ", priv->oid_decimal[i]);
+	strlength += (rc + 1);
+	/* temp_buffer is MAX_STRING bytes in size. */
+	if ((strlength + 1) < MAX_STRING) {
+	    strncat(priv->oid_string, temp_buffer, rc + 1);
+	    /* Do another buffer termination, just to be clear. */
+	    priv->oid_string[strlength + 1] = '\0';
+	}
+    }
+
+    /*
+     * See if we can match this OID with those we know about.
+     */
+    for (i = 0; i < MAXOIDNUM; i++) {
+	for (offset = 0; offset < MAXOIDLEN; offset++) {
+	    if (priv->oid_encoded[offset] != oid_type[i][offset])
+		break;
+	}
+	if (offset >= MAXOIDLEN)
+	    /* Found a recognizable OID type. */
+	    return(i);
+    } 
+    /* Unrecognized OID type. */
+    return(0);
+} /* decodecert_get_oid */
+
+/*
+ * Decode a bitstring sequence.  Return a 32 bit value.
+ * This limits us to a maximum of 32 flags.  Any more than that are ignored.
+ * On entry we have already read in the bitstring tag and length.
+ * The length (bitlen) includes the one unused-bits octet.
+ */
+unsigned long
+decodecert_get_bitstring(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private   *priv,
+    int  bitlen
+    )
+{
+    struct getcert_data  *getcert_shared;
+    int  i, rc, string_octets, unused_bits;
+    unsigned long  bitmask, bitstring;
+
+    getcert_shared = be->be_private;
+
+    /* Make a bitmask from the unused bits value */
+    unused_bits = decodecert_get_octet(be, conn, priv);
+    bitmask = 0;
+    for (i = unused_bits; i > 0; i--) {
+        bitmask <<= 1;
+      bitmask++;
+    }
+    
+    if (bitlen > 5)
+      string_octets = 4;
+    else 
+      string_octets = bitlen - 1;
+    /*
+     * If the bitstring is more than four octets in length, we
+     * are only interested in the first four.  We ignore the rest.
+     */
+    bitstring = 0;
+    for (i = string_octets - 1; i >= 0; i--) {
+      bitstring <<= 8;
+      bitstring |= decodecert_get_octet(be, conn, priv);
+    }
+    bitstring <<= (8 * (4 - string_octets));
+
+    /* Mask out the unused bits in the last octet. */
+    if (string_octets < 5) {
+        bitmask <<= (8 * (4 - string_octets));
+        bitstring &= ~bitmask;
+    }
+
+    /* Skip over any remaining bitstring octets. */
+    for (i = (bitlen - 1) - 4; i > 0; i--)
+      rc = decodecert_get_octet(be, conn, priv);
+
+    return(bitstring);
+} /* decodecert_get_bitstring */
+
+/*
+ * Read in the certificate's serial number and
+ * save it in the current_certificate structure.
+ * On entry we have read the integer tag.
+ * Return: 0 = successful
+ *        -1 = error
+ */
+int
+decodecert_get_serial_number(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private   *priv
+    ) 
+{
+    int  i;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    priv->current_certificate.serialnumber_length =
+	 decodecert_get_length(be, conn, priv);
+    if (priv->current_certificate.serialnumber_length < 0) {
+	decodecert_error(be, conn, priv, "Invalid serial number length.");
+	return(-1);
+    }
+    if (priv->current_certificate.serialnumber_length > MAX_SERIALNUMBER) {
+	decodecert_error(be, conn, priv, "Serial Number is too long.\n");
+	return(-1);
+    }
+    for (i = 0; i < priv->current_certificate.serialnumber_length; i++)
+	priv->current_certificate.serialnumber[i] =
+	    decodecert_get_octet(be, conn, priv);
+
+    return(0);
+} /* decodecert_get_serial_number */
+
+/*
+ *  Compare the UTCTime string with the current
+ *  time stored in the getcert_private structure.
+ *  Return:
+ *	-1 if the UTCTime is earlier than the current time.
+ *	 0 if the UTCTime is equal to the current time.
+ *	 1 if the UTCTime is later than the current time.
+ */
+int
+decodecert_check_time(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private   *priv,
+    char        *utc_string
+    )
+{
+    int     day, month, year;
+    time_t  seconds, current_secs;
+    char    strbuff[14];
+    struct  getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    /* Convert UTCTime to decimal. */
+    strncpy(strbuff, utc_string, 13);
+    strbuff[12] = '\0';
+    seconds = strtol(&strbuff[10], NULL, 10);
+    strbuff[10] = '\0';
+    seconds += (60 * strtol(&strbuff[8], NULL, 10));
+    strbuff[8] = '\0';
+    seconds += (3600 * strtol(&strbuff[6], NULL, 10));
+    strbuff[6] = '\0';
+    day = strtol(&strbuff[4], NULL, 10);
+    strbuff[4] = '\0';
+    month = strtol(&strbuff[2], NULL, 10);
+    strbuff[2] = '\0';
+    year = strtol(&strbuff[0], NULL, 10);
+    if (year >= 50)
+	year += 1900;
+    else
+	year += 2000;
+
+    /* year */
+    if (year < (priv->current_time.tm_year + 1900))
+	return(-1);
+    if (year > (priv->current_time.tm_year + 1900))
+	return(1);
+
+    /* month */
+    if (month < (priv->current_time.tm_mon + 1))
+	return(-1);
+    if (month > (priv->current_time.tm_mon + 1))
+	return(1);
+
+  /* day */
+    if (day < priv->current_time.tm_mday)
+	return(-1);
+    if (day > priv->current_time.tm_mday)
+	return(1);
+
+    /* seconds */
+    current_secs = priv->current_time.tm_sec + 
+		   (60 * priv->current_time.tm_min) +
+		   (3600 * priv->current_time.tm_hour);
+    if (seconds < current_secs)
+	return(-1);
+    if (seconds > current_secs)
+	return(1);
+    else
+	return(0);
+} /* decodecert_check_time */
+
+/*
+ * Decode the set elements in this section
+ * into a DN in the content buffer.
+ * Return code: 0 = success
+ *             -1 = error
+ */
+int
+decodecert_get_dn(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private   *priv,
+    int  section_length
+    )
+{
+    int  content_offset, j, len, rc, subject_start, sublength;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+    subject_start = priv->total_octets;
+    content_offset = 0;
+
+    if (getcert_shared->debugging & DEBUG_DATA)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Decoding a DN at offset 0x%x of length %d.\n",
+	    conn->c_connid, priv->total_octets, section_length);
+
+    /* The DN in the Subject section can be zero length. */
+    if (section_length == 0) {
+   	priv->content_buffer[content_offset] = '\0'; 
+	return(0);
+    }
+
+    /* Decode each set element in the Subject section. */
+    do {
+	rc = decodecert_get_identifier(be, conn, priv);
+	if ((rc < 0) || (priv->tag_class != Universal) ||
+	    ((priv->tag_number != 16) && (priv->tag_number != 17))) {
+	    decodecert_error(be, conn, priv,
+		"Cannot find sequence tag in Subject section.");
+	    return(-1);
+	}
+
+	if (priv->tag_number == 16) {
+	    /* Another SEQUENCE within the SET encoding.         */
+	    /* Is this even legal?  Oh well... decode it anyway. */
+	    /* Output a slash character to separate this */
+	    /* value from the previous element value.    */
+	    if (content_offset > 0) {
+	        priv->content_buffer[content_offset++] = '/';
+	        priv->content_buffer[content_offset] = '\0';
+	    }
+	} else
+	if (priv->tag_number == 17) {
+	    /* A new SET element. */
+	    sublength = decodecert_get_length(be, conn, priv);
+	    if (sublength <= 0) 
+		/* Empty SET.  Continue with next SET, if any. */
+		continue;
+	    /* Next should be a sequence tag. */
+	    rc = decodecert_get_identifier(be, conn, priv);
+	    if ((rc < 0) ||
+	        (priv->tag_class != Universal) ||
+	        (priv->tag_number != 16)) {
+	        decodecert_error(be, conn, priv,
+	           "Cannot find sequence tag in Subject section.");
+	        return(-1);
+	    }
+	} 
+	
+	/* SEQUENCE under SET. */
+	sublength = decodecert_get_length(be, conn, priv);
+	if (sublength > 0) {
+	    /* Next should be an OID type. */
+	    rc = decodecert_get_identifier(be, conn, priv);
+	    if ((rc < 0) ||
+	        (priv->tag_class != Universal) ||
+	        (priv->tag_number != 6)) {
+	        decodecert_error(be, conn, priv,
+		    "Cannot find OID tag in Subject section.");
+		return(-1);
+	    }
+	    sublength = decodecert_get_length(be, conn, priv);
+	    rc = decodecert_get_oid(be, conn, priv, sublength);
+	    len = strlen(oid_name[rc]);
+	    if ((content_offset + len + 3) >= MAX_CONTENT) {
+	        decodecert_error(be, conn, priv, "Subject value is too long.");
+		return(-1);
+	    }
+
+	    /* Output a comma if this is not the first value. */
+	    if ((content_offset > 0) &&
+		(priv->content_buffer[content_offset - 1] != '/'))
+	        priv->content_buffer[content_offset++] = ',';
+	    strncpy(&priv->content_buffer[content_offset], oid_name[rc],len);
+	    content_offset += len;
+	    priv->content_buffer[content_offset++] = '=';
+
+	    /* Get the value type. */
+	    rc = decodecert_get_identifier(be, conn, priv);
+	    if ((rc < 0) || (priv->tag_class != Universal) ||
+		((priv->tag_number < 18) && (priv->tag_number != 12)) ||
+ 		(priv->tag_number > 30) ||
+		((priv->tag_number > 22) && (priv->tag_number < 25))) {
+		decodecert_error(be, conn, priv,
+		    "Subject value is not a known string type.");
+		return(-1);
+	    }
+	    sublength = decodecert_get_length(be, conn, priv);
+	    if ((content_offset + sublength) > (MAX_CONTENT - 1)) {
+		decodecert_error(be, conn, priv, "Subject value is too big.");
+		return(-1);
+	    }
+	    for (j = 0; j < sublength; j++)
+		priv->content_buffer[content_offset++] = 
+		    decodecert_get_octet(be, conn, priv);
+	} /* Empty sequence */
+    } while (priv->total_octets < (subject_start + section_length)); 
+    priv->content_buffer[content_offset++] = '\0';
+
+    if (getcert_shared->debugging & DEBUG_DATA)
+	syslog(LOG_DEBUG,
+	        "[%lu][debug] DN string is %d bytes long.\n",
+		conn->c_connid, strlen(priv->content_buffer));
+    return(0);
+} /* decodecert_get_dn */
+
+/*
+ * Process the extensions section of this certificate.
+ * On entry we've read in the section tag and length.
+ */
+int 
+decodecert_read_extensions(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private   *priv
+    )
+{
+    int   i, ext_length, last_octet, length,
+	  next_sequence, oid_index, rc;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 16)) {
+	decodecert_error(be, conn, priv,
+	    "Cannot find tag for Explicit Extensions.");
+	return(-1);
+    }
+    ext_length = decodecert_get_length(be, conn, priv);
+    last_octet = priv->total_octets + ext_length;
+    if (getcert_shared->debugging & DEBUG_DATA) {
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Explicit Extensions section is %d bytes long.\n",
+	    conn->c_connid, ext_length);
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Next certificate section starts at %d\n",
+	    conn->c_connid, last_octet);
+    }
+
+    /*
+     * Loop through each extension object.
+     */
+    while (priv->total_octets < last_octet) {
+        rc = decodecert_get_identifier(be, conn, priv);
+	if ((rc != 0) ||
+	    (priv->tag_class != Universal) ||
+	    (priv->tag_number != 16)) {
+	    decodecert_error(be, conn, priv,
+		"Cannot find tag for extension OID.");
+	    return(-1);
+        }
+        length = decodecert_get_length(be, conn, priv);
+	if (getcert_shared->debugging & DEBUG_DATA)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] OID sequence is %d bytes in length.\n",
+		conn->c_connid, length);
+	next_sequence = priv->total_octets + length;
+
+        /* OID type */
+        rc = decodecert_get_identifier(be, conn, priv);
+        if ((rc < 0) ||
+	    (priv->tag_class != Universal) ||
+	    (priv->tag_number != 6)) {
+	    decodecert_error(be, conn, priv, "Cannot find OID tag.");
+	    return(-1);
+        }
+        length = decodecert_get_length(be, conn, priv);
+        oid_index = decodecert_get_oid(be, conn, priv, length);
+	if (getcert_shared->debugging & DEBUG_DATA)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] OID is %.128s  { %.900s }\n",
+		conn->c_connid, oid_name[oid_index], priv->oid_string);
+
+	/*
+	 * The rest of the data in this object depends on the OID.
+	 * We'll need to access the object's data based on the 
+	 * published specifications of the OID.
+	 */
+
+	/* See if this OID includes a Critical/NonCritical flag. */
+	rc = decodecert_get_identifier(be, conn, priv);
+	if ((rc >= 0) &&
+	    (priv->tag_class == Universal) &&
+	    (priv->tag_number == 1)) {
+	    length = decodecert_get_length(be, conn, priv);
+	    rc = decodecert_get_octet(be, conn, priv);
+	    if (rc == 0)
+		priv->criticality = FALSE;
+	    else
+		priv->criticality = TRUE;
+	    rc = decodecert_get_identifier(be, conn, priv);
+	} else {
+	    priv->criticality = FALSE;
+	    if (getcert_shared->debugging & DEBUG_DATA) 
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] No criticality flag for this object at %d\n",
+		    conn->c_connid, priv->total_octets);
+	}
+
+	/*
+	 * We should be positioned at the octet string that contains 
+	 * this object's data. 
+	 */
+	if ((rc < 0) ||
+	    (priv->tag_class != Universal) ||
+	    (priv->tag_number != 4)) {
+	    decodecert_error(be, conn, priv,
+		"Cannot find OID value octet string.");
+	    return(-1);
+	}
+	/*
+	 * The data in this object is in the form of an octet string.
+	 * Are we interested in decoding the data in this particular OID?
+	 */
+	if (priv->total_octets < next_sequence) {
+	    switch (oid_index) {
+	        case 0: /* Unknown (to us) OID. */
+	            break;
+	        case 21: /* keyUsage - { 2 5 29 14 } */
+	            rc = decodecert_read_keyUsage(be, conn, priv, next_sequence);
+		    if (rc < 0)
+		        return(-1);
+	            break;
+	        case 23: /* subjectAltName - { 2 5 29 17 } */
+		    rc = decodecert_read_subjectAltName(be, conn, priv, next_sequence);
+		    if (rc < 0)
+			return(-1);
+		    break;
+	        case 40: /* netscape-cert-type - { 2 16 840 1 113730 1 1 } */
+		    rc = decodecert_read_ns_certtype(be, conn, priv);
+		    if (rc < 0)
+		        return(-1);
+		    break;
+	        default: /* Uninteresting (to us) OID. */
+	            break;
+	    }
+	}
+
+	/*
+	 * We've either processed the rest of the data from this 
+	 * object or we are not interested in it, so skip over it.
+	 */
+	if (priv->total_octets < next_sequence) {
+	    if (getcert_shared->debugging & DEBUG_DATA)
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] Skipping over remainder of object.\n",
+                    conn->c_connid);
+	    for (i = 0; priv->total_octets < next_sequence; i++)
+	        rc = decodecert_get_octet(be, conn, priv);
+	}
+    } /* next OID */
+
+    if (getcert_shared->debugging & DEBUG_DATA)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] End of extensions section at %d\n",
+	    conn->c_connid, priv->total_octets);
+    return(0);
+} /* decodecert_read_extensions */
+
+/*
+ *  Read the data from the keyUsage extension object.
+ *  On entry we have already read in the octet string tag.
+ * Return code: 0 = successful
+ * 	       -1 = error
+ */
+int
+decodecert_read_keyUsage(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private   *priv,
+    int  end_of_object
+    )
+{
+    int  length, rc;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+    priv->current_certificate.key_usage_criticality = priv->criticality;
+
+    if (getcert_shared->debugging & DEBUG_DATA)
+        syslog(LOG_DEBUG,
+	    "[%lu][debug] Reading keyUsage extension object.\n",
+	    conn->c_connid);
+
+    /* Expecting an octet string */
+    length = decodecert_get_length(be, conn, priv);
+
+    /*
+     * Bitstring sequences with constructed flags set are actually
+     * sequences of bitstrings.  We are only interested in the last
+     * nine flags defined for keyUsage which should be in the last
+     * bitstring sequence.  Non-constructed bitstring sequences are
+     * just a single bitstring.
+     */
+    do {
+        /* bitstring */
+        rc = decodecert_get_identifier(be, conn, priv);
+	if ((rc < 0) ||
+	    (priv->tag_class != Universal) ||
+	    (priv->tag_number != 3)) {
+	    decodecert_error(be, conn, priv,
+		"Cannot find bitstring tag in keyUsage object.");
+            return(-1);
+	}
+	length = decodecert_get_length(be, conn, priv);
+	priv->bitstring = decodecert_get_bitstring(be, conn, priv, length);
+    } while ((priv->tag_class == Universal) &&
+	     (priv->tag_number == 3) &&
+	     (priv->total_octets < end_of_object));
+
+    /* List the keyUsage flags */
+    if ((priv->bitstring & 0x80000000) != 0)
+	priv->current_certificate.key_usage_digitalSignature = TRUE;
+    if ((priv->bitstring & 0x40000000) != 0)
+	priv->current_certificate.key_usage_nonRepudiation = TRUE;
+    if ((priv->bitstring & 0x20000000) != 0)
+	priv->current_certificate.key_usage_keyEncipherment = TRUE;
+    if ((priv->bitstring & 0x10000000) != 0)
+	priv->current_certificate.key_usage_dataEncipherment = TRUE;
+    if ((priv->bitstring & 0x08000000) != 0)
+	priv->current_certificate.key_usage_keyAgreement = TRUE;
+    if ((priv->bitstring & 0x04000000) != 0)
+	priv->current_certificate.key_usage_keyCertSign = TRUE;
+    if ((priv->bitstring & 0x02000000) != 0)
+	priv->current_certificate.key_usage_cRLSign = TRUE;
+    if ((priv->bitstring & 0x01000000) != 0)
+	priv->current_certificate.key_usage_encipherOnly = TRUE;
+    if ((priv->bitstring & 0x00800000) != 0)
+	priv->current_certificate.key_usage_decipherOnly = TRUE;
+
+    if (getcert_shared->debugging & DEBUG_DATA) {
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Certificate keyUsage flags (0x%8.8X):\n",
+	    conn->c_connid, priv->bitstring);
+	if (priv->current_certificate.key_usage_digitalSignature == TRUE)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug]     digitalSignature\n", conn->c_connid);
+	if (priv->current_certificate.key_usage_nonRepudiation == TRUE)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug]     nonRepudiation\n", conn->c_connid);
+	if (priv->current_certificate.key_usage_keyEncipherment == TRUE)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug]     keyEncipherment\n", conn->c_connid);
+	if (priv->current_certificate.key_usage_dataEncipherment == TRUE)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug]     dataEncipherment\n", conn->c_connid);
+	if (priv->current_certificate.key_usage_keyAgreement == TRUE)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug]     keyAgreement\n", conn->c_connid);
+	if (priv->current_certificate.key_usage_keyCertSign == TRUE)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug]     keyCertSign\n", conn->c_connid);
+	if (priv->current_certificate.key_usage_cRLSign == TRUE)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug]     cRLSign\n", conn->c_connid);
+	if (priv->current_certificate.key_usage_encipherOnly == TRUE)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug]     encipherOnly\n", conn->c_connid);
+	if (priv->current_certificate.key_usage_decipherOnly == TRUE)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug]     decipherOnly\n", conn->c_connid);
+    }
+
+    return(0);
+} /* decodecert_read_keyUsage */
+
+/*
+ *  Read the data from the subjectAltName extension object.
+ *  We are looking for any rfc822Name values.
+ *  On entry we have already read in this extension's octet string tag.
+ *  Return code: 0 = successful
+ * 	        -1 = error
+ */
+int
+decodecert_read_subjectAltName(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private   *priv,
+    int  end_of_object
+    )
+{
+    int  len, length, octet;
+    struct rfc822name_link  *link_ptr;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+    priv->current_certificate.subjectAltName_criticality = priv->criticality;
+    /* Octet string */
+    length = decodecert_get_length(be, conn, priv);
+    if (getcert_shared->debugging & DEBUG_DATA)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] Length of subjectAltName octet string is %d\n",
+            conn->c_connid, length);
+
+    /* Rather than try ASN.1 decoding of this extension, */
+    /* we'll just search for the rfc822Name tags.        */
+    while (priv->total_octets < end_of_object) {
+	octet = decodecert_get_octet(be, conn, priv);	
+	if (octet == 0x81) {
+	    /* rfc822Name tag */
+	    if (getcert_shared->debugging & DEBUG_DATA)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] Processing rfc822Name object.\n",
+		    conn->c_connid);
+	    length = decodecert_get_length(be, conn, priv);
+	    if ((length < MAX_EMAIL_LENGTH) &&
+		((priv->total_octets + length) <= end_of_object))  {
+		/* Put the email address in the content buffer. */
+		len = decodecert_get_content(be, conn, priv, length);
+		if (len != length) {
+		    if (getcert_shared->debugging & DEBUG_DATA)
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] Cannot read rfc822Name at 0x%x\n",
+			    conn->c_connid, priv->total_octets);
+		    return(-1);
+		}
+		priv->content_buffer[len] = '\0';
+                if (getcert_shared->debugging & DEBUG_DATA)
+                    syslog(LOG_DEBUG,
+                        "[%lu][debug] Found an rfc822Name: %.900s\n",
+                        conn->c_connid, priv->content_buffer);
+
+		/*
+		 * Store the email address in the rfc822Name chain.
+		 * There can be multiple rfc822Name entries in this
+		 * AltName extension, but typically only one.
+		 * So the first link in the chain is preallocated.
+		 * Additional links are dynamically allocated as needed.
+		 */
+		link_ptr = &priv->current_certificate.rfc822Name_chain;
+		if (link_ptr->email_name[0] == '\0') {
+		    link_ptr->email_name =
+			strncpy(link_ptr->email_name, priv->content_buffer, len + 1);
+			link_ptr->next_rfc822Name = NULL;
+		} else {
+		    /* Add a link to the rfc822Name chain. */
+		    while (link_ptr->next_rfc822Name != NULL) 
+			link_ptr = link_ptr->next_rfc822Name;
+		    if (getcert_shared->debugging & DEBUG_MEM)
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] Allocating %d %.64s %d %.64s\n",
+			    conn->c_connid, "bytes of memory for",
+			    sizeof(struct rfc822name_link), "rfc822Name link.");
+		    link_ptr->next_rfc822Name = malloc(sizeof(struct rfc822name_link));
+		    if (link_ptr->next_rfc822Name == NULL) {
+			syslog(LOG_INFO,
+			    "[%lu][error] Cannot allocate memory for rfc822Name.\n",
+			    conn->c_connid);
+		        return(-1);
+		    }
+		    if (getcert_shared->debugging & DEBUG_MEM) 
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] Allocating %d bytes of memory for rfc822Name string.\n",
+			    conn->c_connid, strlen(priv->content_buffer) + 1);
+		    link_ptr->next_rfc822Name->email_name =
+			strdup(priv->content_buffer);
+		    link_ptr->next_rfc822Name->next_rfc822Name = NULL;
+		}
+	    }
+	}
+    } /* Next octet */
+
+    if (getcert_shared->debugging & DEBUG_DATA) {
+        if (priv->current_certificate.rfc822Name_chain.email_name == NULL) {
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] No rfc822Name values found in this certificate.\n",
+		conn->c_connid);
+	} else {
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] rfc822Name values found in this certificate:\n",
+		conn->c_connid);
+	    link_ptr = &priv->current_certificate.rfc822Name_chain;
+	    do {
+	        syslog(LOG_DEBUG,
+		    "[%lu][debug]       %.900s\n",
+		    conn->c_connid, link_ptr->email_name);
+		link_ptr = link_ptr->next_rfc822Name;
+	    } while (link_ptr != NULL);
+	}
+    }
+    return(0);
+} /* decodecert_read_subjectAltName */
+
+/*
+ *  Read the data from the netscape-cert-type extension object.
+ *  On entry we have already read in the octet string tag.
+ *  Return code: 0 = successful
+ *	        -1 = error
+ */
+int
+decodecert_read_ns_certtype(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private  *priv
+    )
+{
+    int  length, rc;
+    unsigned long  nsflags;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    /* Octet string */
+    length = decodecert_get_length(be, conn, priv);
+
+    /* bitstring */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 3)) {
+	decodecert_error(be, conn, priv,
+	    "Cannot find bitstring in netscape_cert_type object.");
+        return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    nsflags = decodecert_get_bitstring(be, conn, priv, length);
+    if (getcert_shared->debugging & DEBUG_DATA)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Netscape Certificate Type bitstring is: 0x%8.8X\n",	
+	    conn->c_connid, nsflags);
+    if ((nsflags & 0x80000000) != 0)
+	priv->current_certificate.ns_cert_type_sslclient = TRUE;
+    if ((nsflags & 0x40000000) != 0)
+	priv->current_certificate.ns_cert_type_sslserver = TRUE;
+    if ((nsflags & 0x20000000) != 0)
+	priv->current_certificate.ns_cert_type_smime = TRUE;
+    if ((nsflags & 0x10000000) != 0)
+	priv->current_certificate.ns_cert_type_objsigning = TRUE;
+    if ((nsflags & 0x04000000) != 0)
+	priv->current_certificate.ns_cert_type_sslca = TRUE;
+    if ((nsflags & 0x02000000) != 0)
+	priv->current_certificate.ns_cert_type_smimeca = TRUE;
+    if ((nsflags & 0x01000000) != 0)
+	priv->current_certificate.ns_cert_type_objsigningca = TRUE;
+    return(0);
+} /* decodecert_read_ns_certtype */
+
+/*
+ *  Produce error messages if certificate or CRL decoding fails.
+ */
+void
+decodecert_error(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private  *priv,
+    char *debug_msg
+    )
+{
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    syslog(LOG_INFO,
+	"[%lu][error] Error in reading certificate or CRL at byte %d\n",
+	conn->c_connid, priv->total_octets);
+    if ((getcert_shared->debugging & DEBUG_DATA) ||
+	(getcert_shared->debugging & DEBUG_GEN_HI) && (debug_msg != NULL)) {
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] %.1000s\n", conn->c_connid, debug_msg);
+    }
+    return;
+} /* decodecert_error */
+
+/*
+ * Decode an X.509 certificate.
+ * Return values of interest in the global current_certificate structure.
+ * Return code = 0 successful 
+ *             = Negative if unable to read the entire certificate.
+ */
+int
+decode_certificate(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private  *priv
+    )
+{
+    int   content_length, len, length, loc, rc;
+    char  *chrptr;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    /* Initialize for this new certificate. */
+    priv->total_octets = 0;
+    priv->integer_error = FALSE;
+    priv->current_certificate.certlength = 0;
+    priv->current_certificate.certversion = -1;
+    priv->current_certificate.serialnumber_length = 0;
+    priv->current_certificate.serialnumber[0] = '\0';
+    priv->current_certificate.subject_algorithm_id = NULL;
+    priv->current_certificate.issuer[0] = '\0';
+    priv->current_certificate.validity_notbefore[0] = '\0';
+    priv->current_certificate.validity_notafter[0] = '\0';
+    priv->current_certificate.subject[0] = '\0';
+    priv->current_certificate.emailAddress[0] = '\0';
+    priv->current_certificate.subject_pkidata = NULL;
+    priv->current_certificate.signature_algorithm_id = NULL;
+    priv->current_certificate.key_usage_criticality = FALSE;
+    priv->current_certificate.key_usage_digitalSignature = FALSE;
+    priv->current_certificate.key_usage_nonRepudiation = FALSE;
+    priv->current_certificate.key_usage_keyEncipherment = FALSE;
+    priv->current_certificate.key_usage_dataEncipherment = FALSE;
+    priv->current_certificate.key_usage_keyAgreement = FALSE;
+    priv->current_certificate.key_usage_keyCertSign = FALSE;
+    priv->current_certificate.key_usage_cRLSign = FALSE;
+    priv->current_certificate.key_usage_encipherOnly = FALSE;
+    priv->current_certificate.key_usage_decipherOnly = FALSE;
+    priv->current_certificate.subjectAltName_criticality = FALSE;
+    /*
+     * The first rfc822name in the rfc822Name_chain is preallocated.
+     * Every other rfc822name is dynamically allocated as (seldom) needed.
+     */
+    priv->current_certificate.rfc822Name_chain.email_name = 
+	priv->current_certificate.first_rfc822Name;
+    priv->current_certificate.rfc822Name_chain.email_name[0] = '\0';
+    priv->current_certificate.rfc822Name_chain.next_rfc822Name = NULL;
+    priv->current_certificate.ns_cert_type_sslclient = FALSE;
+    priv->current_certificate.ns_cert_type_sslserver = FALSE;
+    priv->current_certificate.ns_cert_type_smime = FALSE;
+    priv->current_certificate.ns_cert_type_objsigning = FALSE;
+    priv->current_certificate.ns_cert_type_sslca = FALSE;
+    priv->current_certificate.ns_cert_type_smimeca = FALSE;
+    priv->current_certificate.ns_cert_type_objsigningca = FALSE;
+
+    /*
+     * The first sequence tag tells us how long the certificate is.
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if (rc < 0) {
+	decodecert_error(be, conn, priv,
+	    "Cannot read the beginning of this certificate.");
+	return(-1);
+    }
+
+    if ((priv->tag_class != Universal) || (priv->tag_number != 16)) {
+	decodecert_error(be, conn, priv,
+	    "Cert does not appear to be in X.509 DER format.");
+        return(-1);
+    }
+
+    priv->current_certificate.certlength = decodecert_get_length(be,conn,priv);
+    if (priv->current_certificate.certlength >= 0) { 
+        if (getcert_shared->debugging & DEBUG_GEN_LO)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] Certificate DER length is %d bytes\n",
+	        conn->c_connid, priv->current_certificate.certlength);
+    } else
+	return(-1);
+ 
+    /*
+     * The second sequence tag leads us to the TBSCertificate length.
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 16)) {
+	decodecert_error(be, conn, priv, "Cannot find TBSCertificate tag.");
+	return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    if ((length < 0) || (length >= priv->current_certificate.certlength) ||
+	(priv->tag_number != 16)) {
+	decodecert_error(be, conn, priv,
+	    "Invalid TBSCertificate length.");
+        return(-1);
+    }
+
+    /*
+     * TBSCertificate section
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+	(priv->tag_class != Context_specific) ||
+	(priv->tag_number != 0)) {
+        /* No [0] found.  This is a version 1 certificate. */
+	if (getcert_shared->debugging & DEBUG_DATA)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] No [0] section found.  %.126s\n",
+		conn->c_connid, "Must be a version 1 certificate.");
+	priv->current_certificate.certversion = 0;
+        /* Get the certificate serial number. */
+        if ((priv->tag_class == Universal) && (priv->tag_number == 2)) {
+            rc = decodecert_get_serial_number(be, conn, priv);
+	    if (rc < 0) 
+		return(-1);
+	}
+    } else {
+	/* ASN.1 [0] */
+        length = decodecert_get_length(be, conn, priv);
+        /* Version number */
+        rc = decodecert_get_identifier(be, conn, priv);
+        if ((rc < 0) ||
+	    (priv->tag_class != Universal) ||
+	    (priv->tag_number != 2)) {
+	    decodecert_error(be, conn, priv,
+	        "Cannot find certificate version number tag.");
+            return(-1);
+        }
+        length = decodecert_get_length(be, conn, priv);
+        if (length == 1) {
+	    rc = decodecert_get_integer(be, conn, priv, length);
+	    if (priv->integer_error)
+		return(-1);
+	    else {
+                priv->current_certificate.certversion = rc;
+		if (getcert_shared->debugging & DEBUG_DATA)
+		    syslog(LOG_DEBUG,
+                	"[%lu][debug] Certificate version is %d\n",
+                	conn->c_connid, rc + 1);
+	    }
+        } else {
+	    decodecert_error(be, conn, priv,
+		"Cannot find certificate version number length.");
+            return(-1);
+        }
+
+        /* Serial number */
+        rc = decodecert_get_identifier(be, conn, priv);
+        if ((rc >= 0) &&
+	    (priv->tag_class == Universal) &&
+	    (priv->tag_number == 2)) {
+            rc = decodecert_get_serial_number(be, conn, priv);
+	    if (rc < 0)
+		return(-1);
+        } else {
+	    decodecert_error(be, conn, priv,
+		"Cannot find certificate serial number.");
+            return(-1);
+        }
+    }
+
+    /*
+     * Certificate signature
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 16)) {
+	decodecert_error(be, conn, priv, "Cannot find signature section tag.");
+        return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    if (getcert_shared->debugging & DEBUG_DATA)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] Signature section is %d bytes in length.\n",
+	    conn->c_connid, length);
+    /* OID type */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 6)) {
+	decodecert_error(be, conn, priv,
+	    "Cannot find OID of Signature algorithm.");
+        return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    rc = decodecert_get_oid(be, conn, priv, length);
+    priv->current_certificate.subject_algorithm_id = oid_name[rc];
+    if (getcert_shared->debugging & DEBUG_DATA)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] Certificate Signature Algorithm is %.900s\n",
+	    conn->c_connid, priv->current_certificate.subject_algorithm_id);
+
+    /*
+     * algorithm parameters
+     * This field is optional.
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc >= 0) &&
+	(priv->tag_class == Universal) &&
+	(priv->tag_number == 16)) {
+	/* This is the start of the Certificate Issuer section. */
+	if (getcert_shared->debugging & DEBUG_DATA)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] There is no optional Parameters field.\n",
+		conn->c_connid);
+    } else {
+        length = decodecert_get_length(be, conn, priv);
+        if (getcert_shared->debugging & DEBUG_DATA) {
+	    if (length > 0)
+                syslog(LOG_DEBUG,
+	            "[%lu][debug] Algorithm parameters are %d bytes long.\n",
+		    conn->c_connid, length);
+            else
+	        syslog(LOG_DEBUG,
+                    "[%lu][debug] There are no Algorithm parameters.\n",
+		    conn->c_connid);
+        }
+        if (length > 0) {
+	    /* Skip over any algorithm parameters. */
+	    content_length = decodecert_get_content(be, conn, priv, length);
+	}
+	/* Next up is the Issuer section. */
+        rc = decodecert_get_identifier(be, conn, priv);
+    }
+
+    /*
+     * Certificate issuer
+     */
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 16)) {
+	decodecert_error(be, conn, priv, "Cannot find signatureValue tag.");
+        return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    if (getcert_shared->debugging & DEBUG_DATA)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] Issuer section is %d bytes in length.\n",
+	    conn->c_connid, length);
+    rc = decodecert_get_dn(be, conn, priv, length);
+    if (rc < 0)
+	return(-1);
+    len = strlen(priv->content_buffer);
+    if (len < MAX_DN_LENGTH)
+        strncpy(priv->current_certificate.issuer, priv->content_buffer,
+	        len + 1);
+    else
+        strncpy(priv->current_certificate.issuer, priv->content_buffer,
+		MAX_DN_LENGTH - 1);
+    if (getcert_shared->debugging & DEBUG_DATA) {
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Certificate Issuer:\n", conn->c_connid);
+	syslog(LOG_DEBUG,
+	    "[%lu][debug]     %.900s\n",
+	    conn->c_connid, priv->current_certificate.issuer);
+    }
+
+    /*
+     * Certificate validity dates
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 16)) {
+	decodecert_error(be, conn, priv, "Cannot find validity section tag.");
+	return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    if (getcert_shared->debugging & DEBUG_DATA) 
+        syslog(LOG_DEBUG,
+            "[%lu][debug] Validity section is %d bytes in length.\n",
+            conn->c_connid, length);
+    /* notBefore */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 23)) {
+	decodecert_error(be, conn, priv, "Cannot find tag for notBefore date.");
+        return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    content_length = decodecert_get_content(be, conn, priv, length);
+    if (content_length < 0) {
+	decodecert_error(be, conn, priv,
+	    "Cannot find notBefore date string length.");
+	return(-1);
+    } else {
+        strncpy(priv->current_certificate.validity_notbefore,
+		priv->content_buffer, 14);
+	priv->current_certificate.validity_notbefore[13] = '\0';
+   	if (getcert_shared->debugging & DEBUG_DATA)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] notBefore = %.900s\n",
+		conn->c_connid, priv->current_certificate.validity_notbefore);
+    }
+ 
+    /* notAfter */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 23)) {
+	decodecert_error(be, conn, priv, "Cannot find tag for notAfter date.");
+        return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    content_length = decodecert_get_content(be, conn, priv, length);
+    if (content_length < 0) {
+	decodecert_error(be, conn, priv,
+	    "Cannot find notAfter date string length.");
+	return(-1);
+    } else {
+        strncpy(priv->current_certificate.validity_notafter,
+		priv->content_buffer, 14);
+	priv->current_certificate.validity_notafter[13] = '\0';
+   	if (getcert_shared->debugging & DEBUG_DATA)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] notAfter = %.900s\n",
+		conn->c_connid, priv->current_certificate.validity_notafter);
+    }
+
+    /*
+     * Subject section
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 16)) {
+	decodecert_error(be, conn, priv,
+	    "Cannot find tag for Subject section.");
+        return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv); 
+    if (getcert_shared->debugging & DEBUG_DATA)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Subject section is %d bytes in length.\n",
+	    conn->c_connid, length);
+    /* Decode the Subject DN into the content buffer. */
+    rc = decodecert_get_dn(be, conn, priv, length);
+    if (rc < 0)
+        return(-1);
+    len = strlen(priv->content_buffer);
+    if (len < MAX_DN_LENGTH)
+	strncpy(priv->current_certificate.subject,
+		priv->content_buffer, len + 1);
+    else {
+	strncpy(priv->current_certificate.subject,
+		priv->content_buffer, MAX_DN_LENGTH - 1);
+	if (getcert_shared->debugging & DEBUG_DATA)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Subject DN too long (%d bytes) at offset %d.\n",
+		conn->c_connid, strlen(priv->content_buffer),
+		priv->total_octets);
+    }
+    if (getcert_shared->debugging & DEBUG_DATA) {
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Subject DN:\n", conn->c_connid);
+	syslog(LOG_DEBUG,
+	    "[%lu][debug]     %.900s\n",
+	    conn->c_connid, priv->current_certificate.subject);
+    }
+
+    /*
+     * The emailAddress OID {1 2 840 113549 1 9 1} should no longer be
+     * in the Subject DN, but it often is.  So we had better look for it
+     * so the email address can be added to the rfc822Name verification 
+     * check.
+     */
+    chrptr = strstr(priv->content_buffer, "emailAddress=");
+    if (chrptr != NULL) {
+	/* Skip over the attribute name. */
+	chrptr += 13;
+	len = strlen(chrptr);
+	if (len < MAX_EMAIL_LENGTH) {
+	    strncpy(priv->current_certificate.emailAddress, chrptr, len);
+	    priv->current_certificate.emailAddress[len] = '\0';
+	} else {
+	    strncpy(priv->current_certificate.emailAddress, chrptr,
+			MAX_EMAIL_LENGTH);
+	    priv->current_certificate.emailAddress[MAX_EMAIL_LENGTH - 1] = '\0';
+	}
+	/* Trim off the tail end of the DN string if   */
+	/* any of it follows the email address string. */ 
+	chrptr = strchr(priv->current_certificate.emailAddress, ',');
+	if (chrptr != NULL)
+	    chrptr[0] = '\0';
+	chrptr = strchr(priv->current_certificate.emailAddress, ' ');
+	if (chrptr != NULL)
+	    chrptr[0] = '\0';
+	chrptr = strchr(priv->current_certificate.emailAddress, '/');
+	if (chrptr != NULL)
+	    chrptr[0] = '\0';
+        if (getcert_shared->debugging & DEBUG_DATA)
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] Deprecated emailAddress OID found: %.900s\n",
+	        conn->c_connid, priv->current_certificate.emailAddress);
+    }
+
+    /*
+     * PublicKeyInfo section
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 16)) {
+	decodecert_error(be, conn, priv,
+	    "Cannot find tag for PublicKeyInfo section.");
+        return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    if (getcert_shared->debugging & DEBUG_DATA)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] PublicKeyInfo section is %d bytes in length.\n",
+            conn->c_connid, length);
+    /* PublicKeyInfo Algorithm Identifier */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 16)) {
+	decodecert_error(be, conn, priv,
+	    "Cannot find PublicKeyInfo Algorithm ID.");
+        return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    if (getcert_shared->debugging & DEBUG_DATA)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] Algorithm Identifier is %d bytes in length.\n",
+            conn->c_connid, length);
+    /* OID type */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 6)) {
+	decodecert_error(be, conn, priv,
+	    "Cannot find Public Key algorithm OID.");
+        return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    rc = decodecert_get_oid(be, conn, priv, length);
+    priv->current_certificate.subject_pkidata = oid_name[rc];
+    if (getcert_shared->debugging & DEBUG_DATA)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Public Key Algorithm is %.900s\n",
+	    conn->c_connid, priv->current_certificate.subject_pkidata);
+
+    /*
+     * algorithm parameters
+     * This field is optional.
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc >= 0) &&
+        (priv->tag_class == Universal) &&
+        (priv->tag_number == 3)) {
+        /* This is the start of the Public Key section. */
+        if (getcert_shared->debugging & DEBUG_DATA)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] There is no optional Parameters field.\n",
+                conn->c_connid);
+    } else {
+        length = decodecert_get_length(be, conn, priv);
+        if (getcert_shared->debugging & DEBUG_DATA) {
+            if (length > 0)
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] Algorithm parameters are %d bytes long.\n",
+                    conn->c_connid, length);
+            else
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] There are no Algorithm parameters.\n",
+                    conn->c_connid);
+        }
+        if (length > 0) {
+            /* Skip over any algorithm parameters. */
+            content_length = decodecert_get_content(be, conn, priv, length);
+        }
+        /* Next up is the Public Key section. */
+        rc = decodecert_get_identifier(be, conn, priv);
+    }
+
+    /* Public Key */
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 3)) {
+	decodecert_error(be, conn, priv, "Cannot find tag for Public Key.");
+	return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    if (getcert_shared->debugging & DEBUG_DATA)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Public Key is %d bytes in length.\n",
+	    conn->c_connid, length);
+    /* Skip over public key. */
+    content_length = decodecert_get_content(be, conn, priv, length);
+    if (content_length != length) {
+	decodecert_error(be, conn, priv, "Public Key length mismatch.");
+	return(-1);
+    }
+
+    if (priv->current_certificate.certversion > 0) {
+	/*
+         * TBS extensions sections [1] and [2].
+         */
+	if (getcert_shared->debugging & DEBUG_DATA)
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Looking for TBS extensions section.\n",
+		conn->c_connid);
+	rc = decodecert_get_identifier(be, conn, priv);
+	length = decodecert_get_length(be, conn, priv);
+	while ((rc == 0) && (priv->tag_class == Context_specific) &&
+		((priv->tag_number == 1) || (priv->tag_number == 2))) {
+	    if (priv->tag_number == 1) {
+		/* [1] IssuerUniqueID */
+		if (getcert_shared->debugging & DEBUG_DATA)
+		    syslog(LOG_DEBUG,
+			"[%lu][debug] issuerUniqueID section is %d %.64s\n",
+			conn->c_connid, length, "bytes in length.");
+		}
+	    if (priv->tag_number == 2) {
+		/* [2] subjectUniqueID */
+		if (getcert_shared->debugging & DEBUG_DATA)
+		    syslog(LOG_DEBUG,
+		       "[%lu][debug] subjectUniqueID section is %d %.64s\n",
+		       conn->c_connid, length, "bytes in length.");
+		}
+	    /* Skip over [1] & [2] values. */
+	    content_length = decodecert_get_content(be, conn, priv, length);
+	    if (content_length != length) {
+		decodecert_error(be, conn, priv, "UniqueID length mismatch.");
+	        return(-1);
+	    }
+	    rc = decodecert_get_identifier(be, conn, priv);
+	    if (rc == 0)
+		length = decodecert_get_length(be, conn, priv);
+	    else
+		length = 0;
+	} /* Next section. */
+
+	/* Check for extensions section [3]. */
+	if ((rc != 0) ||
+	    (priv->tag_class != Context_specific) ||
+	    (priv->tag_number != 3)) {
+	    if (getcert_shared->debugging & DEBUG_DATA)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] No TBS extensions section found.\n");
+	} else {
+	    rc = decodecert_read_extensions(be, conn, priv);
+	    if (rc < 0)
+		return(-1);
+	    rc = decodecert_get_identifier(be, conn, priv);
+	    length = decodecert_get_length(be, conn, priv); 
+	}
+    } /* Versions 2 & 3 */
+
+    /*
+     * Last, but not least, the two long awaited signature sections.
+     */
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 16)) {
+	decodecert_error(be, conn, priv, "Cannot find signatureAlgorithm tag.");
+	return(-1);
+    }
+    rc = decodecert_get_identifier(be, conn, priv);
+    length = decodecert_get_length(be, conn, priv);
+    rc = decodecert_get_oid(be, conn, priv, length);
+    priv->current_certificate.signature_algorithm_id = oid_name[rc];
+    if (getcert_shared->debugging & DEBUG_DATA)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] Signature Algorithm is %.900s\n", 
+	    conn->c_connid, priv->current_certificate.signature_algorithm_id);
+
+    /*
+     * algorithm parameters
+     * This field is optional.
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc >= 0) &&
+        (priv->tag_class == Universal) &&
+        (priv->tag_number == 3)) {
+        /* This is the start of the Signature value section. */
+        if (getcert_shared->debugging & DEBUG_DATA)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] There is no optional Parameters field.\n",
+                conn->c_connid);
+    } else {
+        length = decodecert_get_length(be, conn, priv);
+        if (getcert_shared->debugging & DEBUG_DATA) {
+            if (length > 0)
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] Algorithm parameters are %d bytes long.\n",
+                    conn->c_connid, length);
+            else
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] There are no Algorithm parameters.\n",
+                    conn->c_connid);
+        }
+        if (length > 0) {
+            /* Skip over any algorithm parameters. */
+            content_length = decodecert_get_content(be, conn, priv, length);
+        }
+        /* Next up is the Signature value section. */
+        rc = decodecert_get_identifier(be, conn, priv);
+    }
+
+    /* Signature value */
+    loc = priv->total_octets - 1;
+    length = decodecert_get_length(be, conn, priv);
+    length -= (priv->total_octets - loc);
+    /* Skip over public key. */
+    content_length = decodecert_get_content(be, conn, priv, length);
+    if (content_length != length) {
+	decodecert_error(be, conn, priv, "Public Key length mismatch.");
+        return(-1);
+    }
+    return(0);
+} /* decode_certificate */
+
+/*
+ * Read through the list of revoked certificates
+ * in the revokedCertificates section of the CRL.
+ * On entry, we have read in the sequence tag and 
+ * sequence length of the first cert in the revoked
+ * list.
+ *
+ * Return the number of revoked certs in the list.
+ * Return -1 on error.
+ */
+int
+decodecrl_revoked(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private  *priv,
+    int  list_length,
+    int  cert_length
+    )
+{
+    int  certnum, content_length, end_of_revoked_list,
+	 length, next_cert, rc;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    /* Where this section ends. */
+    end_of_revoked_list = priv->total_octets + (list_length - 2);
+    if (getcert_shared->debugging & DEBUG_DATA)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] revokedCertificates section ends at offset 0x%x\n",
+	    conn->c_connid, end_of_revoked_list);
+    /* Where the second cert entry begins. */
+    next_cert = priv->total_octets + cert_length;
+    if (getcert_shared->debugging & DEBUG_DATA)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] Second revoked cert entry starts at offset 0x%x\n",
+	    conn->c_connid, next_cert);
+
+    /* Loop through each certificate entry.                 */
+    /* We don't actually need any data from these entries,  */
+    /* but we will count the number of entries and take a   */
+    /* quick look at their structure to decide whether this */
+    /* is an undamaged CRL.                                 */
+
+    certnum = 0;
+    while (priv->total_octets < end_of_revoked_list) {
+	/*
+	 * cert serial number
+	 */
+	rc = decodecert_get_identifier(be, conn, priv);
+	if ((rc < 0) ||
+	    (priv->tag_class != Universal) ||
+	    (priv->tag_number != 2)) {
+	    decodecert_error(be, conn, priv,
+		"Cannot find tag for CertificateSerialNumber.");
+	    return(-1);
+	}
+	rc = decodecert_get_serial_number(be, conn, priv);
+	if (rc < 0) {
+	    decodecert_error(be, conn, priv,
+		"Cannot read certificate serial number in CRL.");
+	    return(-1);
+	}
+	/*
+	 * Certificate revocation date/time.
+	 */
+        rc = decodecert_get_identifier(be, conn, priv);
+	if ((rc < 0) ||
+            (priv->tag_class != Universal) ||
+            (priv->tag_number != 23)) {
+	    decodecert_error(be, conn, priv,
+	       "Cannot find tag for cert revocation date.");
+	    return(-1);
+	}
+        length = decodecert_get_length(be, conn, priv);
+        if (length > 0) {
+            content_length = decodecert_get_content(be, conn, priv, length);
+            if (content_length < 0) {
+                decodecert_error(be, conn, priv,
+                    "Cannot read certificate revocation date in CRL.");
+                return(-1);
+	    }
+	}
+	/*
+	 * Check for optional cert extensions.
+	 */
+	if (priv->total_octets < next_cert) {
+	    /* Skip over cert extensions */
+	    rc = decodecert_get_identifier(be, conn, priv);
+	    if ((rc < 0) ||
+	        (priv->tag_class != Universal) ||
+	        (priv->tag_number != 16)) {
+		decodecert_error(be, conn, priv,
+		    "Cannot find cert extensions section.");
+		return(-1);
+	    }
+	    length = decodecert_get_length(be, conn, priv);
+    	    if (length > 0) {
+	        content_length = decodecert_get_content(be, conn, priv, length);
+		if (content_length < 0) {
+		    decodecert_error(be, conn, priv,
+			"Cannot read extension section for this cert entry.");
+		    return(-1);
+		}
+	    }
+	}
+	certnum++;
+	if (getcert_shared->debugging & DEBUG_DATA) 
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Finished with cert entry %d\n", conn->c_connid, certnum);
+
+	if (priv->total_octets < end_of_revoked_list) {
+	    /* Start reading the next cert entry. */
+	    rc = decodecert_get_identifier(be, conn, priv);
+            if ((rc < 0) ||
+                (priv->tag_class != Universal) ||
+                (priv->tag_number != 16)) { 
+	        decodecert_error(be, conn, priv,
+	           "Cannot find next revoked cert entry in CRL.");
+	        return(-1);
+	    }
+	    length = decodecert_get_length(be, conn, priv);
+	    next_cert = priv->total_octets + length;
+	    if (getcert_shared->debugging & DEBUG_DATA)
+		syslog(LOG_DEBUG,
+		    "[%lu][debug] Next cert entry starts at offset 0x%x\n",
+		    conn->c_connid, next_cert);
+	}
+    } /* Next cert entry */
+
+    /* Tally the number of revoked certs we found. */
+    if ((getcert_shared->debugging & DEBUG_DATA) ||
+	(getcert_shared->debugging & DEBUG_GEN_HI))
+        syslog(LOG_DEBUG,
+            "[%lu][debug] %d revoked certificates listed in this CRL.\n",
+            conn->c_connid, certnum);
+    return(certnum);
+} /* decodecrl_revoked */
+
+/*
+ * Decode an X.509 Certificate Revocation List (CRL) in ASN.1 format.
+ * Return values of interest in the global current_crl structure.
+ * Return code = 0 successful
+ *             = Negative if unable to read the entire
+ *		 CRL or it fails a verification test.
+ */
+int
+decode_crl(
+    Backend     *be,
+    Connection  *conn,
+    struct getcert_private  *priv
+    )
+{
+    int  i, certnum, cert_length, content_length, len, length, rc,
+	 section_rc, section_tag, section_class, section_length;
+    struct tm  *utcstruct;
+    time_t  epoch;
+    struct getcert_data  *getcert_shared;
+
+    getcert_shared = be->be_private;
+
+    /* Initialize for this new CRL. */
+    priv->total_octets = 0;
+    priv->integer_error = FALSE;
+    priv->current_crl.crl_version = -1;
+    priv->current_crl.signature_algorithm_id = NULL;
+    priv->current_crl.crl_issuer[0] = '\0';
+    priv->current_crl.thisUpdate[0] = '\0';
+    priv->current_crl.nextUpdate[0] = '\0';
+    priv->current_crl.revoked_certs = 0;
+
+    /* Make sure we have a CRL to decode. */
+    if ((priv->attr_vals == NULL) || (priv->current_crl.crl_number < 0)) {
+	decodecert_error(be, conn, priv,
+	    "No CRL to examine.\n");
+	return(-1);
+    }
+
+    /*
+     * The first sequence tag tells us how long the CRL is.
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if (rc < 0) {
+        decodecert_error(be, conn, priv,
+            "Cannot read the beginning of this CRL.");
+        return(-1);
+    }
+
+    if ((priv->tag_class != Universal) || (priv->tag_number != 16)) {
+	decodecert_error(be, conn, priv,
+            "CRL does not appear to be in X.509 DER format.");
+        return(-1);
+    }
+
+    length = decodecert_get_length(be, conn, priv);
+    priv->current_crl.crl_length = priv->total_octets + length;
+    if (length >= 0) {
+        if (getcert_shared->debugging & DEBUG_GEN_LO)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] CRL DER length is %d bytes\n",
+                conn->c_connid, priv->current_crl.crl_length);
+    } else
+        return(-1);
+
+    /*
+     * The second sequence tag leads us to the TBSCertList length.
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+        (priv->tag_class != Universal) ||
+        (priv->tag_number != 16)) {
+        decodecert_error(be, conn, priv, "Cannot find TBSCertList tag.");
+        return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    if ((length < 0) || (length >= priv->current_crl.crl_length) ||
+        (priv->tag_number != 16)) {
+        decodecert_error(be, conn, priv, "Invalid TBSCertList length.");
+        return(-1);
+    }
+
+    /*
+     * TBSCertList section
+     */
+
+    /*
+     * Optional version number.
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if (rc < 0) {
+	decodecert_error(be, conn, priv,
+	    "Error at CRL version number.");
+	return(-1);
+    }
+    if ((priv->tag_class == Universal) &&
+        (priv->tag_number == 2)) {
+        /* This is a version number tag. */
+	length = decodecert_get_length(be, conn, priv);
+	if (length == 1) {
+            rc = decodecert_get_integer(be, conn, priv, length);
+            if (priv->integer_error)
+                return(-1);
+            else {
+                priv->current_crl.crl_version = rc;
+                if (getcert_shared->debugging & DEBUG_DATA)
+                    syslog(LOG_DEBUG,
+                        "[%lu][debug] CRL version is %d\n",
+                        conn->c_connid, rc + 1);
+            }
+        } else {
+	    decodecert_error(be, conn, priv,
+                "Cannot find CRL version number length.");
+            return(-1);
+        }
+	rc = decodecert_get_identifier(be, conn, priv);
+    }
+
+    /*
+     * Signature AlgorithmID
+     */
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+	(priv->tag_number != 16)) {
+	decodecert_error(be, conn, priv,
+	    "Cannot find CRL Signature AlgorithmID.");
+	return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    if (getcert_shared->debugging & DEBUG_DATA)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] Signature AlgorithmID section is %d bytes long.\n",
+            conn->c_connid, length);
+    /*
+     * OID type
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+        (priv->tag_class != Universal) ||
+        (priv->tag_number != 6)) {
+        decodecert_error(be, conn, priv,
+            "Cannot find OID of Signature AlgorithmID.");
+        return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    rc = decodecert_get_oid(be, conn, priv, length);
+    priv->current_crl.signature_algorithm_id = oid_name[rc];
+    if (getcert_shared->debugging & DEBUG_DATA)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] CRL Signature Algorithm is %.900s\n",
+            conn->c_connid, priv->current_crl.signature_algorithm_id);
+    /*
+     * Algorithm parameters
+     * This field is optional.
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc >= 0) &&
+        (priv->tag_class == Universal) &&
+        (priv->tag_number == 16)) {
+	/* This is the start of the CRL Issuer section. */
+	if (getcert_shared->debugging & DEBUG_DATA)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] There is no optional Parameters field.\n",
+                conn->c_connid);
+    } else {
+	length = decodecert_get_length(be, conn, priv);
+        if (getcert_shared->debugging & DEBUG_DATA) {
+            if (length > 0)
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] Algorithm parameters are %d bytes long.\n",
+                    conn->c_connid, length);
+            else
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] There are no Algorithm parameters.\n",
+                    conn->c_connid);
+        }
+        if (length > 0) {
+            /* Skip over any algorithm parameters. */
+            content_length = decodecert_get_content(be, conn, priv, length);
+        }
+        /* Next up is the CRL Issuer section. */
+        rc = decodecert_get_identifier(be, conn, priv);
+    }
+
+    /*
+     * CRL issuer
+     */
+    if ((rc < 0) ||
+        (priv->tag_class != Universal) ||
+        (priv->tag_number != 16)) {
+        decodecert_error(be, conn, priv, "Cannot find issuer name tag.");
+        return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    if (getcert_shared->debugging & DEBUG_DATA)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] Issuer section is %d bytes in length.\n",
+            conn->c_connid, length);
+    rc = decodecert_get_dn(be, conn, priv, length);
+    if (rc < 0)
+        return(-1);
+    len = strlen(priv->content_buffer);
+    if (len < MAX_DN_LENGTH)
+        strncpy(priv->current_crl.crl_issuer, priv->content_buffer,
+                len + 1);
+    else
+	strncpy(priv->current_crl.crl_issuer, priv->content_buffer,
+                MAX_DN_LENGTH - 1);
+    if (getcert_shared->debugging & DEBUG_DATA) {
+        syslog(LOG_DEBUG,
+            "[%lu][debug] CRL Issuer:\n", conn->c_connid);
+        syslog(LOG_DEBUG,
+            "[%lu][debug]     %.900s\n",
+            conn->c_connid, priv->current_crl.crl_issuer);
+    }
+
+    /*
+     * thisUpdate time
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc < 0) ||
+        (priv->tag_class != Universal) ||
+        (priv->tag_number != 23)) {
+        decodecert_error(be, conn, priv,
+	    "Cannot find tag for thisUpdate date.");
+        return(-1);
+    }
+    length = decodecert_get_length(be, conn, priv);
+    if (length > 0) {
+        content_length = decodecert_get_content(be, conn, priv, length);
+        if (content_length < 0) {
+            decodecert_error(be, conn, priv,
+                "Cannot find thisUpdate date.");
+            return(-1);
+        } else {
+            strncpy(priv->current_crl.thisUpdate, priv->content_buffer, 14);
+            priv->current_crl.thisUpdate[13] = '\0';
+            if (getcert_shared->debugging & DEBUG_DATA)
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] thisUpdate = %.900s\n",
+                    conn->c_connid, priv->current_crl.thisUpdate);
+	}
+    }
+
+    /*
+     * The remaining TBSCertList sections are optional:
+     *     nextUpdate
+     *     revokedCertificates
+     *     crlExtensions
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+
+    /*
+     * Optional nextUpdate time
+     */
+    if ((rc >= 0) &&
+        (priv->tag_class == Universal) &&
+        (priv->tag_number == 23)) {
+        length = decodecert_get_length(be, conn, priv);
+        if (length > 0) {
+            content_length = decodecert_get_content(be, conn, priv, length);
+            if (content_length < 0) {
+                decodecert_error(be, conn, priv,
+                    "Cannot find nextUpdate date string length.");
+                return(-1);
+            } else {
+                strncpy(priv->current_crl.nextUpdate, priv->content_buffer, 14);
+                priv->current_crl.nextUpdate[13] = '\0'; 
+                if (getcert_shared->debugging & DEBUG_DATA)
+                    syslog(LOG_DEBUG,
+                        "[%lu][debug] nextUpdate = %.900s\n",
+                        conn->c_connid, priv->current_crl.nextUpdate);
+            }
+	    rc = decodecert_get_identifier(be, conn, priv);
+	}
+    }
+
+    /*
+     *  We have to read ahead in order to be able to identify the 
+     *  following optional sections.  So we will save the section
+     *  header information at the start of each new section so we 
+     *  don't lose it.
+     */
+    section_rc = rc;
+    section_tag = priv->tag_number;
+    section_class = priv->tag_class;
+    section_length = decodecert_get_length(be, conn, priv);
+    rc = decodecert_get_identifier(be, conn, priv);
+    length = decodecert_get_length(be, conn, priv);
+    
+    /*
+     * Next section could be:
+     *    revokedCertificates
+     *    crlExtensions
+     *    signatureAlgorithm
+     */
+    if ((section_rc >= 0) &&
+	(section_class == Universal) &&
+	(section_tag == 16) &&
+	(rc >= 0) &&
+	(priv->tag_class == Universal) &&
+        (priv->tag_number == 16)) {
+	/*
+	 * revokedCertificates section
+	 */
+	rc = decodecrl_revoked(be, conn, priv, section_length, length);
+	if (rc < 0) {
+	    /* decodecrl_revoked will have logged the error. */
+	    return(-1);
+    	} else {
+	    priv->current_crl.revoked_certs = rc;
+	}
+        section_rc = decodecert_get_identifier(be, conn, priv);
+	section_tag = priv->tag_number;
+	section_class = priv->tag_class;
+	section_length = decodecert_get_length(be, conn, priv);
+	rc = decodecert_get_identifier(be, conn, priv);
+	length = decodecert_get_length(be, conn, priv);
+    } else {
+	if (getcert_shared->debugging & DEBUG_DATA)
+            syslog(LOG_DEBUG,
+		"[%lu][debug] No revokedCertificates section.\n", conn->c_connid);
+    }
+
+    /*
+     * Next section could be:
+     *    crlExtensions
+     *    signatureAlgorithm
+     */
+    if ((section_rc >= 0) &&
+        (section_class == Context_specific) &&
+	(section_tag == 0) &&
+	(rc >= 0) &&
+	(priv->tag_class == Universal) &&
+        (priv->tag_number == 16)) {
+	/*
+	 *  [0] crlExtensions
+	 */
+	/* Skip over crlExtensions section. */
+	if (section_length > 0) {
+            content_length =
+	        decodecert_get_content(be, conn, priv, length);
+	}
+        section_rc = decodecert_get_identifier(be, conn, priv);
+	section_tag = priv->tag_number;
+	section_class = priv->tag_class;
+	section_length = decodecert_get_length(be, conn, priv);
+	rc = decodecert_get_identifier(be, conn, priv);
+	length = decodecert_get_length(be, conn, priv);
+    } else {
+	if (getcert_shared->debugging & DEBUG_DATA)
+            syslog(LOG_DEBUG,
+		"[%lu][debug] No crlExtensions section.\n", conn->c_connid);
+    }
+
+    /*
+     * signatureAlgorithm section
+     */
+    if ((section_rc < 0) ||
+	(section_class != Universal) ||
+	(section_tag != 16)) {
+	decodecert_error(be, conn, priv,
+	    "Cannot find signatureAlgorithm section in CRL.");
+	return(-1);
+    }
+    if (getcert_shared->debugging & DEBUG_DATA)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] Signature AlgorithmID section is %d bytes long.\n",
+            conn->c_connid, section_length);
+    /*
+     * OID type
+     */
+    if ((rc < 0) ||
+        (priv->tag_class != Universal) ||
+        (priv->tag_number != 6)) {
+        decodecert_error(be, conn, priv,
+            "Cannot find OID of Signature AlgorithmID.");
+        return(-1);
+    }
+    rc = decodecert_get_oid(be, conn, priv, length);
+    priv->current_crl.signature_algorithm_id = oid_name[rc];
+    if (getcert_shared->debugging & DEBUG_DATA)
+        syslog(LOG_DEBUG,
+            "[%lu][debug] CRL Signature Algorithm is %.900s\n",
+            conn->c_connid, priv->current_crl.signature_algorithm_id);
+    /*
+     * Algorithm parameters
+     * This field is optional.
+     */
+    rc = decodecert_get_identifier(be, conn, priv);
+    if ((rc >= 0) &&
+        (priv->tag_class == Universal) &&
+        (priv->tag_number == 3)) {
+	/* This is the start of the signatureValue section. */
+	if (getcert_shared->debugging & DEBUG_DATA)
+            syslog(LOG_DEBUG,
+                "[%lu][debug] There is no optional Parameters field.\n",
+                conn->c_connid);
+    } else {
+	length = decodecert_get_length(be, conn, priv);
+        if (getcert_shared->debugging & DEBUG_DATA) {
+            if (length > 0)
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] Algorithm parameters are %d bytes long.\n",
+                    conn->c_connid, length);
+            else
+                syslog(LOG_DEBUG,
+                    "[%lu][debug] There are no Algorithm parameters.\n",
+                    conn->c_connid);
+        }
+        if (length > 0) {
+            /* Skip over any algorithm parameters. */
+            content_length = decodecert_get_content(be, conn, priv, length);
+        }
+        /* Next up is the signatureValue section. */
+        rc = decodecert_get_identifier(be, conn, priv);
+    }
+
+    /*
+     * signatureValue section
+     */
+    if ((rc < 0) ||
+	(priv->tag_class != Universal) ||
+        (priv->tag_number != 3)) {
+	decodecert_error(be, conn, priv,
+	    "Cannot find signatureValue data.");
+	return(-1);
+    }
+    /* Skip over signatureValue */
+    length = decodecert_get_length(be, conn, priv);
+    if (length > 0)
+	content_length = decodecert_get_content(be, conn, priv, length);
+
+    if (getcert_shared->debugging & DEBUG_DATA)
+	syslog(LOG_DEBUG,
+	    "[%lu][debug] End of CRL at offset %d (0x%x)\n",
+	    conn->c_connid, priv->total_octets, priv->total_octets);
+
+    /*
+     * The CRL is readable.  If further 
+     * checks are called for, do them now.
+     */
+/*
+ *  if (getcert_shared->crl_check == 2) {
+ *	if (priv->current_crl.nextUpdate[0] == '\0') {
+ *	    syslog(LOG_DEBUG,
+ *		"[%lu][debug] Optional nextUpdate date not present.\n",
+ *		conn->c_connid);
+ *	} else {
+ */
+            /* Today's date & time for validity checking. */
+/*
+ *           epoch = slap_get_time();
+ *           utcstruct = gmtime_r(&epoch, &priv->current_time);
+ *           if (utcstruct == NULL) {
+ *               syslog(LOG_INFO,
+ *                   "[%lu][error] Cannot get current system time. %.256s\n",
+ *		    conn->c_connid, "Skipping nextUpdate date check.");
+ *            } else {
+ *		if (getcert_shared->debugging & DEBUG_DATA)
+ *		    syslog(LOG_DEBUG,
+ *			"[%lu][debug] Checking CRL nextUpdate date.\n",
+ *			conn->c_connid);
+ *                rc = decodecert_check_time(be, conn, priv,
+ *                    priv->current_crl.nextUpdate);
+ *	        if (rc == 1) {
+ */
+  		    /* A newer CRL should have been available.
+  		     * Reject this one.
+  		     */
+/*
+ *		    syslog(LOG_INFO,
+ *			"[%lu] CRL\'s nextUpdate date (%.32s) has passed.\n",
+ *			conn->c_connid, priv->current_crl.nextUpdate);
+ *		    syslog(LOG_INFO,
+ *			"[%lu]     Rejecting CRL %d.\n",
+ *			conn->c_connid, priv->current_crl.crl_number + 1);
+ *		    return(-1);
+ *		}
+ *	    }
+ *	}
+ *    }
+ */
+
+    return(0);
+} /* decode_crl */
+
+/***************************
+ ***************************
+ **                       **
+ **  Main search process  **
+ **                       **
+ ***************************
+ ***************************/
+/*
+ * This routine is envoked by the slapd front end process
+ * to process an LDAP SEARCH command from an LDAP client.
+ */
+int
+getcert_back_search(Operation *op, SlapReply *rs)
+{
+    int	   i, j, len, old_count, rc, young_count;
+    char   *ptr;
+    time_t age, now_time;
+    struct getcert_private  priv;
+    struct getcert_data  *getcert_shared;
+
+    /*
+     * Get the server list(s).
+     * One or the other may be NULL.
+     */
+    getcert_shared = op->o_bd->be_private;
+    cert_server_list = getcert_shared->cert_serverlist;
+    ldap_server_list = getcert_shared->ldap_serverlist;
+
+    /*
+     * Initialize
+     */
+    priv.certificates = NULL;
+    priv.cert_number = 0;
+    priv.log_buffer[0] = '\0';
+
+    /*
+     * Get info about the LDAP client.
+     */
+    if (op->o_hdr->oh_conn->c_peer_name.bv_len < 1) {
+	priv.client_ip[0] = '\0';
+	syslog(LOG_INFO, "[%lu][error] No client IP address found.\n", op->o_hdr->oh_connid);
+    } else {
+        if (op->o_hdr->oh_conn->c_peer_name.bv_len < (MAX_IP_LENGTH - 1))
+	    strncpy(priv.client_ip, op->o_hdr->oh_conn->c_peer_name.bv_val,
+		op->o_hdr->oh_conn->c_peer_name.bv_len + 1);
+        else {
+	    strncpy(priv.client_ip, op->o_hdr->oh_conn->c_peer_name.bv_val, MAX_IP_LENGTH);
+	    priv.client_ip[MAX_IP_LENGTH - 1] = '\0';
+        }
+    }
+
+    if (op->o_hdr->oh_conn->c_peer_name.bv_len > 0) {
+	ptr = strchr(priv.client_ip, ':');
+        if (ptr != NULL)
+	   ptr[0] = '\0';
+    }
+
+    /*
+     * Begin the log entry for use when logging without debugging messages.
+     */
+    if (getcert_shared->debugging == DEBUG_NONE)
+	snprintf(priv.log_buffer, MAX_LOG_REC, "[%lu] %s ", op->o_hdr->oh_connid, priv.client_ip);
+    else
+	syslog(LOG_INFO, "[%lu] Client %.900s   LDAP version = %d\n",
+	    op->o_hdr->oh_connid, priv.client_ip, op->o_hdr->oh_protocol);
+
+    /*
+     * Display dn, ndn, and attribute list as
+     * specified in the client's search request.
+     */
+    if (getcert_shared->debugging & DEBUG_GEN_HI) {
+	if (op->o_req_dn.bv_len == 0) {
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] BaseDN specified in search request is NULL.\n",
+		op->o_hdr->oh_connid);
+	} else {
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] BaseDN specified in search request:\n",
+		op->o_hdr->oh_connid);
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug]     %.*s\n",
+		op->o_hdr->oh_connid, op->o_req_dn.bv_len, op->o_req_dn.bv_val);
+	}
+    }
+    if (getcert_shared->debugging & DEBUG_GEN_LO) {
+	if (op->o_req_ndn.bv_len == 0) {
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] %.128s\n", op->o_hdr->oh_connid,
+		"Normalized BaseDN specified in search request is NULL.\n");
+	} else {
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] Normalized DN specified in search request:\n",
+		op->o_hdr->oh_connid);
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug]     %.*s\n",
+		op->o_hdr->oh_connid, op->o_req_ndn.bv_len, op->o_req_ndn.bv_val);
+	}
+    }
+    if (getcert_shared->debugging & DEBUG_GEN_HI) {
+	if (op->ors_attrs == NULL) {
+	    syslog(LOG_DEBUG,
+	       "[%lu][debug] Attribute list in search request is NULL.\n",
+	       op->o_hdr->oh_connid);
+	} else {
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Attributes specified in search request:\n",
+		op->o_hdr->oh_connid);
+	    for (i = 0; op->ors_attrs[i].an_name.bv_val != NULL; i++)
+	        syslog(LOG_DEBUG,
+		    "[%lu][debug]      %.*s\n", op->o_hdr->oh_connid,
+		    op->ors_attrs[i].an_name.bv_len,
+                    op->ors_attrs[i].an_name.bv_val);
+	}
+    }
+
+    if (getcert_shared->debugging & DEBUG_GEN_LO) {
+	syslog(LOG_DEBUG, "[%lu][debug] Desired certificate type is %d\n",
+	    op->o_hdr->oh_connid, getcert_shared->certificate_type);
+	if (getcert_shared->cert_server_list_filename != NULL) {
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] Certificate Server List name is:\n", op->o_hdr->oh_connid);
+	    syslog(LOG_DEBUG,
+		"[%lu][debug]     %.900s\n",
+		op->o_hdr->oh_connid, getcert_shared->cert_server_list_filename);
+	    for (i = 0; cert_server_list[i] != NULL; i++);
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] There are %d servers listed in %.80s\n",
+	        op->o_hdr->oh_connid, i, "the Certificate Server List.");
+	}
+	if (getcert_shared->ldap_server_list_filename != NULL) {
+	    syslog(LOG_DEBUG,
+		"[%lu][debug] LDAP Server List name is:\n", op->o_hdr->oh_connid);
+	    syslog(LOG_DEBUG,
+		"[%lu][debug]     %.900s\n",
+		op->o_hdr->oh_connid, getcert_shared->ldap_server_list_filename);
+	    for (i = 0; ldap_server_list[i] != NULL; i++);
+	    syslog(LOG_DEBUG,
+	        "[%lu][debug] There are %d servers %.128s\n",
+	        op->o_hdr->oh_connid, i, "listed in the LDAP Server List.");
+	}
+    }
+
+    /*
+     * Remove any saved search results that are more than MAX_RESULTS_LIFE
+     * seconds old.  If clients that send multi-query sequences to fetch data
+     * haven't sent all the search requests required for it to access a
+     * certificate by then, it probably isn't a verbose client and has
+     * accepted the certificate sent in response to the first search query.
+     */
+    old_count = 0;
+    young_count = 0;
+    now_time = slap_get_time();
+    for (i = 0; i < getcert_shared->MAX_RESULTS_CACHE; i++) {
+        if (getcert_shared->last_search_results[i].ldif_ptr != NULL) {
+            if (now_time == (time_t) -1) {
+    	        syslog(LOG_INFO,
+    	            "[%lu][error] Cannot get local time.\n", op->o_hdr->oh_connid);
+    	    } else {
+    	        /* Is this entry too old to be needed anymore? */
+    	        age = (int)difftime(now_time,
+    			getcert_shared->last_search_results[i].timestamp);
+    	        if (age > getcert_shared->MAX_RESULTS_LIFE) {
+    	            old_count++;
+    		    if (getcert_shared->debugging & DEBUG_GEN_HI)
+    		        syslog(LOG_DEBUG,
+    		            "[%lu][debug] %.80s %d seconds.\n", op->o_hdr->oh_connid,
+    		            "Removing old search results after", age);
+		    /* Release memory allocated for attribute list. */
+		    for (j = 0;
+			 getcert_shared->last_search_results[i].search_attrs[j] != NULL; 
+			 j++) {
+		        if (getcert_shared->debugging & DEBUG_MEM)
+			    syslog(LOG_DEBUG,
+			        "[%lu][debug] Releasing %d %.64s\n", op->o_hdr->oh_connid,
+			        strlen(getcert_shared->last_search_results[i].search_attrs[j]) + 1,
+			        "memory bytes allocated for attribute name.");
+			free(getcert_shared->last_search_results[i].search_attrs[j]);
+			getcert_shared->last_search_results[i].search_attrs[j] = NULL;
+		    }
+		    /* Release memory allocated for LDIF buffer. */
+		    if (getcert_shared->debugging & DEBUG_MEM)
+			syslog(LOG_DEBUG,
+			    "[%lu][debug] Releasing %d bytes of memory %.64s\n",
+			    op->o_hdr->oh_connid,
+			    strlen(getcert_shared->last_search_results[i].ldif_ptr),
+			    "allocated for LDIF copy.");
+    		    free(getcert_shared->last_search_results[i].ldif_ptr);
+    		    getcert_shared->last_search_results[i].ldif_ptr = NULL;
+    	        } else {
+    		    young_count++;
+    	        }
+    	    }
+        }
+    }
+    if (getcert_shared->debugging & DEBUG_GEN_HI) {
+	syslog(LOG_DEBUG,
+	   "[%lu][debug] Removed %d entries from last_search_results table.\n",
+	   op->o_hdr->oh_connid, old_count);
+	syslog(LOG_DEBUG,
+	   "[%lu][debug] There are now %d entries %.128s\n",
+	   op->o_hdr->oh_connid, young_count, "in last_search_results table.");
+    }
+
+    /*
+     * To detect and terminate proxy infinite loops, we maintain a list
+     * of all LDAP queries we are currently processing.  If a query comes
+     * in that is identical (same client IP address, BaseDN, and filter
+     * string) to a query we are already processing, reject the new query
+     * with an LDAP_LOOP_DETECT return code.  In rare cases this may reject
+     * the occasional legitimate query, but proxy loops are proxy killers
+     * and must be stopped at all cost.
+     */
+    rc = check_pending_queries(op->o_bd, op->o_hdr->oh_conn, op, &op->ors_filterstr, &op->o_req_dn, &priv, rs);
+    if (rc != 0) {
+	/* New query has been rejected. */
+	if (getcert_shared->debugging == DEBUG_NONE)
+	    syslog(LOG_INFO, "%s\n", priv.log_buffer);
+	return(0);
+    }
+
+    /*
+     * Outlook and Entrust clients send multiple search queries in sequence
+     * to fetch user certificates.  However, only the first query in the 
+     * sequence has the email address in the search filter and they will
+     * ignore certificates returned before they send the last query in the
+     * sequence.  So we check the last sent results cache see if this query
+     * is the next query in the sequence.  If it is, resend the last search
+     * results.
+     * We identify follow-on queries of a multi-query sequence by looking
+     * at the client's IP address, the search filter, and the BaseDN (which
+     * will be the same DN we passed to them after the first query).
+     */
+    if ((op->ors_filterstr.bv_len >= 15) &&
+	  ((strncmp(op->ors_filterstr.bv_val, "(objectClass=*)", 15) == 0) || 
+	   (strncmp(op->ors_filterstr.bv_val, "(userCertificate=*)", 19) == 0) || 
+	   (strncmp(op->ors_filterstr.bv_val, "(userCertificate;binary=*)", 26) == 0)))
+    {
+	/* See if we recently sent search results to this client. */
+	for (i = 0; i < getcert_shared->MAX_RESULTS_CACHE; i++) {
+	    if (getcert_shared->last_search_results[i].ldif_ptr != NULL) {
+		/*
+		 * If this search request is from the same IP address and
+		 * specifies a base DN which is the same as the unique DN 
+		 * value returned with this previously send search result,
+		 * resend it.
+		 */
+		if (getcert_shared->debugging & DEBUG_GEN_LO) {
+		    syslog(LOG_DEBUG,
+		       "[%lu][debug] Comparing %.40s with %.40s\n", op->o_hdr->oh_connid,
+			getcert_shared->last_search_results[i].client_ip_addr,
+			priv.client_ip);
+		    syslog(LOG_DEBUG,
+		        "[%lu][debug] and comparing %.256s\n", op->o_hdr->oh_connid,
+		        getcert_shared->last_search_results[i].unique_ndn);
+		    syslog(LOG_DEBUG,
+			"[%lu][debug] with %.*s\n",
+			op->o_hdr->oh_connid, op->o_req_ndn.bv_len, op->o_req_ndn.bv_val);
+		}
+	
+	        if ((strcmp(getcert_shared->last_search_results[i].client_ip_addr,
+		        priv.client_ip) == 0) && 
+		    (strncmp(getcert_shared->last_search_results[i].unique_ndn,
+			op->o_req_ndn.bv_val, op->o_req_ndn.bv_len) == 0)) {
+		    /*
+		     * Same IP address and new base DN same as previous
+		     * result's unique DN. Resend the last search result.
+		     */
+		    if (getcert_shared->debugging & DEBUG_GEN_HI)
+		        syslog(LOG_DEBUG,
+		            "[%lu] Resending the last search results.", op->o_hdr->oh_connid);
+		    rc = send_search_results(op->o_bd, op->o_hdr->oh_conn, op,
+                         op->ors_attrs, op->ors_attrsonly,
+			 getcert_shared->last_search_results[i].ldif_ptr, priv.unique_ndn, rs);
+		    if (rc < 0) {
+	    		/* Couldn't return results. */
+			syslog(LOG_INFO,
+			    "[%lu][error] Could not resend search results.\n", op->o_hdr->oh_connid);
+                        rs->sr_err = LDAP_OPERATIONS_ERROR;
+                        rs->sr_text = getcert_err_msg[GETCERT_CANNOT_PROCESS];
+                        send_ldap_result(op, rs);
+		    } else {
+			/* Results returned. */
+			if (getcert_shared->debugging == DEBUG_NONE) {
+			    len = (MAX_LOG_REC - strlen(priv.log_buffer)) - 1;
+			    strncat(priv.log_buffer, "Search results resent from cache.", len);
+			} else {
+	    		    syslog(LOG_INFO,
+			        "[%lu] Search results resent from cache.\n", op->o_hdr->oh_connid);
+			}
+                        rs->sr_err = LDAP_SUCCESS;
+                        rs->sr_text = NULL;
+        		send_ldap_result(op, rs);
+		    }
+		    remove_pending_query(op->o_bd, op->o_hdr->oh_conn);
+		    if (getcert_shared->debugging == DEBUG_NONE)
+			syslog(LOG_INFO, "%s\n", priv.log_buffer);
+		    return(0);
+            	}
+	    }
+	} /* Next last_search_results entry */
+    }
+
+    /*
+     * The LDAP Proxy is designed to process any of three kinds of LDAP search request:
+     * 1) Find user certificates using an email address pulled from the search filter
+     *    as the search criteria.
+     * 2) Find a value for a single attribute from the attribute list using
+     *    the specified DN as the search criteria.
+     * 3) Find all attribute values at the specified DN using the search filter 
+     *    "(objectClass=*)" and a null attribute list as the search criteria.
+     *
+     * Use the following routines & server lists for each type of search:
+     * 1) find_certificate() & certificate_server_list.txt
+     * 2) find_object() & ldap_server_list.txt
+     * 3) find_all() & ldap_server_list.txt
+     */
+
+    /* Attempt to pull an email filter from the full LDAP filter string. */
+    if ((cert_server_list != NULL) && (op->ors_filterstr.bv_val != NULL)) {
+        if (get_mail_filter(op->o_bd, op->o_hdr->oh_conn,
+                        &op->ors_filterstr, &priv) == 0) {
+	    if (getcert_shared->debugging == DEBUG_NONE) {
+		len = (MAX_LOG_REC - strlen(priv.log_buffer)) - 1;
+		strncat(priv.log_buffer, "find_cert: ", len);
+	    }
+            find_certificate(op->o_bd, op->o_hdr->oh_conn, op, &op->o_req_dn, &op->o_req_ndn, &op->ors_filterstr, op->ors_attrs, op->ors_attrsonly, &priv, rs);
+	    remove_pending_query(op->o_bd, op->o_hdr->oh_conn);
+	    if (getcert_shared->debugging == DEBUG_NONE)
+		syslog(LOG_INFO, "%s", priv.log_buffer);
+	    return(0);
+	}
+        /* No email address in search filter. */
+    }
+
+    /* If a BaseDN and an attribute list is specified, search for those values. */
+    if ((ldap_server_list != NULL) && (op->o_req_dn.bv_len > 0) && (op->ors_attrs !=NULL)) {
+        if (getcert_shared->debugging == NONE) {
+            len = (MAX_LOG_REC - strlen(priv.log_buffer)) - 1;
+            strncat(priv.log_buffer, "find_obj: ", len);
+        }
+	find_object(op->o_bd, op->o_hdr->oh_conn, op, &op->o_req_dn, &op->o_req_ndn, &op->ors_filterstr, op->ors_attrs, op->ors_attrsonly, &priv, rs);
+	remove_pending_query(op->o_bd, op->o_hdr->oh_conn);
+	if (getcert_shared->debugging == DEBUG_NONE) 
+                syslog(LOG_INFO, "%s", priv.log_buffer);
+	return(0);
+    }
+
+    /* If no attributes specified, and the search filter specifies everything, */
+    /* attempt to return all attribute values from an LDAP entry.              */
+    if ((op->ors_attrs == NULL) && (op->o_req_dn.bv_len > 0) && 
+	(strncmp(op->ors_filterstr.bv_val, "(objectClass=*)", 15) == 0)) {
+	if (getcert_shared->debugging == DEBUG_NONE) {
+	    len = (MAX_LOG_REC - strlen(priv.log_buffer)) - 1;
+            strncat(priv.log_buffer, "find_all: ", len);
+        }
+	find_all(op->o_bd, op->o_hdr->oh_conn, op, &op->o_req_dn, &op->o_req_ndn, &op->ors_filterstr, op->ors_attrs, op->ors_attrsonly, &priv, rs);
+	remove_pending_query(op->o_bd, op->o_hdr->oh_conn);
+	if (getcert_shared->debugging == DEBUG_NONE) 
+                syslog(LOG_INFO, "%s", priv.log_buffer);
+	return(0);
+    }
+
+    /*
+     * This LDAP search request does not meet any of our search criteria.
+     */
+    if (getcert_shared->debugging == DEBUG_NONE) {
+	len = (MAX_LOG_REC - strlen(priv.log_buffer)) - 1;
+        strncat(priv.log_buffer, "Ignoring this search request.\n", len);
+    } else {
+        syslog(LOG_INFO,
+            "[%lu] Ignoring this search request.\n", op->o_hdr->oh_connid);
+	if (getcert_shared->debugging & DEBUG_GEN_HI) {
+            syslog(LOG_DEBUG,
+                "[%lu]    Filter: %.*s\n", op->o_hdr->oh_connid, op->ors_filterstr.bv_len, op->ors_filterstr.bv_val);
+            syslog(LOG_DEBUG,
+                "[%lu]    Base DN: %.*s\n", op->o_hdr->oh_connid, op->o_req_ndn.bv_len, op->o_req_ndn.bv_val);
+            if (op->ors_attrs == NULL) {
+	        syslog(LOG_DEBUG,
+	            "[%lu]    No attribute list.\n", op->o_hdr->oh_connid);
+            } else {
+		if (getcert_shared->debugging & DEBUG_GEN_LO) {
+                    for (i = 0; op->ors_attrs[i].an_name.bv_val != NULL; i++)
+                        syslog(LOG_DEBUG,
+                            "[%lu][debug]     Attribute: %.*s\n", op->o_hdr->oh_connid,
+                            op->ors_attrs[i].an_name.bv_len, op->ors_attrs[i].an_name.bv_val);
+		} else {
+	            for (i = 0; op->ors_attrs[i].an_name.bv_val != NULL; i++);
+	                syslog(LOG_DEBUG,
+		            "[%lu]    %d attributes specified in attribute list.\n",
+			    op->o_hdr->oh_connid, i);
+	        }
+            }
+        }
+    }
+
+    rs->sr_err = LDAP_SUCCESS;
+    rs->sr_text = NULL;
+    send_ldap_result(op, rs);
+    remove_pending_query(op->o_bd, op->o_hdr->oh_conn);
+    if (getcert_shared->debugging == DEBUG_NONE) 
+        syslog(LOG_INFO, "%s", priv.log_buffer);
+    return(0);
+}
diff -urN openldap-2.3.41-clean/servers/slapd/back-getcert/unbind.c openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/unbind.c
--- openldap-2.3.41-clean/servers/slapd/back-getcert/unbind.c	1969-12-31 19:00:00.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/back-getcert/unbind.c	2008-03-25 12:18:41.000000000 -0400
@@ -0,0 +1,28 @@
+/* unbind.c   3.3  3/16/2006  */
+/*
+ *  This is the unbind.c file for the getcert SLAPD backend.
+ *      Marc Amis    (marc.amis@boeing.com)
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "portable.h"
+#include "slap.h"
+#include "proto-getcert.h"
+#include "getcert.h"
+
+/*
+ *  No unbinding cleanup needed.
+ */
+int
+getcert_back_unbind(Operation *op, SlapReply *rs)
+{
+    struct getcert_data  *getcert_shared;
+    getcert_shared = op->o_bd->be_private;
+
+    if (getcert_shared->debugging & DEBUG_GEN_HI)
+        syslog(LOG_DEBUG,
+	    "[%lu][debug] Unbind requested.\n", op->o_hdr->oh_connid);
+
+    return(0);
+}
diff -urN openldap-2.3.41-clean/servers/slapd/result.c openldap-2.3.41-pathfinder-getcert/servers/slapd/result.c
--- openldap-2.3.41-clean/servers/slapd/result.c	2008-02-11 18:24:17.000000000 -0500
+++ openldap-2.3.41-pathfinder-getcert/servers/slapd/result.c	2008-03-25 12:18:41.000000000 -0400
@@ -530,7 +530,7 @@
 	if ( rs->sr_err == SLAPD_ABANDON || op->o_abandon )
 		goto abandon;
 
-	assert( !LDAP_API_ERROR( rs->sr_err ) );
+	//assert( !LDAP_API_ERROR( rs->sr_err ) );
 
 	Debug( LDAP_DEBUG_TRACE,
 		"send_ldap_result: %s p=%d\n",
@@ -549,7 +549,7 @@
 			NULL, NULL );
 	}
 
-	assert( rs->sr_err != LDAP_PARTIAL_RESULTS );
+	//assert( rs->sr_err != LDAP_PARTIAL_RESULTS );
 
 	if ( rs->sr_err == LDAP_REFERRAL ) {
 		if( op->o_domain_scope ) rs->sr_ref = NULL;
